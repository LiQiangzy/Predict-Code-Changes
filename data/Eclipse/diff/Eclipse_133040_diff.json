{
    "92e2d551694f8c66162991728d31adb4310f2411": {
        "core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/CPPSemantics.java": {
            "meta_a": {
                "name": "core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/CPPSemantics.java",
                "content_type": "text/x-java",
                "lines": 4624,
                "web_links": [
                    {
                        "name": "browse",
                        "url": "/r/plugins/gitiles/cdt/org.eclipse.cdt/+/d085e955c72e7ce382620a78dee2643e093d9d96/core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/CPPSemantics.java",
                        "target": "_blank"
                    }
                ]
            },
            "meta_b": {
                "name": "core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/CPPSemantics.java",
                "content_type": "text/x-java",
                "lines": 4624,
                "web_links": [
                    {
                        "name": "browse",
                        "url": "/r/plugins/gitiles/cdt/org.eclipse.cdt/+/refs/changes/40/133040/1/core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/CPPSemantics.java",
                        "target": "_blank"
                    }
                ]
            },
            "change_type": "MODIFIED",
            "diff_header": [
                "diff --git a/core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/CPPSemantics.java b/core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/CPPSemantics.java",
                "index d4e6b66..eb5c5a9 100644",
                "--- a/core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/CPPSemantics.java",
                "+++ b/core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/CPPSemantics.java"
            ],
            "content": [
                {
                    "ab": [
                        "/*******************************************************************************",
                        " * Copyright (c) 2004, 2016 IBM Corporation and others.",
                        " *",
                        " * This program and the accompanying materials",
                        " * are made available under the terms of the Eclipse Public License 2.0",
                        " * which accompanies this distribution, and is available at",
                        " * https://www.eclipse.org/legal/epl-2.0/",
                        " *",
                        " * SPDX-License-Identifier: EPL-2.0",
                        " *",
                        " * Contributors:",
                        " *     Andrew Niefer (IBM) - Initial API and implementation",
                        " *     Markus Schorn (Wind River Systems)",
                        " *     Bryan Wilkinson (QNX)",
                        " *     Andrew Ferguson (Symbian)",
                        " *     Sergey Prigogin (Google)",
                        " *     Mike Kucera (IBM)",
                        " *     Thomas Corbat (IFS)",
                        " *     Nathan Ridge",
                        " *     Richard Eames",
                        " *******************************************************************************/",
                        "package org.eclipse.cdt.internal.core.dom.parser.cpp.semantics;",
                        "",
                        "import static org.eclipse.cdt.core.dom.ast.IASTExpression.ValueCategory.LVALUE;",
                        "import static org.eclipse.cdt.core.dom.ast.IASTExpression.ValueCategory.PRVALUE;",
                        "import static org.eclipse.cdt.internal.core.dom.parser.cpp.semantics.SemanticUtil.ALLCVQ;",
                        "import static org.eclipse.cdt.internal.core.dom.parser.cpp.semantics.SemanticUtil.ARRAY;",
                        "import static org.eclipse.cdt.internal.core.dom.parser.cpp.semantics.SemanticUtil.CVTYPE;",
                        "import static org.eclipse.cdt.internal.core.dom.parser.cpp.semantics.SemanticUtil.MPTR;",
                        "import static org.eclipse.cdt.internal.core.dom.parser.cpp.semantics.SemanticUtil.PTR;",
                        "import static org.eclipse.cdt.internal.core.dom.parser.cpp.semantics.SemanticUtil.REF;",
                        "import static org.eclipse.cdt.internal.core.dom.parser.cpp.semantics.SemanticUtil.TDEF;",
                        "import static org.eclipse.cdt.internal.core.dom.parser.cpp.semantics.SemanticUtil.calculateInheritanceDepth;",
                        "import static org.eclipse.cdt.internal.core.dom.parser.cpp.semantics.SemanticUtil.getNestedType;",
                        "import static org.eclipse.cdt.internal.core.dom.parser.cpp.semantics.SemanticUtil.getUltimateTypeUptoPointers;",
                        "import static org.eclipse.cdt.internal.core.dom.parser.cpp.semantics.SemanticUtil.isConversionOperator;",
                        "",
                        "import java.util.ArrayDeque;",
                        "import java.util.ArrayList;",
                        "import java.util.Arrays;",
                        "import java.util.Collection;",
                        "import java.util.Collections;",
                        "import java.util.Deque;",
                        "import java.util.HashMap;",
                        "import java.util.HashSet;",
                        "import java.util.List;",
                        "import java.util.Set;",
                        "import java.util.regex.Matcher;",
                        "import java.util.regex.Pattern;",
                        "",
                        "import org.eclipse.cdt.core.CCorePlugin;",
                        "import org.eclipse.cdt.core.dom.IName;",
                        "import org.eclipse.cdt.core.dom.ast.ASTNodeProperty;",
                        "import org.eclipse.cdt.core.dom.ast.ASTVisitor;",
                        "import org.eclipse.cdt.core.dom.ast.DOMException;",
                        "import org.eclipse.cdt.core.dom.ast.EScopeKind;",
                        "import org.eclipse.cdt.core.dom.ast.IASTBinaryExpression;",
                        "import org.eclipse.cdt.core.dom.ast.IASTCastExpression;",
                        "import org.eclipse.cdt.core.dom.ast.IASTCompositeTypeSpecifier;",
                        "import org.eclipse.cdt.core.dom.ast.IASTCompoundStatement;",
                        "import org.eclipse.cdt.core.dom.ast.IASTDeclSpecifier;",
                        "import org.eclipse.cdt.core.dom.ast.IASTDeclaration;",
                        "import org.eclipse.cdt.core.dom.ast.IASTDeclarationStatement;",
                        "import org.eclipse.cdt.core.dom.ast.IASTDeclarator;",
                        "import org.eclipse.cdt.core.dom.ast.IASTElaboratedTypeSpecifier;",
                        "import org.eclipse.cdt.core.dom.ast.IASTEnumerationSpecifier.IASTEnumerator;",
                        "import org.eclipse.cdt.core.dom.ast.IASTEqualsInitializer;",
                        "import org.eclipse.cdt.core.dom.ast.IASTExpression;",
                        "import org.eclipse.cdt.core.dom.ast.IASTExpression.ValueCategory;",
                        "import org.eclipse.cdt.core.dom.ast.IASTFieldReference;",
                        "import org.eclipse.cdt.core.dom.ast.IASTFunctionCallExpression;",
                        "import org.eclipse.cdt.core.dom.ast.IASTFunctionDeclarator;",
                        "import org.eclipse.cdt.core.dom.ast.IASTFunctionDefinition;",
                        "import org.eclipse.cdt.core.dom.ast.IASTIdExpression;",
                        "import org.eclipse.cdt.core.dom.ast.IASTImplicitNameOwner;",
                        "import org.eclipse.cdt.core.dom.ast.IASTInitializer;",
                        "import org.eclipse.cdt.core.dom.ast.IASTInitializerClause;",
                        "import org.eclipse.cdt.core.dom.ast.IASTLabelStatement;",
                        "import org.eclipse.cdt.core.dom.ast.IASTLiteralExpression;",
                        "import org.eclipse.cdt.core.dom.ast.IASTName;",
                        "import org.eclipse.cdt.core.dom.ast.IASTNameOwner;",
                        "import org.eclipse.cdt.core.dom.ast.IASTNamedTypeSpecifier;",
                        "import org.eclipse.cdt.core.dom.ast.IASTNode;",
                        "import org.eclipse.cdt.core.dom.ast.IASTParameterDeclaration;",
                        "import org.eclipse.cdt.core.dom.ast.IASTReturnStatement;",
                        "import org.eclipse.cdt.core.dom.ast.IASTSimpleDeclaration;",
                        "import org.eclipse.cdt.core.dom.ast.IASTStatement;",
                        "import org.eclipse.cdt.core.dom.ast.IASTTranslationUnit;",
                        "import org.eclipse.cdt.core.dom.ast.IASTTypeId;",
                        "import org.eclipse.cdt.core.dom.ast.IASTTypeIdExpression;",
                        "import org.eclipse.cdt.core.dom.ast.IASTTypeIdInitializerExpression;",
                        "import org.eclipse.cdt.core.dom.ast.IASTUnaryExpression;",
                        "import org.eclipse.cdt.core.dom.ast.IBasicType;",
                        "import org.eclipse.cdt.core.dom.ast.IBasicType.Kind;",
                        "import org.eclipse.cdt.core.dom.ast.IBinding;",
                        "import org.eclipse.cdt.core.dom.ast.ICompositeType;",
                        "import org.eclipse.cdt.core.dom.ast.IEnumeration;",
                        "import org.eclipse.cdt.core.dom.ast.IEnumerator;",
                        "import org.eclipse.cdt.core.dom.ast.IFunction;",
                        "import org.eclipse.cdt.core.dom.ast.IFunctionType;",
                        "import org.eclipse.cdt.core.dom.ast.IPointerType;",
                        "import org.eclipse.cdt.core.dom.ast.IProblemBinding;",
                        "import org.eclipse.cdt.core.dom.ast.IScope;",
                        "import org.eclipse.cdt.core.dom.ast.IScope.ScopeLookupData;",
                        "import org.eclipse.cdt.core.dom.ast.ISemanticProblem;",
                        "import org.eclipse.cdt.core.dom.ast.IType;",
                        "import org.eclipse.cdt.core.dom.ast.ITypedef;",
                        "import org.eclipse.cdt.core.dom.ast.IVariable;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTAliasDeclaration;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTCapture;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTCatchHandler;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTCompositeTypeSpecifier;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTCompositeTypeSpecifier.ICPPASTBaseSpecifier;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTConstructorChainInitializer;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTConstructorInitializer;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTConversionName;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTDeclSpecifier;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTDeclarator;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTDecltypeSpecifier;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTDeleteExpression;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTEnumerationSpecifier;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTExpression;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTFieldReference;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTForStatement;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTFunctionDeclarator;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTFunctionDefinition;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTIfStatement;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTInitCapture;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTInitializerClause;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTInitializerList;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTLambdaExpression;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTLinkageSpecification;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTLiteralExpression;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTNamedTypeSpecifier;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTNamespaceAlias;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTNamespaceDefinition;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTNewExpression;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTParameterDeclaration;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTQualifiedName;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTRangeBasedForStatement;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTSimpleDeclSpecifier;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTSimpleTypeConstructorExpression;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTSimpleTypeTemplateParameter;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTSwitchStatement;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTTemplateDeclaration;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTTemplateId;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTTemplateParameter;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTTemplateSpecialization;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTTemplatedTypeTemplateParameter;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTTranslationUnit;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTTypeId;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTUnaryExpression;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTUsingDeclaration;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTUsingDirective;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTWhileStatement;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPAliasTemplate;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPBase;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPBlockScope;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPClassScope;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPClassSpecialization;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPClassTemplate;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPClassTemplatePartialSpecialization;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPClassType;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPConstructor;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPField;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPFunction;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPFunctionInstance;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPFunctionSpecialization;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPFunctionTemplate;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPFunctionType;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPMember;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPMethod;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPNamespace;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPNamespaceScope;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPParameter;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPPartialSpecialization;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPPointerToMemberType;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPReferenceType;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPScope;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPSpecialization;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPTemplateArgument;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPTemplateDefinition;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPTemplateInstance;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPTemplateNonTypeParameter;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPTemplateParameter;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPTemplateScope;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPTemplateTemplateParameter;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPTemplateTypeParameter;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPUsingDeclaration;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPUsingDirective;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPVariable;",
                        "import org.eclipse.cdt.core.index.IIndex;",
                        "import org.eclipse.cdt.core.index.IIndexBinding;",
                        "import org.eclipse.cdt.core.index.IIndexFile;",
                        "import org.eclipse.cdt.core.index.IIndexFileSet;",
                        "import org.eclipse.cdt.core.index.IIndexName;",
                        "import org.eclipse.cdt.core.parser.util.ArrayUtil;",
                        "import org.eclipse.cdt.core.parser.util.CharArrayObjectMap;",
                        "import org.eclipse.cdt.core.parser.util.CharArrayUtils;",
                        "import org.eclipse.cdt.core.parser.util.CollectionUtils;",
                        "import org.eclipse.cdt.core.parser.util.DebugUtil;",
                        "import org.eclipse.cdt.core.parser.util.IUnaryPredicate;",
                        "import org.eclipse.cdt.core.parser.util.ObjectSet;",
                        "import org.eclipse.cdt.internal.core.dom.parser.ASTAmbiguousNode;",
                        "import org.eclipse.cdt.internal.core.dom.parser.ASTInternal;",
                        "import org.eclipse.cdt.internal.core.dom.parser.ASTNode;",
                        "import org.eclipse.cdt.internal.core.dom.parser.ASTQueries;",
                        "import org.eclipse.cdt.internal.core.dom.parser.IASTAmbiguousDeclarator;",
                        "import org.eclipse.cdt.internal.core.dom.parser.IASTInternalScope;",
                        "import org.eclipse.cdt.internal.core.dom.parser.IRecursionResolvingBinding;",
                        "import org.eclipse.cdt.internal.core.dom.parser.ITypeContainer;",
                        "import org.eclipse.cdt.internal.core.dom.parser.IntegralValue;",
                        "import org.eclipse.cdt.internal.core.dom.parser.ProblemBinding;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPASTIdExpression;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPASTLiteralExpression;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPASTName;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPASTNameBase;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPASTTranslationUnit;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPBasicType;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPBuiltinParameter;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPCompositeBinding;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPDeferredConstructor;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPDeferredFunction;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPFunctionType;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPImplicitFunction;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPNamespace;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPNamespaceScope;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPPointerType;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPReferenceType;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPScope;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPTemplateNonTypeArgument;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPTemplateParameterMap;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPUnknownField;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPUnknownMemberClass;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPUnknownMethod;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPUsingDeclaration;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPUsingDirective;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPVariable;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.ICPPASTInternalScope;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.ICPPClassSpecializationScope;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.ICPPDeferredClassInstance;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.ICPPEvaluation;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.ICPPInternalBinding;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.ICPPInternalNamespaceScope;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.ICPPUnknownBinding;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.ICPPUnknownType;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.OverloadableOperator;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.semantics.CPPTemplates.TypeSelection;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.semantics.Conversions.Context;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.semantics.Conversions.UDCMode;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.semantics.Cost.Rank;",
                        "import org.eclipse.cdt.internal.core.pdom.dom.IPDOMAdaptedASTNode;",
                        "import org.eclipse.core.runtime.CoreException;",
                        "import org.eclipse.core.runtime.IStatus;",
                        "",
                        "/**",
                        " * Name resolution.",
                        " */",
                        "public class CPPSemantics {",
                        "\t/**",
                        "\t * The maximum depth to search ancestors before assuming infinite looping.",
                        "\t */",
                        "\tpublic static final int MAX_INHERITANCE_DEPTH = 40;",
                        "",
                        "\tpublic static final String EMPTY_NAME = \"\"; //$NON-NLS-1$",
                        "\tpublic static final char[] OPERATOR_ = new char[] { 'o', 'p', 'e', 'r', 'a', 't', 'o', 'r', ' ' };",
                        "\tpublic static final IType VOID_TYPE = new CPPBasicType(Kind.eVoid, 0);",
                        "\tpublic static final IType INT_TYPE = new CPPBasicType(Kind.eInt, 0);",
                        "",
                        "\tprivate static final char[] CALL_FUNCTION = \"call-function\".toCharArray(); //$NON-NLS-1$",
                        "\tprivate static final ICPPEvaluation[] NO_INITCLAUSE_EVALUATION = {};",
                        "",
                        "\t// Set to true for debugging.",
                        "\tpublic static boolean traceBindingResolution = false;",
                        "\tpublic static int traceIndent = 0;",
                        "",
                        "\t// special return value for costForFunctionCall",
                        "\tprivate static final FunctionCost CONTAINS_DEPENDENT_TYPES = new FunctionCost(null, 0);",
                        "",
                        "\t// A regular expression for matching qualified names.  This allows for optional global qualification",
                        "\t// (leading ::) and then separates the first part of the name from the rest (if present).  There are",
                        "\t// three capture groups:",
                        "\t//   (1) If the input name specifies the global namespace (leading ::) then capture group 1 will",
                        "\t//       be ::.  Group 1 will be null otherwise.",
                        "\t//   (2) The text of the first component of the qualified name, including leading :: if present in",
                        "\t//       the input string.  Leading and trailing whitespace is trimmed.  There is no effort to check",
                        "\t//       that the name contains valid C++ identifier characters.",
                        "\t//   (3) The text of everything after the first component of the qualified name.",
                        "\t//",
                        "\t// E.g., -- Input Name --   ---- Capture Groups ----",
                        "\t//       \"::nsA::nsB::b\" => { \"::\", \"nsA\", \"nsB::b\" }",
                        "\t//       \"a\"             => { null, \"a\",   null     }",
                        "\t//       \"::  i\"         => { \"::\", \"i\",   null     }",
                        "\tprivate static final Pattern QUALNAME_REGEX = Pattern.compile(\"^\\\\s*(::)?\\\\s*([^\\\\s:]+)\\\\s*(?:::(.*))?$\"); //$NON-NLS-1$",
                        "",
                        "\t// This flag controls whether name lookup is allowed to find bindings in headers",
                        "\t// that are not reachable via includes from the file containing the name.",
                        "\t// Generally this is not allowed, but certain consumers, such as IncludeOrganizer,",
                        "\t// need it (since the whole point of IncludeOrganizer is to find missing headers).",
                        "\tprivate static final ThreadLocal<Boolean> fAllowPromiscuousBindingResolution = new ThreadLocal<Boolean>() {",
                        "\t\t@Override",
                        "\t\tprotected Boolean initialValue() {",
                        "\t\t\treturn false;",
                        "\t\t}",
                        "\t};",
                        "",
                        "\tprivate static final ThreadLocal<Deque<IASTNode>> fLookupPoints = new ThreadLocal<Deque<IASTNode>>() {",
                        "\t\t@Override",
                        "\t\tprotected Deque<IASTNode> initialValue() {",
                        "\t\t\treturn new ArrayDeque<>();",
                        "\t\t}",
                        "\t};",
                        "",
                        "\tpublic static void pushLookupPoint(IASTNode point) {",
                        "\t\tfLookupPoints.get().push(point);",
                        "\t}",
                        "",
                        "\tpublic static void popLookupPoint() {",
                        "\t\tfLookupPoints.get().pop();",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Get the current point of instantiation / point of lookup for name lookups.",
                        "\t *",
                        "\t * NOTE: This is meant to be used primarily for \"declaredBefore\" purposes, that is,",
                        "\t *       for determining whether something was declared before or after the point",
                        "\t *       of lookup. It is NOT meant to be used as a general mechanism for accessing",
                        "\t *       information about a call site without having to pass that information along",
                        "\t *       the usual way (via function arguments).",
                        "\t */",
                        "\tpublic static IASTNode getCurrentLookupPoint() {",
                        "\t\tDeque<IASTNode> lookupPoints = fLookupPoints.get();",
                        "\t\treturn lookupPoints.isEmpty() ? null : lookupPoints.peek();",
                        "\t}",
                        "",
                        "\tstatic protected IBinding resolveBinding(IASTName name) {",
                        "\t\tif (traceBindingResolution) {",
                        "\t\t\tfor (int i = 0; i < traceIndent; i++) {",
                        "\t\t\t\tSystem.out.print(\"  \"); //$NON-NLS-1$",
                        "\t\t\t}",
                        "\t\t\tSystem.out.println(\"Resolving \" + name + ':' + ((ASTNode) name).getOffset()); //$NON-NLS-1$",
                        "\t\t\ttraceIndent++;",
                        "\t\t}",
                        "\t\tif (name instanceof CPPASTNameBase) {",
                        "\t\t\t((CPPASTNameBase) name).incResolutionDepth();",
                        "\t\t}",
                        "",
                        "\t\t// 1: Get some context info off of the name to figure out what kind of lookup we want.",
                        "\t\tLookupData data = createLookupData(name);",
                        "",
                        "\t\tIBinding binding;",
                        "\t\tpushLookupPoint(name);",
                        "\t\ttry {",
                        "\t\t\ttry {",
                        "\t\t\t\t// 2: Lookup",
                        "\t\t\t\tlookup(data, null);",
                        "",
                        "\t\t\t\t// Perform argument dependent lookup",
                        "\t\t\t\tif (data.checkAssociatedScopes() && !data.hasTypeOrMemberFunctionOrVariableResult()) {",
                        "\t\t\t\t\tdoArgumentDependentLookup(data);",
                        "\t\t\t\t}",
                        "\t\t\t} catch (DOMException e) {",
                        "\t\t\t\tdata.problem = (ProblemBinding) e.getProblem();",
                        "\t\t\t}",
                        "\t\t\tif (data.problem != null)",
                        "\t\t\t\treturn data.problem;",
                        "",
                        "\t\t\t// 3: Resolve ambiguities",
                        "\t\t\ttry {",
                        "\t\t\t\tbinding = resolveAmbiguities(data);",
                        "\t\t\t} catch (DOMException e) {",
                        "\t\t\t\tbinding = e.getProblem();",
                        "\t\t\t}",
                        "\t\t\t// 4: Post processing",
                        "\t\t\tbinding = postResolution(binding, data);",
                        "\t\t} finally {",
                        "\t\t\tpopLookupPoint();",
                        "\t\t}",
                        "\t\tif (traceBindingResolution) {",
                        "\t\t\ttraceIndent--;",
                        "\t\t\tfor (int i = 0; i < traceIndent; i++) {",
                        "\t\t\t\tSystem.out.print(\"  \"); //$NON-NLS-1$",
                        "\t\t\t}",
                        "\t\t\tSystem.out.println(\"Resolved  \" + name + ':' + ((ASTNode) name).getOffset() + //$NON-NLS-1$",
                        "\t\t\t\t\t\" to \" + DebugUtil.toStringWithClass(binding) + ':' + System.identityHashCode(binding)); //$NON-NLS-1$",
                        "\t\t}",
                        "\t\treturn binding;",
                        "\t}",
                        "",
                        "\tprotected static IBinding postResolution(IBinding binding, IASTName name) {",
                        "\t\tLookupData data = createLookupData(name);",
                        "\t\treturn postResolution(binding, data);",
                        "\t}",
                        "",
                        "\tprivate static IBinding postResolution(IBinding binding, LookupData data) {",
                        "\t\tfinal IASTName lookupName = data.getLookupName();",
                        "\t\tif (lookupName == null)",
                        "\t\t\treturn binding;",
                        "",
                        "\t\t// If this is the unqualified name of a function in a function call in a template and some",
                        "\t\t// of the function arguments are dependent, a matching function could be found via",
                        "\t\t// argument-dependent lookup at the point of instantiation.",
                        "\t\tif (binding == null || binding instanceof IProblemBinding) {",
                        "\t\t\tif (!data.qualified && data.isFunctionCall()",
                        "\t\t\t\t\t&& CPPTemplates.containsDependentType(data.getFunctionArgumentTypes())) {",
                        "\t\t\t\tbinding = CPPDeferredFunction.createForName(lookupName.getSimpleID());",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\tif (binding instanceof IProblemBinding)",
                        "\t\t\treturn binding;",
                        "",
                        "\t\tIASTNode lookupPoint = data.getLookupPoint();",
                        "",
                        "\t\tif (binding == null && data.checkClassContainingFriend()) {",
                        "\t\t\t// 3.4.1-10 If we don't find a name used in a friend declaration in the member",
                        "\t\t\t// declaration's class, we should look in the class granting friendship.",
                        "\t\t\tIASTNode parent = lookupName.getParent();",
                        "\t\t\twhile (parent != null && !(parent instanceof ICPPASTCompositeTypeSpecifier)) {",
                        "\t\t\t\tparent = parent.getParent();",
                        "\t\t\t}",
                        "\t\t\tif (parent instanceof ICPPASTCompositeTypeSpecifier) {",
                        "\t\t\t\tIScope scope = ((ICPPASTCompositeTypeSpecifier) parent).getScope();",
                        "\t\t\t\ttry {",
                        "\t\t\t\t\tlookup(data, scope);",
                        "\t\t\t\t\tbinding = resolveAmbiguities(data);",
                        "\t\t\t\t} catch (DOMException e) {",
                        "\t\t\t\t\tbinding = e.getProblem();",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\t// Explicit type conversion in functional notation.",
                        "\t\tif (binding instanceof ICPPClassTemplate && lookupName instanceof ICPPASTTemplateId) {",
                        "\t\t\tfinal IASTNode parent = lookupName.getParent();",
                        "\t\t\tif (parent instanceof IASTIdExpression",
                        "\t\t\t\t\t&& parent.getPropertyInParent() == IASTFunctionCallExpression.FUNCTION_NAME) {",
                        "\t\t\t\treturn binding;",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\t/* 14.6.1-1:",
                        "\t\t * Within the scope of a class template, when the name of the template is neither qualified",
                        "\t\t * nor followed by <, it is equivalent to the name followed by the template arguments",
                        "\t\t * enclosed in <>.",
                        "\t\t */",
                        "\t\tif (binding instanceof ICPPClassTemplate && !(binding instanceof ICPPClassSpecialization)",
                        "\t\t\t\t&& !(binding instanceof ICPPTemplateParameter) && !(lookupName instanceof ICPPASTTemplateId)) {",
                        "\t\t\tASTNodeProperty prop = lookupName.getPropertyInParent();",
                        "\t\t\tif (prop != ICPPASTTemplateId.TEMPLATE_NAME && !lookupName.isQualified()) {",
                        "\t\t\t\t// You cannot use a class template name outside of the class template scope,",
                        "\t\t\t\t// mark it as a problem.",
                        "\t\t\t\tIBinding user = CPPTemplates.isUsedInClassTemplateScope((ICPPClassTemplate) binding, lookupName);",
                        "\t\t\t\tif (user instanceof ICPPClassTemplate) {",
                        "\t\t\t\t\tbinding = ((ICPPClassTemplate) user).asDeferredInstance();",
                        "\t\t\t\t} else if (user != null) {",
                        "\t\t\t\t\tbinding = user;",
                        "\t\t\t\t} else {",
                        "\t\t\t\t\tboolean ok = false;",
                        "\t\t\t\t\tIASTNode node = lookupName.getParent();",
                        "\t\t\t\t\twhile (node != null && !ok) {",
                        "\t\t\t\t\t\tif (node instanceof ICPPASTTemplateId",
                        "\t\t\t\t\t\t\t\t|| node instanceof ICPPASTTemplatedTypeTemplateParameter) {",
                        "\t\t\t\t\t\t\tok = true; // Can be argument or default-value for template template parameter",
                        "\t\t\t\t\t\t\tbreak;",
                        "\t\t\t\t\t\t} else if (node instanceof IASTElaboratedTypeSpecifier) {",
                        "\t\t\t\t\t\t\tIASTNode parent = node.getParent();",
                        "\t\t\t\t\t\t\tif (parent instanceof IASTSimpleDeclaration) {",
                        "\t\t\t\t\t\t\t\tIASTDeclSpecifier declspec = ((IASTSimpleDeclaration) parent).getDeclSpecifier();",
                        "\t\t\t\t\t\t\t\tif (declspec instanceof ICPPASTDeclSpecifier) {",
                        "\t\t\t\t\t\t\t\t\tif (((ICPPASTDeclSpecifier) declspec).isFriend()) {",
                        "\t\t\t\t\t\t\t\t\t\tok = true; // A friend class template declarations uses resolution.",
                        "\t\t\t\t\t\t\t\t\t\tbreak;",
                        "\t\t\t\t\t\t\t\t\t}",
                        "\t\t\t\t\t\t\t\t}",
                        "\t\t\t\t\t\t\t}",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t\tnode = node.getParent();",
                        "\t\t\t\t\t}",
                        "\t\t\t\t\tif (!ok) {",
                        "\t\t\t\t\t\tbinding = new ProblemBinding(lookupName, lookupPoint, IProblemBinding.SEMANTIC_INVALID_TYPE,",
                        "\t\t\t\t\t\t\t\tdata.getFoundBindings());",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t} else if (binding instanceof ICPPDeferredClassInstance) {",
                        "\t\t\t// Try to replace binding by the one pointing to the enclosing template declaration.",
                        "\t\t\tICPPDeferredClassInstance dcl = (ICPPDeferredClassInstance) binding;",
                        "\t\t\tIBinding usedHere = CPPTemplates.isUsedInClassTemplateScope(dcl.getClassTemplate(), lookupName);",
                        "\t\t\tif (usedHere instanceof ICPPClassTemplatePartialSpecialization) {",
                        "\t\t\t\tif (CPPTemplates.areSameArguments(",
                        "\t\t\t\t\t\t((ICPPClassTemplatePartialSpecialization) usedHere).getTemplateArguments(),",
                        "\t\t\t\t\t\tdcl.getTemplateArguments()))",
                        "\t\t\t\t\tbinding = ((ICPPClassTemplatePartialSpecialization) usedHere).asDeferredInstance();",
                        "\t\t\t} else if (usedHere instanceof ICPPClassTemplate) {",
                        "\t\t\t\tif (CPPTemplates.areSameArguments(",
                        "\t\t\t\t\t\tCPPTemplates.templateParametersAsArguments((ICPPClassTemplate) usedHere),",
                        "\t\t\t\t\t\tdcl.getTemplateArguments())) {",
                        "\t\t\t\t\tbinding = ((ICPPClassTemplate) usedHere).asDeferredInstance();",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\tif (binding instanceof IType) {",
                        "\t\t\tIType t = getNestedType((IType) binding, TDEF);",
                        "\t\t\tif (t instanceof ICPPClassType && convertClassToConstructor(lookupName)) {",
                        "\t\t\t\tICPPClassType cls = (ICPPClassType) t;",
                        "\t\t\t\tif (cls instanceof IIndexBinding) {",
                        "\t\t\t\t\tcls = data.getTranslationUnit().mapToAST(cls);",
                        "\t\t\t\t}",
                        "\t\t\t\ttry {",
                        "\t\t\t\t\tif (lookupName instanceof ICPPASTTemplateId && cls instanceof ICPPClassTemplate) {",
                        "\t\t\t\t\t\tif (data.getTranslationUnit() != null) {",
                        "\t\t\t\t\t\t\tICPPASTTemplateId id = (ICPPASTTemplateId) lookupName;",
                        "\t\t\t\t\t\t\tICPPTemplateArgument[] args = CPPTemplates.createTemplateArgumentArray(id);",
                        "\t\t\t\t\t\t\tIBinding inst = CPPTemplates.instantiate((ICPPClassTemplate) cls, args);",
                        "\t\t\t\t\t\t\tif (inst instanceof ICPPClassType) {",
                        "\t\t\t\t\t\t\t\tcls = (ICPPClassType) inst;",
                        "\t\t\t\t\t\t\t}",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t}",
                        "\t\t\t\t\tif (cls instanceof ICPPUnknownBinding) {",
                        "\t\t\t\t\t\tbinding = new CPPDeferredConstructor(cls);",
                        "\t\t\t\t\t} else {",
                        "\t\t\t\t\t\t// Do not interpret template arguments to a template class as being",
                        "\t\t\t\t\t\t// explicit template arguments to its templated constructor.",
                        "\t\t\t\t\t\tdata.setTemplateArguments(null);",
                        "\t\t\t\t\t\tbinding = resolveFunction(data, cls.getConstructors(), true, false);",
                        "\t\t\t\t\t}",
                        "\t\t\t\t} catch (DOMException e) {",
                        "\t\t\t\t\treturn e.getProblem();",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\tIASTName name = lookupName;",
                        "\t\tIASTNode nameParent = name.getParent();",
                        "\t\tif (nameParent instanceof ICPPASTTemplateId) {",
                        "\t\t\tif (binding instanceof ICPPTemplateInstance) {",
                        "\t\t\t\tfinal ICPPTemplateInstance instance = (ICPPTemplateInstance) binding;",
                        "\t\t\t\tbinding = instance.getSpecializedBinding();",
                        "\t\t\t\tname.setBinding(binding);",
                        "\t\t\t\t((ICPPASTTemplateId) nameParent).setBinding(instance);",
                        "\t\t\t}",
                        "\t\t\tname = (ICPPASTTemplateId) nameParent;",
                        "\t\t\tnameParent = name.getParent();",
                        "\t\t}",
                        "\t\tboolean isNestedNameSpecifier = false;",
                        "\t\tif (nameParent instanceof ICPPASTQualifiedName) {",
                        "\t\t\tif (name == ((ICPPASTQualifiedName) nameParent).getLastName()) {",
                        "\t\t\t\tname = (IASTName) nameParent;",
                        "\t\t\t\tnameParent = name.getParent();",
                        "\t\t\t} else {",
                        "\t\t\t\tisNestedNameSpecifier = true;",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\t// If the lookup in base-classes ran into a deferred instance, use the computed unknown",
                        "\t\t// binding.",
                        "\t\tfinal ASTNodeProperty namePropertyInParent = name.getPropertyInParent();",
                        "\t\tif (binding == null && data.skippedScope != null) {",
                        "\t\t\tif (isNestedNameSpecifier || namePropertyInParent == IASTNamedTypeSpecifier.NAME) {",
                        "\t\t\t\tbinding = new CPPUnknownMemberClass(data.skippedScope, name.getSimpleID());",
                        "\t\t\t} else if (data.isFunctionCall()) {",
                        "\t\t\t\tbinding = new CPPUnknownMethod(data.skippedScope, name.getSimpleID());",
                        "\t\t\t} else {",
                        "\t\t\t\tbinding = new CPPUnknownField(data.skippedScope, name.getSimpleID());",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\tif (binding != null) {",
                        "\t\t\tif (namePropertyInParent == IASTNamedTypeSpecifier.NAME) {",
                        "\t\t\t\tif (!(binding instanceof IType || binding instanceof ICPPConstructor)) {",
                        "\t\t\t\t\tIASTNode parent = name.getParent().getParent();",
                        "\t\t\t\t\tif (parent instanceof IASTTypeId",
                        "\t\t\t\t\t\t\t&& parent.getPropertyInParent() == ICPPASTTemplateId.TEMPLATE_ID_ARGUMENT) {",
                        "\t\t\t\t\t\tif (!(binding instanceof IType)) {",
                        "\t\t\t\t\t\t\t// A type id needs to hold a type.",
                        "\t\t\t\t\t\t\tbinding = new ProblemBinding(lookupName, lookupPoint, IProblemBinding.SEMANTIC_INVALID_TYPE,",
                        "\t\t\t\t\t\t\t\t\tdata.getFoundBindings());",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t\t// Don't create a problem here.",
                        "\t\t\t\t\t} else {",
                        "\t\t\t\t\t\tbinding = new ProblemBinding(lookupName, lookupPoint, IProblemBinding.SEMANTIC_INVALID_TYPE,",
                        "\t\t\t\t\t\t\t\tdata.getFoundBindings());",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t} else if (namePropertyInParent == IASTIdExpression.ID_NAME) {",
                        "\t\t\t\tif (binding instanceof IType) {",
                        "\t\t\t\t\tfinal IASTNode idExpr = name.getParent();",
                        "\t\t\t\t\tASTNodeProperty pip = idExpr.getPropertyInParent();",
                        "\t\t\t\t\tif (pip == ICPPASTTemplatedTypeTemplateParameter.DEFAULT_VALUE) {",
                        "\t\t\t\t\t\t// Default for template template parameter is a type.",
                        "\t\t\t\t\t} else if (pip == IASTFunctionCallExpression.FUNCTION_NAME) {",
                        "\t\t\t\t\t\t// Explicit type conversion in functional notation.",
                        "\t\t\t\t\t} else if (pip == IASTUnaryExpression.OPERAND && ((ICPPASTUnaryExpression) idExpr.getParent())",
                        "\t\t\t\t\t\t\t.getOperator() == IASTUnaryExpression.op_sizeofParameterPack) {",
                        "\t\t\t\t\t\t// Argument of sizeof... can be a type",
                        "\t\t\t\t\t} else {",
                        "\t\t\t\t\t\tbinding = new ProblemBinding(lookupName, lookupPoint, IProblemBinding.SEMANTIC_INVALID_TYPE,",
                        "\t\t\t\t\t\t\t\tdata.getFoundBindings());",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\t// Some declarations are found via name resolution (e.g. when using a qualified name),",
                        "\t\t// add name as definition and check the declaration specifier.",
                        "\t\tfinal IASTDeclaration declaration = data.forDeclaration();",
                        "\t\tif (declaration != null) {",
                        "\t\t\t// Functions",
                        "\t\t\tif (binding instanceof IFunction) {",
                        "\t\t\t\tbinding = checkDeclSpecifier(binding, lookupName, declaration);",
                        "\t\t\t\tif (!(binding instanceof IProblemBinding)) {",
                        "\t\t\t\t\tif (declaration instanceof ICPPASTFunctionDefinition) {",
                        "\t\t\t\t\t\tASTInternal.addDefinition(binding, lookupName);",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t\t// Definitions of static fields.",
                        "\t\t\tif (binding instanceof ICPPField && lookupName.isDefinition()) {",
                        "\t\t\t\tif (declaration.getPropertyInParent() != IASTCompositeTypeSpecifier.MEMBER_DECLARATION) {",
                        "\t\t\t\t\tASTInternal.addDefinition(binding, lookupName);",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\t// If the result is a virtual method called without explicit qualification, and we can determine a",
                        "\t\t// unique final overrider for it in the hierarchy of the method call's implied object type, replace",
                        "\t\t// the method with its final overrider.",
                        "\t\tif (!(lookupName.getParent() instanceof ICPPASTQualifiedName) && binding instanceof ICPPMethod",
                        "\t\t\t\t&& ((ICPPMethod) binding).isVirtual()) {",
                        "\t\t\tIType impliedObjectType = data.getImpliedObjectType();",
                        "\t\t\tif (impliedObjectType instanceof ICPPClassType) {",
                        "\t\t\t\tICPPMethod finalOverrider = CPPInheritance.getFinalOverrider((ICPPMethod) binding,",
                        "\t\t\t\t\t\t(ICPPClassType) impliedObjectType);",
                        "\t\t\t\tif (finalOverrider != null) {",
                        "\t\t\t\t\tbinding = finalOverrider;",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\t// If we're still null...",
                        "\t\tif (binding == null) {",
                        "\t\t\tif (name instanceof ICPPASTQualifiedName && declaration != null) {",
                        "\t\t\t\tbinding = new ProblemBinding(lookupName, lookupPoint,",
                        "\t\t\t\t\t\tIProblemBinding.SEMANTIC_MEMBER_DECLARATION_NOT_FOUND, data.getFoundBindings());",
                        "\t\t\t} else {",
                        "\t\t\t\tbinding = new ProblemBinding(lookupName, lookupPoint, IProblemBinding.SEMANTIC_NAME_NOT_FOUND,",
                        "\t\t\t\t\t\tdata.getFoundBindings());",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\treturn binding;",
                        "\t}",
                        "",
                        "\tprivate static boolean convertClassToConstructor(IASTName name) {",
                        "\t\tif (name == null)",
                        "\t\t\treturn false;",
                        "\t\tfinal ASTNodeProperty propertyInParent = name.getPropertyInParent();",
                        "\t\tif (propertyInParent == null)",
                        "\t\t\treturn false;",
                        "",
                        "\t\tif (propertyInParent == ICPPASTTemplateId.TEMPLATE_NAME)",
                        "\t\t\treturn false;",
                        "",
                        "\t\tIASTNode parent = name.getParent();",
                        "\t\tif (parent instanceof ICPPASTQualifiedName) {",
                        "\t\t\tif (((ICPPASTQualifiedName) parent).getLastName() != name)",
                        "\t\t\t\treturn false;",
                        "\t\t\tparent = parent.getParent();",
                        "\t\t}",
                        "\t\tif (parent instanceof ICPPASTConstructorChainInitializer) {",
                        "\t\t\treturn true;",
                        "\t\t}",
                        "\t\treturn false;",
                        "\t}",
                        "",
                        "\tpublic static void doArgumentDependentLookup(LookupData data) throws DOMException {",
                        "\t\tdata.ignoreUsingDirectives = true;",
                        "\t\t// Set 'qualified' to true for the duration of this function call so the calls to lookup()",
                        "\t\t// don't ascend into enclosing scopes.",
                        "\t\tboolean originalQualified = data.qualified;",
                        "\t\tdata.qualified = true;",
                        "\t\tdata.setArgumentDependent(true);",
                        "\t\tSet<ICPPFunction> friendFns = new HashSet<>(2);",
                        "\t\tSet<ICPPNamespaceScope> associated = getAssociatedScopes(data, friendFns);",
                        "\t\tfor (ICPPNamespaceScope scope : associated) {",
                        "\t\t\tif (!data.visited.containsKey(scope)) {",
                        "\t\t\t\tlookup(data, scope);",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\tObject[] matchingFriendFns = CollectionUtils.filter(friendFns, new NameMatcherPredicate(data.getLookupKey()))",
                        "\t\t\t\t.toArray();",
                        "\t\tmergeResults(data, matchingFriendFns, false);",
                        "\t\tdata.qualified = originalQualified;",
                        "\t\tdata.setArgumentDependent(false);",
                        "\t}",
                        "",
                        "\tprivate static class NameMatcherPredicate implements IUnaryPredicate<ICPPFunction> {",
                        "\t\tprivate char[] fKey;",
                        "",
                        "\t\tpublic NameMatcherPredicate(char[] key) {",
                        "\t\t\tfKey = key;",
                        "\t\t}",
                        "",
                        "\t\t@Override",
                        "\t\tpublic boolean apply(ICPPFunction argument) {",
                        "\t\t\treturn Arrays.equals(argument.getNameCharArray(), fKey);",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tstatic IBinding checkDeclSpecifier(IBinding binding, IASTName name, IASTNode decl) {",
                        "\t\t// Check for empty declaration specifiers.",
                        "\t\tif (!isCtorOrConversionOperator(binding)) {",
                        "\t\t\tIASTDeclSpecifier declspec = null;",
                        "\t\t\tif (decl instanceof IASTSimpleDeclaration) {",
                        "\t\t\t\tdeclspec = ((IASTSimpleDeclaration) decl).getDeclSpecifier();",
                        "\t\t\t} else if (decl instanceof IASTFunctionDefinition) {",
                        "\t\t\t\tdeclspec = ((IASTFunctionDefinition) decl).getDeclSpecifier();",
                        "\t\t\t}",
                        "\t\t\tif (declspec != null && CPPVisitor.doesNotSpecifyType(declspec)) {",
                        "\t\t\t\tbinding = new ProblemBinding(name, IProblemBinding.SEMANTIC_INVALID_TYPE);",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\treturn binding;",
                        "\t}",
                        "",
                        "\tprivate static boolean isCtorOrConversionOperator(IBinding binding) {",
                        "\t\tif (binding instanceof ICPPConstructor)",
                        "\t\t\treturn true;",
                        "",
                        "\t\tif (binding instanceof ICPPMethod) {",
                        "\t\t\tICPPMethod m = (ICPPMethod) binding;",
                        "\t\t\tif (m.isDestructor())",
                        "\t\t\t\treturn true;",
                        "\t\t\treturn isConversionOperator(m);",
                        "\t\t}",
                        "\t\treturn false;",
                        "\t}",
                        "",
                        "\tpublic static LookupData createLookupData(IASTName name) {",
                        "\t\tLookupData data = new LookupData(name);",
                        "\t\tIASTNode parent = name.getParent();",
                        "",
                        "\t\tif (parent instanceof ICPPASTTemplateId)",
                        "\t\t\tparent = parent.getParent();",
                        "\t\tif (parent instanceof ICPPASTQualifiedName)",
                        "\t\t\tparent = parent.getParent();",
                        "",
                        "\t\tif (parent instanceof IASTDeclarator && parent.getPropertyInParent() == IASTSimpleDeclaration.DECLARATOR) {",
                        "\t\t\tIASTSimpleDeclaration simple = (IASTSimpleDeclaration) parent.getParent();",
                        "\t\t\tif (simple.getDeclSpecifier().getStorageClass() == IASTDeclSpecifier.sc_typedef)",
                        "\t\t\t\tdata.qualified = true;",
                        "\t\t}",
                        "",
                        "\t\tif (parent instanceof IASTIdExpression) {",
                        "\t\t\tIASTNode grand = parent.getParent();",
                        "\t\t\twhile (grand instanceof IASTUnaryExpression",
                        "\t\t\t\t\t&& ((IASTUnaryExpression) grand).getOperator() == IASTUnaryExpression.op_bracketedPrimary) {",
                        "\t\t\t\tparent = grand;",
                        "\t\t\t\tgrand = grand.getParent();",
                        "\t\t\t}",
                        "\t\t\tif (parent.getPropertyInParent() == IASTFunctionCallExpression.FUNCTION_NAME) {",
                        "\t\t\t\tparent = parent.getParent();",
                        "\t\t\t\tIASTInitializerClause[] args = ((IASTFunctionCallExpression) parent).getArguments();",
                        "\t\t\t\tdata.setFunctionArguments(false, args);",
                        "\t\t\t}",
                        "\t\t} else if (parent instanceof ICPPASTFieldReference) {",
                        "\t\t\tIASTNode grand = parent.getParent();",
                        "\t\t\twhile (grand instanceof IASTUnaryExpression",
                        "\t\t\t\t\t&& ((IASTUnaryExpression) grand).getOperator() == IASTUnaryExpression.op_bracketedPrimary) {",
                        "\t\t\t\tparent = grand;",
                        "\t\t\t\tgrand = grand.getParent();",
                        "\t\t\t}",
                        "\t\t\tif (parent.getPropertyInParent() == IASTFunctionCallExpression.FUNCTION_NAME) {",
                        "\t\t\t\tIASTInitializerClause[] exp = ((IASTFunctionCallExpression) parent.getParent()).getArguments();",
                        "\t\t\t\tdata.setFunctionArguments(false, exp);",
                        "\t\t\t}",
                        "\t\t} else if (parent instanceof ICPPASTNamedTypeSpecifier && parent.getParent() instanceof IASTTypeId) {",
                        "\t\t\tIASTTypeId typeId = (IASTTypeId) parent.getParent();",
                        "\t\t\tif (typeId.getParent() instanceof ICPPASTNewExpression) {",
                        "\t\t\t\tICPPASTNewExpression newExp = (ICPPASTNewExpression) typeId.getParent();",
                        "\t\t\t\tIASTInitializer init = newExp.getInitializer();",
                        "\t\t\t\tif (init == null) {",
                        "\t\t\t\t\tdata.setFunctionArguments(false, NO_INITCLAUSE_EVALUATION);",
                        "\t\t\t\t} else if (init instanceof ICPPASTConstructorInitializer) {",
                        "\t\t\t\t\tdata.setFunctionArguments(false, ((ICPPASTConstructorInitializer) init).getArguments());",
                        "\t\t\t\t} else if (init instanceof ICPPASTInitializerList) {",
                        "\t\t\t\t\tdata.setFunctionArguments(false, (ICPPASTInitializerList) init);",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t} else if (parent instanceof ICPPASTConstructorChainInitializer) {",
                        "\t\t\tICPPASTConstructorChainInitializer ctorinit = (ICPPASTConstructorChainInitializer) parent;",
                        "\t\t\tIASTInitializer init = ctorinit.getInitializer();",
                        "\t\t\tif (init instanceof ICPPASTConstructorInitializer) {",
                        "\t\t\t\tdata.setFunctionArguments(false, ((ICPPASTConstructorInitializer) init).getArguments());",
                        "\t\t\t} else if (init instanceof ICPPASTInitializerList) {",
                        "\t\t\t\tdata.setFunctionArguments(false, (ICPPASTInitializerList) init);",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\treturn data;",
                        "\t}",
                        "",
                        "\tprivate static Set<ICPPNamespaceScope> getAssociatedScopes(LookupData data, Set<ICPPFunction> friendFns) {",
                        "\t\tif (!data.hasFunctionArguments())",
                        "\t\t\treturn Collections.emptySet();",
                        "",
                        "\t\tIType[] ps = data.getFunctionArgumentTypes();",
                        "\t\tSet<ICPPNamespaceScope> namespaces = new HashSet<>(2);",
                        "\t\tObjectSet<IType> handled = new ObjectSet<>(2);",
                        "\t\tfor (IType p : ps) {",
                        "\t\t\ttry {",
                        "\t\t\t\tgetAssociatedScopes(p, namespaces, friendFns, handled, data.getTranslationUnit(), true);",
                        "\t\t\t} catch (DOMException e) {",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\tIASTName lookupName = data.getLookupName();",
                        "\t\tif (lookupName != null) {",
                        "\t\t\tfinal char[] simpleID = lookupName.getSimpleID();",
                        "\t\t\tif (CharArrayUtils.equals(CPPVisitor.BEGIN, simpleID) || CharArrayUtils.equals(CPPVisitor.END, simpleID)) {",
                        "\t\t\t\tIASTNode parent = lookupName.getParent(); // id-expression",
                        "\t\t\t\tif (parent != null)",
                        "\t\t\t\t\tparent = parent.getParent(); // function call",
                        "\t\t\t\tif (parent != null)",
                        "\t\t\t\t\tparent = parent.getParent(); // the loop",
                        "\t\t\t\tif (parent instanceof ICPPASTRangeBasedForStatement) {",
                        "\t\t\t\t\tIASTTranslationUnit tu = parent.getTranslationUnit();",
                        "\t\t\t\t\tIBinding[] std = tu.getScope().find(CPPVisitor.STD, tu);",
                        "\t\t\t\t\tfor (IBinding binding : std) {",
                        "\t\t\t\t\t\tif (binding instanceof ICPPNamespace) {",
                        "\t\t\t\t\t\t\tnamespaces.add(((ICPPNamespace) binding).getNamespaceScope());",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\treturn namespaces;",
                        "\t}",
                        "",
                        "\t// 3.4.2-2",
                        "\tprivate static void getAssociatedScopes(IType t, Set<ICPPNamespaceScope> namespaces, Set<ICPPFunction> friendFns,",
                        "\t\t\tObjectSet<IType> handled, CPPASTTranslationUnit tu, boolean lookInBaseClasses) throws DOMException {",
                        "\t\tt = getNestedType(t, TDEF | CVTYPE | PTR | ARRAY | REF);",
                        "\t\t// No point getting namespaces associated with a dependent type - we don't know what they",
                        "\t\t// are yet.",
                        "\t\tif (CPPTemplates.isDependentType(t))",
                        "\t\t\treturn;",
                        "\t\tif (t instanceof IBinding) {",
                        "\t\t\tif (handled.containsKey(t))",
                        "\t\t\t\treturn;",
                        "\t\t\thandled.put(t);",
                        "",
                        "\t\t\tif (t instanceof IEnumeration) {",
                        "\t\t\t\t// [basic.lookup.argdep] p2.3: an enumeration's only associated namespace",
                        "\t\t\t\t// is the innermost enclosing namespace of its declaration.",
                        "\t\t\t\tgetAssociatedNamespaceScopes(getContainingNamespaceScope((IBinding) t, tu), namespaces);",
                        "\t\t\t} else {",
                        "\t\t\t\tIBinding owner = ((IBinding) t).getOwner();",
                        "\t\t\t\tif (owner instanceof ICPPClassType) {",
                        "\t\t\t\t\tgetAssociatedScopes((IType) owner, namespaces, friendFns, handled, tu,",
                        "\t\t\t\t\t\t\tfalse /* do not look at base classes of the enclosing class */);",
                        "\t\t\t\t} else {",
                        "\t\t\t\t\tgetAssociatedNamespaceScopes(getContainingNamespaceScope((IBinding) t, tu), namespaces);",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\tif (t instanceof ICPPClassType && !(t instanceof ICPPClassTemplate)) {",
                        "\t\t\tICPPClassType ct = (ICPPClassType) t;",
                        "\t\t\tif (lookInBaseClasses) {",
                        "\t\t\t\tICPPBase[] bases = ct.getBases();",
                        "\t\t\t\tfor (ICPPBase base : bases) {",
                        "\t\t\t\t\tIBinding b = base.getBaseClass();",
                        "\t\t\t\t\tif (b instanceof IType)",
                        "\t\t\t\t\t\tgetAssociatedScopes((IType) b, namespaces, friendFns, handled, tu, true);",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t\t// Furthermore, if T is a class template ...",
                        "\t\t\t// * ... types of the template arguments for template type parameters",
                        "\t\t\t//\t   (excluding template template parameters);",
                        "\t\t\t// * ... owners of which any template template arguments are members;",
                        "\t\t\tif (ct instanceof ICPPSpecialization) {",
                        "\t\t\t\tfor (IBinding friend : ct.getFriends()) {",
                        "\t\t\t\t\tif (friend instanceof ICPPFunction) {",
                        "\t\t\t\t\t\tfriendFns.add((ICPPFunction) friend);",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t\tif (ct instanceof ICPPTemplateInstance) {",
                        "\t\t\t\t\tICPPTemplateArgument[] args = ((ICPPTemplateInstance) ct).getTemplateArguments();",
                        "\t\t\t\t\tfor (ICPPTemplateArgument arg : args) {",
                        "\t\t\t\t\t\tif (arg.isTypeValue()) {",
                        "\t\t\t\t\t\t\tgetAssociatedScopes(arg.getTypeValue(), namespaces, friendFns, handled, tu, true);",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t} else if (t instanceof IFunctionType) {",
                        "\t\t\tIFunctionType ft = (IFunctionType) t;",
                        "\t\t\tgetAssociatedScopes(ft.getReturnType(), namespaces, friendFns, handled, tu, true);",
                        "\t\t\tIType[] ps = ft.getParameterTypes();",
                        "\t\t\tfor (IType pt : ps) {",
                        "\t\t\t\tgetAssociatedScopes(pt, namespaces, friendFns, handled, tu, true);",
                        "\t\t\t}",
                        "\t\t} else if (t instanceof ICPPPointerToMemberType) {",
                        "\t\t\tfinal ICPPPointerToMemberType pmt = (ICPPPointerToMemberType) t;",
                        "\t\t\tgetAssociatedScopes(pmt.getMemberOfClass(), namespaces, friendFns, handled, tu, true);",
                        "\t\t\tgetAssociatedScopes(pmt.getType(), namespaces, friendFns, handled, tu, true);",
                        "\t\t} else if (t instanceof FunctionSetType) {",
                        "\t\t\tFunctionSetType fst = (FunctionSetType) t;",
                        "\t\t\tfor (ICPPFunction fn : fst.getFunctionSet().getBindings()) {",
                        "\t\t\t\tgetAssociatedScopes(fn.getType(), namespaces, friendFns, handled, tu, true);",
                        "\t\t\t}",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tprivate static ICPPNamespaceScope getContainingNamespaceScope(IBinding binding, CPPASTTranslationUnit tu)",
                        "\t\t\tthrows DOMException {",
                        "\t\tif (binding == null)",
                        "\t\t\treturn null;",
                        "\t\tIScope scope = binding.getScope();",
                        "\t\tscope = SemanticUtil.mapToAST(scope, tu);",
                        "\t\twhile (scope != null && !(scope instanceof ICPPNamespaceScope)) {",
                        "\t\t\tscope = getParentScope(scope, tu);",
                        "\t\t}",
                        "\t\treturn (ICPPNamespaceScope) scope;",
                        "\t}",
                        "",
                        "\tpublic static void getAssociatedNamespaceScopes(ICPPNamespaceScope scope, Set<ICPPNamespaceScope> namespaces) {",
                        "\t\tif (scope == null || !namespaces.add(scope))",
                        "\t\t\treturn;",
                        "",
                        "\t\tif (scope instanceof ICPPInternalNamespaceScope) {",
                        "\t\t\tfinal ICPPInternalNamespaceScope internalScope = (ICPPInternalNamespaceScope) scope;",
                        "\t\t\tfor (ICPPNamespaceScope mem : internalScope.getEnclosingNamespaceSet()) {",
                        "\t\t\t\tnamespaces.add(mem);",
                        "\t\t\t}",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tstatic ICPPScope getLookupScope(IASTName name) throws DOMException {",
                        "\t\tIASTNode parent = name.getParent();",
                        "\t\tIScope scope = null;",
                        "\t\tif (parent instanceof ICPPASTBaseSpecifier) {",
                        "\t\t\tICPPASTCompositeTypeSpecifier compSpec = (ICPPASTCompositeTypeSpecifier) parent.getParent();",
                        "\t\t\tIASTName n = compSpec.getName();",
                        "\t\t\tif (n instanceof ICPPASTQualifiedName) {",
                        "\t\t\t\tn = n.getLastName();",
                        "\t\t\t}",
                        "\t\t\tscope = CPPVisitor.getContainingScope(n);",
                        "\t\t} else {",
                        "\t\t\tscope = CPPVisitor.getContainingScope(name);",
                        "\t\t}",
                        "\t\tif (scope instanceof ICPPScope) {",
                        "\t\t\treturn (ICPPScope) scope;",
                        "\t\t} else if (scope instanceof IProblemBinding) {",
                        "\t\t\treturn new CPPScope.CPPScopeProblem(((IProblemBinding) scope).getASTNode(),",
                        "\t\t\t\t\tIProblemBinding.SEMANTIC_BAD_SCOPE, ((IProblemBinding) scope).getNameCharArray());",
                        "\t\t}",
                        "\t\treturn new CPPScope.CPPScopeProblem(name, IProblemBinding.SEMANTIC_BAD_SCOPE);",
                        "\t}",
                        "",
                        "\tprivate static void mergeResults(LookupData data, Object results, boolean scoped) {",
                        "\t\tif (!data.contentAssist) {",
                        "\t\t\tif (results instanceof IBinding) {",
                        "\t\t\t\tdata.foundItems = ArrayUtil.append(Object.class, (Object[]) data.foundItems, results);",
                        "\t\t\t} else if (results instanceof Object[]) {",
                        "\t\t\t\tdata.foundItems = ArrayUtil.addAll(Object.class, (Object[]) data.foundItems, (Object[]) results);",
                        "\t\t\t}",
                        "\t\t} else {",
                        "\t\t\t@SuppressWarnings(\"unchecked\")",
                        "\t\t\tfinal CharArrayObjectMap<Object> oldItems = (CharArrayObjectMap<Object>) data.foundItems;",
                        "\t\t\tdata.foundItems = mergePrefixResults(oldItems, results, scoped);",
                        "\t\t}",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * @param dest",
                        "\t * @param source : either Object[] or CharArrayObjectMap",
                        "\t * @param scoped",
                        "\t * @return",
                        "\t */",
                        "\tstatic CharArrayObjectMap<Object> mergePrefixResults(CharArrayObjectMap<Object> dest, Object source,",
                        "\t\t\tboolean scoped) {",
                        "\t\tif (source == null)",
                        "\t\t\treturn dest;",
                        "\t\tCharArrayObjectMap<Object> resultMap = (dest != null) ? dest : new CharArrayObjectMap<>(2);",
                        "",
                        "\t\tCharArrayObjectMap<Object> map = null;",
                        "\t\tObject[] objs = null;",
                        "\t\tint size;",
                        "\t\tif (source instanceof CharArrayObjectMap) {",
                        "\t\t\t@SuppressWarnings(\"unchecked\")",
                        "\t\t\tfinal CharArrayObjectMap<Object> sourceMap = (CharArrayObjectMap<Object>) source;",
                        "\t\t\tmap = sourceMap;",
                        "\t\t\tsize = map.size();",
                        "\t\t} else {",
                        "\t\t\tif (source instanceof Object[])",
                        "\t\t\t\tobjs = ArrayUtil.trim(Object.class, (Object[]) source);",
                        "\t\t\telse",
                        "\t\t\t\tobjs = new Object[] { source };",
                        "\t\t\tsize = objs.length;",
                        "\t\t}",
                        "",
                        "\t\tint resultInitialSize = resultMap.size();",
                        "\t\tfor (int i = 0; i < size; i++) {",
                        "\t\t\tchar[] key;",
                        "\t\t\tObject so;",
                        "\t\t\tif (map != null) {",
                        "\t\t\t\tkey = map.keyAt(i);",
                        "\t\t\t\tso = map.get(key);",
                        "\t\t\t} else if (objs != null) {",
                        "\t\t\t\tso = objs[i];",
                        "\t\t\t\tkey = (so instanceof IBinding) ? ((IBinding) so).getNameCharArray() : ((IASTName) so).getSimpleID();",
                        "\t\t\t} else {",
                        "\t\t\t\treturn resultMap;",
                        "\t\t\t}",
                        "\t\t\tint idx = resultMap.lookup(key);",
                        "\t\t\tif (idx == -1) {",
                        "\t\t\t\tresultMap.put(key, so);",
                        "\t\t\t} else if (!scoped || idx >= resultInitialSize) {",
                        "\t\t\t\tObject obj = resultMap.get(key);",
                        "\t\t\t\tif (obj instanceof Object[]) {",
                        "\t\t\t\t\tif (so instanceof IBinding || so instanceof IASTName) {",
                        "\t\t\t\t\t\tobj = ArrayUtil.append(Object.class, (Object[]) obj, so);",
                        "\t\t\t\t\t} else {",
                        "\t\t\t\t\t\tobj = ArrayUtil.addAll(Object.class, (Object[]) obj, (Object[]) so);",
                        "\t\t\t\t\t}",
                        "\t\t\t\t} else {",
                        "\t\t\t\t\tif (so instanceof IBinding || so instanceof IASTName) {",
                        "\t\t\t\t\t\tobj = new Object[] { obj, so };",
                        "\t\t\t\t\t} else {",
                        "\t\t\t\t\t\tObject[] temp = new Object[((Object[]) so).length + 1];",
                        "\t\t\t\t\t\ttemp[0] = obj;",
                        "\t\t\t\t\t\tobj = ArrayUtil.addAll(Object.class, temp, (Object[]) so);",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t\tresultMap.put(key, obj);",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\treturn resultMap;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Perform a lookup with the given data starting in the given scope, considering bases and parent scopes.",
                        "\t * @param data the lookup data created off a name",
                        "\t * @param start either a scope or a name.",
                        "\t */",
                        "\tstatic protected void lookup(LookupData data, IScope start) throws DOMException {",
                        "\t\tif (start == null && lookupDestructor(data)) {",
                        "\t\t\treturn;",
                        "\t\t}",
                        "",
                        "\t\tICPPScope nextScope = null;",
                        "\t\tICPPTemplateScope nextTmplScope = null;",
                        "\t\tif (start instanceof ICPPScope) {",
                        "\t\t\tnextScope = (ICPPScope) start;",
                        "\t\t} else {",
                        "\t\t\tIASTName lookupName = data.getLookupName();",
                        "\t\t\tif (lookupName == null)",
                        "\t\t\t\treturn;",
                        "",
                        "\t\t\tnextScope = getLookupScope(lookupName);",
                        "",
                        "\t\t\tif (nextScope instanceof ICPPTemplateScope) {",
                        "\t\t\t\tnextTmplScope = (ICPPTemplateScope) nextScope;",
                        "\t\t\t\tnextScope = getParentScope(nextScope, data.getTranslationUnit());",
                        "\t\t\t} else {",
                        "\t\t\t\tnextTmplScope = enclosingTemplateScope(lookupName);",
                        "\t\t\t}",
                        "\t\t\tif (data.qualified && nextTmplScope != null) {",
                        "\t\t\t\tnextTmplScope = null;",
                        "\t\t\t\tif (dependsOnTemplateFieldReference(lookupName)) {",
                        "\t\t\t\t\tdata.setIgnorePointOfDeclaration(true);",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\tif (nextScope == null)",
                        "\t\t\treturn;",
                        "",
                        "\t\tboolean friendInLocalClass = false;",
                        "\t\tif (nextScope instanceof ICPPClassScope && data.forFriendship()) {",
                        "\t\t\ttry {",
                        "\t\t\t\tICPPClassType cls = ((ICPPClassScope) nextScope).getClassType();",
                        "\t\t\t\tfriendInLocalClass = !cls.isGloballyQualified();",
                        "\t\t\t} catch (DOMException e) {",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\twhile (nextScope != null || nextTmplScope != null) {",
                        "\t\t\t// When the non-template scope is no longer contained within the first template scope,",
                        "\t\t\t// we use the template scope for the next iteration.",
                        "\t\t\tboolean useTemplScope = false;",
                        "\t\t\tif (nextTmplScope != null) {",
                        "\t\t\t\tuseTemplScope = true;",
                        "\t\t\t\tif (nextScope instanceof IASTInternalScope) {",
                        "\t\t\t\t\tfinal IASTNode node = ((IASTInternalScope) nextScope).getPhysicalNode();",
                        "\t\t\t\t\tif (node != null && nextTmplScope.getTemplateDeclaration().contains(node)) {",
                        "\t\t\t\t\t\tuseTemplScope = false;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t\tICPPScope scope = useTemplScope ? nextTmplScope : nextScope;",
                        "\t\t\tscope = (ICPPScope) SemanticUtil.mapToAST(scope, data.getTranslationUnit());",
                        "",
                        "\t\t\tif (!data.usingDirectivesOnly && !(data.ignoreMembers && scope instanceof ICPPClassScope)) {",
                        "\t\t\t\tmergeResults(data, getBindingsFromScope(scope, data), true);",
                        "",
                        "\t\t\t\t// Nominate using-directives found in this block or namespace.",
                        "\t\t\t\tif (scope instanceof ICPPNamespaceScope) {",
                        "\t\t\t\t\tfinal ICPPNamespaceScope namespaceScope = (ICPPNamespaceScope) scope;",
                        "",
                        "\t\t\t\t\tif (data.qualified && namespaceScope.getKind() != EScopeKind.eLocal) {",
                        "\t\t\t\t\t\tlookupInlineNamespaces(data, namespaceScope);",
                        "\t\t\t\t\t}",
                        "\t\t\t\t\tif (data.contentAssist || !data.hasResults() || !data.qualified) {",
                        "\t\t\t\t\t\t// Nominate namespaces",
                        "\t\t\t\t\t\tnominateNamespaces(data, namespaceScope);",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "",
                        "\t\t\t// Lookup in nominated namespaces",
                        "\t\t\tif (!data.ignoreUsingDirectives && scope instanceof ICPPNamespaceScope",
                        "\t\t\t\t\t&& !(scope instanceof ICPPBlockScope)) {",
                        "\t\t\t\tif (!data.hasResults() || !data.qualified || data.contentAssist) {",
                        "\t\t\t\t\tlookupInNominated(data, (ICPPNamespaceScope) scope);",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (friendInLocalClass && !(scope instanceof ICPPClassScope))",
                        "\t\t\t\treturn;",
                        "\t\t\tif (!data.contentAssist && hasReachableResult(data))",
                        "\t\t\t\treturn;",
                        "",
                        "\t\t\t// Lookup in base classes",
                        "\t\t\tif (!data.usingDirectivesOnly && scope instanceof ICPPClassScope && !data.ignoreMembers) {",
                        "\t\t\t\tBaseClassLookup.lookupInBaseClasses(data, (ICPPClassScope) scope);",
                        "\t\t\t\tif (!data.contentAssist && data.hasResultOrProblem())",
                        "\t\t\t\t\treturn;",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (data.qualified && !(scope instanceof ICPPTemplateScope)) {",
                        "\t\t\t\tif (data.ignoreUsingDirectives || data.usingDirectives.isEmpty())",
                        "\t\t\t\t\treturn;",
                        "\t\t\t\tdata.usingDirectivesOnly = true;",
                        "\t\t\t}",
                        "",
                        "\t\t\t// Compute next scopes",
                        "\t\t\tif (useTemplScope && nextTmplScope != null) {",
                        "\t\t\t\tnextTmplScope = enclosingTemplateScope(nextTmplScope.getTemplateDeclaration());",
                        "\t\t\t} else {",
                        "\t\t\t\tnextScope = getParentScope(scope, data.getTranslationUnit());",
                        "\t\t\t}",
                        "\t\t}",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Checks if lookup data contains result bindings reachable through includes",
                        "\t * from the translation unit where lookup started. Any binding is considered reachable",
                        "\t * if the lookup is not done in a context of a translation unit.",
                        "\t *",
                        "\t * @param data the LookupData object.",
                        "\t * @return {@code true} if the lookup data contains at least one reachable binding.",
                        "\t */",
                        "\tprivate static boolean hasReachableResult(LookupData data) {",
                        "\t\tif (data.foundItems instanceof Object[]) {",
                        "\t\t\tfor (Object item : (Object[]) data.foundItems) {",
                        "\t\t\t\tif (item instanceof IBinding) {",
                        "\t\t\t\t\tIBinding binding = (IBinding) item;",
                        "\t\t\t\t\tCPPASTTranslationUnit tu = data.getTranslationUnit();",
                        "\t\t\t\t\tif (!isFromIndex(binding) || tu == null || isReachableFromAst(tu, binding)) {",
                        "\t\t\t\t\t\treturn true;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\treturn false;",
                        "\t}",
                        "",
                        "\tprivate static void lookupInlineNamespaces(LookupData data, ICPPNamespaceScope namespace) throws DOMException {",
                        "\t\tlookupInlineNamespaces(data, namespace, new HashSet<ICPPInternalNamespaceScope>());",
                        "\t}",
                        "",
                        "\tprivate static void lookupInlineNamespaces(LookupData data, ICPPNamespaceScope namespace,",
                        "\t\t\tSet<ICPPInternalNamespaceScope> visited) throws DOMException {",
                        "\t\tif (namespace instanceof ICPPInternalNamespaceScope) {",
                        "\t\t\tICPPInternalNamespaceScope ns = (ICPPInternalNamespaceScope) namespace;",
                        "\t\t\tvisited.add(ns);",
                        "\t\t\tfor (ICPPInternalNamespaceScope inline : ns.getInlineNamespaces()) {",
                        "\t\t\t\tif (visited.contains(inline)) {",
                        "\t\t\t\t\tCCorePlugin.log(IStatus.WARNING, \"Detected circular reference between inline namespaces\"); //$NON-NLS-1$",
                        "\t\t\t\t\tcontinue;",
                        "\t\t\t\t}",
                        "\t\t\t\tmergeResults(data, getBindingsFromScope(inline, data), true);",
                        "\t\t\t\tlookupInlineNamespaces(data, inline, visited);",
                        "\t\t\t\tnominateNamespaces(data, inline);",
                        "\t\t\t}",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tprivate static void nominateNamespaces(LookupData data, final ICPPNamespaceScope blockScope) throws DOMException {",
                        "\t\tfinal boolean isBlockScope = blockScope.getKind() == EScopeKind.eLocal;",
                        "\t\tif (!isBlockScope) {",
                        "\t\t\tdata.visited.put(blockScope); // Mark as searched.",
                        "\t\t\tCPPASTTranslationUnit tu = data.getTranslationUnit();",
                        "\t\t\tif (tu != null) {",
                        "\t\t\t\ttu.handleAdditionalDirectives(blockScope);",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\tICPPUsingDirective[] uds = blockScope.getUsingDirectives();",
                        "\t\tif (uds != null && uds.length > 0) {",
                        "\t\t\tHashSet<ICPPNamespaceScope> handled = new HashSet<>();",
                        "\t\t\tfor (final ICPPUsingDirective ud : uds) {",
                        "\t\t\t\tif (data.isIgnorePointOfDeclaration() || declaredBefore(ud, data.getLookupPoint(), false)) {",
                        "\t\t\t\t\tstoreUsingDirective(data, blockScope, ud, handled);",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tprivate static boolean lookupDestructor(LookupData data) throws DOMException {",
                        "\t\tIASTName typeDtorName = data.getLookupName();",
                        "\t\tif (typeDtorName == null)",
                        "\t\t\treturn false;",
                        "\t\tfinal char[] typeDtorChars = typeDtorName.getSimpleID();",
                        "\t\tif (typeDtorChars.length == 0 || typeDtorChars[0] != '~')",
                        "\t\t\treturn false;",
                        "",
                        "\t\t// Assume class C; typedef C T;",
                        "\t\t// When looking up ~T the strategy is to lookup T::~C in two steps:",
                        "\t\t// * First resolve 'T', then compute '~C' and resolve it.",
                        "\t\tIASTNode parent = typeDtorName.getParent();",
                        "\t\tif (parent instanceof ICPPASTQualifiedName) {",
                        "\t\t\tICPPASTQualifiedName dqname = (ICPPASTQualifiedName) parent;",
                        "\t\t\tif (dqname.getLastName() != typeDtorName)",
                        "\t\t\t\treturn false;",
                        "\t\t}",
                        "\t\tchar[] tchars = new char[typeDtorChars.length - 1];",
                        "\t\tSystem.arraycopy(typeDtorChars, 1, tchars, 0, tchars.length);",
                        "",
                        "\t\tICPPTemplateArgument[] templateArgs = data.getTemplateArguments();",
                        "\t\tLookupData ld2 = new LookupData(tchars, templateArgs, data.getLookupPoint());",
                        "\t\tld2.setIgnorePointOfDeclaration(data.isIgnorePointOfDeclaration());",
                        "\t\tld2.contentAssist = data.contentAssist;",
                        "\t\tld2.fNoNarrowing = data.fNoNarrowing;",
                        "\t\tld2.fHeuristicBaseLookup = data.fHeuristicBaseLookup;",
                        "\t\tld2.qualified = parent instanceof ICPPASTQualifiedName;",
                        "\t\tld2.typesOnly = true;",
                        "\t\tlookup(ld2, getLookupScope(typeDtorName));",
                        "\t\tIBinding[] typedefs = ld2.getFoundBindings();",
                        "\t\tITypedef typedef = null;",
                        "\t\tfor (IBinding candidate : typedefs) {",
                        "\t\t\tif (!(candidate instanceof IType)) {",
                        "\t\t\t\tcontinue;",
                        "\t\t\t}",
                        "\t\t\tIType type = (IType) candidate;",
                        "\t\t\tif (templateArgs != null && type instanceof ICPPAliasTemplate) {",
                        "\t\t\t\tIBinding instantiated = CPPTemplates.instantiateAliasTemplate((ICPPAliasTemplate) type, templateArgs);",
                        "\t\t\t\tif (instantiated instanceof IType) {",
                        "\t\t\t\t\ttype = (IType) instantiated;",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t\tif (type instanceof ITypedef) {",
                        "\t\t\t\ttypedef = (ITypedef) type;",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\tif (typedef == null) {",
                        "\t\t\treturn false;",
                        "\t\t}",
                        "",
                        "\t\tIType t = SemanticUtil.getNestedType(typedef, TDEF);",
                        "\t\tif (t instanceof ICPPUnknownBinding || t instanceof ISemanticProblem || !(t instanceof ICPPClassType)) {",
                        "\t\t\treturn false;",
                        "\t\t}",
                        "",
                        "\t\tICPPClassType classType = (ICPPClassType) t;",
                        "\t\tfinal IScope scope = ((ICPPClassType) t).getCompositeScope();",
                        "\t\tif (scope == null) {",
                        "\t\t\treturn false;",
                        "\t\t}",
                        "",
                        "\t\tchar[] classChars = classType.getNameCharArray();",
                        "\t\tchar[] classDtorChars = new char[classChars.length + 1];",
                        "\t\tclassDtorChars[0] = '~';",
                        "\t\tSystem.arraycopy(classChars, 0, classDtorChars, 1, classChars.length);",
                        "\t\tdata.setLookupKey(classDtorChars);",
                        "\t\tlookup(data, scope);",
                        "\t\treturn true;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Checks whether the name directly or indirectly depends on the this pointer.",
                        "\t */",
                        "\tprivate static boolean dependsOnTemplateFieldReference(IASTName astName) {",
                        "\t\tif (astName.getPropertyInParent() != IASTFieldReference.FIELD_NAME)",
                        "\t\t\treturn false;",
                        "",
                        "\t\tfinal boolean[] result = { false };",
                        "\t\tfinal IASTExpression fieldOwner = ((IASTFieldReference) astName.getParent()).getFieldOwner();",
                        "\t\tfieldOwner.accept(new ASTVisitor() {",
                        "\t\t\t{",
                        "\t\t\t\tshouldVisitNames = true;",
                        "\t\t\t\tshouldVisitExpressions = true;",
                        "\t\t\t}",
                        "",
                        "\t\t\t@Override",
                        "\t\t\tpublic int visit(IASTName name) {",
                        "\t\t\t\tIBinding b = name.resolvePreBinding();",
                        "\t\t\t\tif (b instanceof ICPPUnknownBinding || b instanceof ICPPTemplateDefinition) {",
                        "\t\t\t\t\tresult[0] = true;",
                        "\t\t\t\t\treturn PROCESS_ABORT;",
                        "\t\t\t\t}",
                        "\t\t\t\tif (b instanceof ICPPMember) {",
                        "\t\t\t\t\tICPPMember mem = (ICPPMember) b;",
                        "\t\t\t\t\tif (!mem.isStatic()) {",
                        "\t\t\t\t\t\tICPPClassType owner = mem.getClassOwner();",
                        "\t\t\t\t\t\tif (owner instanceof ICPPUnknownBinding || owner instanceof ICPPTemplateDefinition) {",
                        "\t\t\t\t\t\t\tresult[0] = true;",
                        "\t\t\t\t\t\t\treturn PROCESS_ABORT;",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t\tif (b instanceof IVariable) {",
                        "\t\t\t\t\tIType t = SemanticUtil.getUltimateType(((IVariable) b).getType(), true);",
                        "\t\t\t\t\tif (t instanceof ICPPUnknownBinding || t instanceof ICPPTemplateDefinition) {",
                        "\t\t\t\t\t\tresult[0] = true;",
                        "\t\t\t\t\t\treturn PROCESS_ABORT;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t\tif (name instanceof ICPPASTTemplateId)",
                        "\t\t\t\t\treturn PROCESS_SKIP;",
                        "\t\t\t\treturn PROCESS_CONTINUE;",
                        "\t\t\t}",
                        "",
                        "\t\t\t@Override",
                        "\t\t\tpublic int visit(IASTExpression expression) {",
                        "\t\t\t\tif (expression instanceof ICPPASTLiteralExpression) {",
                        "\t\t\t\t\tfinal ICPPASTLiteralExpression litExpr = (ICPPASTLiteralExpression) expression;",
                        "\t\t\t\t\tif (litExpr.getKind() == IASTLiteralExpression.lk_this) {",
                        "\t\t\t\t\t\tfinal IType thisType = SemanticUtil.getNestedType(litExpr.getEvaluation().getType(),",
                        "\t\t\t\t\t\t\t\tTDEF | ALLCVQ | PTR | ARRAY | MPTR | REF);",
                        "\t\t\t\t\t\tif (thisType instanceof ICPPUnknownBinding || thisType instanceof ICPPTemplateDefinition) {",
                        "\t\t\t\t\t\t\tresult[0] = true;",
                        "\t\t\t\t\t\t\treturn PROCESS_ABORT;",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t\tif (expression instanceof IASTUnaryExpression) {",
                        "\t\t\t\t\tswitch (((IASTUnaryExpression) expression).getOperator()) {",
                        "\t\t\t\t\tcase IASTUnaryExpression.op_sizeof:",
                        "\t\t\t\t\tcase IASTUnaryExpression.op_sizeofParameterPack:",
                        "\t\t\t\t\tcase IASTUnaryExpression.op_typeid:",
                        "\t\t\t\t\tcase IASTUnaryExpression.op_throw:",
                        "\t\t\t\t\t\treturn PROCESS_SKIP;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t} else if (expression instanceof IASTTypeIdExpression) {",
                        "\t\t\t\t\tswitch (((IASTTypeIdExpression) expression).getOperator()) {",
                        "\t\t\t\t\tcase IASTTypeIdExpression.op_sizeof:",
                        "\t\t\t\t\tcase IASTTypeIdExpression.op_typeid:",
                        "\t\t\t\t\t\treturn PROCESS_SKIP;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t} else if (expression instanceof IASTCastExpression) {",
                        "\t\t\t\t\tif (!((IASTCastExpression) expression).getTypeId().accept(this)) {",
                        "\t\t\t\t\t\treturn PROCESS_ABORT;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t\treturn PROCESS_SKIP;",
                        "\t\t\t\t} else if (expression instanceof ICPPASTNewExpression) {",
                        "\t\t\t\t\tif (!((ICPPASTNewExpression) expression).getTypeId().accept(this)) {",
                        "\t\t\t\t\t\treturn PROCESS_ABORT;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t\treturn PROCESS_SKIP;",
                        "\t\t\t\t} else if (expression instanceof ICPPASTSimpleTypeConstructorExpression) {",
                        "\t\t\t\t\treturn PROCESS_SKIP;",
                        "\t\t\t\t} else if (expression instanceof IASTTypeIdInitializerExpression) {",
                        "\t\t\t\t\tif (!((IASTTypeIdInitializerExpression) expression).getTypeId().accept(this)) {",
                        "\t\t\t\t\t\treturn PROCESS_ABORT;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t\treturn PROCESS_SKIP;",
                        "\t\t\t\t}",
                        "\t\t\t\treturn PROCESS_CONTINUE;",
                        "\t\t\t}",
                        "\t\t});",
                        "\t\treturn result[0];",
                        "\t}",
                        "",
                        "\tstatic IBinding[] getBindingsFromScope(ICPPScope scope, LookupData data) throws DOMException {",
                        "\t\tIBinding[] bindings = scope.getBindings(data);",
                        "",
                        "\t\tif (scope instanceof ICPPASTInternalScope && scope instanceof ICPPClassScope) {",
                        "\t\t\tfinal IASTName lookupName = data.getLookupName();",
                        "\t\t\tif (LookupData.checkWholeClassScope(lookupName)) {",
                        "\t\t\t\t// Bug 103857: Members declared after the point of completion cannot be",
                        "\t\t\t\t//\t found in the partial AST, we look them up in the index",
                        "\t\t\t\tCPPASTTranslationUnit tu = data.getTranslationUnit();",
                        "\t\t\t\tif (tu != null && tu.isForContentAssist()) {",
                        "\t\t\t\t\tIIndex index = tu.getIndex();",
                        "\t\t\t\t\tIASTNode node = ((IASTInternalScope) scope).getPhysicalNode();",
                        "\t\t\t\t\tif (index != null && node != null && node.contains(lookupName)) {",
                        "\t\t\t\t\t\tIBinding indexBinding = index.adaptBinding(((ICPPClassScope) scope).getClassType());",
                        "\t\t\t\t\t\tif (indexBinding instanceof ICPPClassType) {",
                        "\t\t\t\t\t\t\tIScope scopeInIndex = ((ICPPClassType) indexBinding).getCompositeScope();",
                        "\t\t\t\t\t\t\tbindings = ArrayUtil.addAll(bindings, scopeInIndex.getBindings(data));",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\tif (data.ignoreRecursionResolvingBindings()) {",
                        "\t\t\tbindings = ArrayUtil.filter(bindings, new RecursionResolvingBindingFilter());",
                        "\t\t}",
                        "",
                        "\t\tif (data.namespacesOnly) {",
                        "\t\t\tbindings = ArrayUtil.filter(bindings, (argument) -> {",
                        "\t\t\t\treturn argument instanceof ICPPNamespace;",
                        "\t\t\t});",
                        "\t\t}",
                        "",
                        "\t\treturn expandUsingDeclarationsAndRemoveObjects(bindings, data);",
                        "\t}",
                        "",
                        "\tprivate static class RecursionResolvingBindingFilter implements IUnaryPredicate<IBinding> {",
                        "\t\t@Override",
                        "\t\tpublic boolean apply(IBinding argument) {",
                        "\t\t\treturn !(argument instanceof IRecursionResolvingBinding);",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tprivate static IBinding[] expandUsingDeclarationsAndRemoveObjects(final IBinding[] bindings, LookupData data) {",
                        "\t\tif (bindings == null || bindings.length == 0)",
                        "\t\t\treturn IBinding.EMPTY_BINDING_ARRAY;",
                        "",
                        "\t\tfor (IBinding b : bindings) {",
                        "\t\t\tif (b == null)",
                        "\t\t\t\tbreak;",
                        "",
                        "\t\t\tif (b instanceof ICPPUsingDeclaration || (data.typesOnly && isObject(b))) {",
                        "\t\t\t\tList<IBinding> result = new ArrayList<>(bindings.length);",
                        "\t\t\t\texpandUsingDeclarations(bindings, data, result);",
                        "\t\t\t\treturn result.toArray(new IBinding[result.size()]);",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\treturn bindings;",
                        "\t}",
                        "",
                        "\tprivate static boolean isObject(IBinding b) {",
                        "\t\treturn !(b instanceof IType || b instanceof ICPPNamespace);",
                        "\t}",
                        "",
                        "\tprivate static void expandUsingDeclarations(IBinding[] bindings, LookupData data, List<IBinding> result) {",
                        "\t\tif (bindings != null) {",
                        "\t\t\tfor (IBinding b : bindings) {",
                        "\t\t\t\tif (b == null)",
                        "\t\t\t\t\treturn;",
                        "\t\t\t\t// Lookup for a declaration shall ignore the using declarations.",
                        "\t\t\t\tif (b instanceof ICPPUsingDeclaration) {",
                        "\t\t\t\t\tif (data.forDeclaration() == null) {",
                        "\t\t\t\t\t\tfor (IBinding d : ((ICPPUsingDeclaration) b).getDelegates()) {",
                        "\t\t\t\t\t\t\t// Note on excluding constructors:",
                        "\t\t\t\t\t\t\t// Constructors are never found during name lookup ([class.ctor] p2).",
                        "\t\t\t\t\t\t\t// Binding resolution sometimes resolves names to constructors, and as",
                        "\t\t\t\t\t\t\t// such, the delegates of a using-declaration can include constructors,",
                        "\t\t\t\t\t\t\t// but when using these delegates in the process of name lookup,",
                        "\t\t\t\t\t\t\t// constructors are ignored. If the binding resolution triggering this",
                        "\t\t\t\t\t\t\t// name lookup wants to ultimately resolve to a constructor, it can do so",
                        "\t\t\t\t\t\t\t// after the name lookup phase, e.g. in the convertClassToConstructor()",
                        "\t\t\t\t\t\t\t// call in postResolution().",
                        "\t\t\t\t\t\t\tif (d != null && !(data.typesOnly && isObject(d)) && !(d instanceof ICPPConstructor)) {",
                        "\t\t\t\t\t\t\t\tresult.add(d);",
                        "\t\t\t\t\t\t\t}",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t}",
                        "\t\t\t\t} else if (!(data.typesOnly && isObject(b))) {",
                        "\t\t\t\t\tresult.add(b);",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tprivate static ICPPTemplateScope enclosingTemplateScope(IASTNode node) {",
                        "\t\tIASTNode parent = node.getParent();",
                        "\t\tif (parent instanceof IASTName) {",
                        "\t\t\tif (parent instanceof ICPPASTTemplateId) {",
                        "\t\t\t\tnode = parent;",
                        "\t\t\t\tparent = node.getParent();",
                        "\t\t\t}",
                        "\t\t\tif (parent instanceof ICPPASTQualifiedName) {",
                        "\t\t\t\tICPPASTQualifiedName qname = (ICPPASTQualifiedName) parent;",
                        "\t\t\t\tif (qname.isFullyQualified() || qname.getQualifier()[0] != node)",
                        "\t\t\t\t\treturn null;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\twhile (!(parent instanceof ICPPASTTemplateDeclaration)) {",
                        "\t\t\tif (parent == null)",
                        "\t\t\t\treturn null;",
                        "\t\t\tparent = parent.getParent();",
                        "\t\t}",
                        "\t\treturn ((ICPPASTTemplateDeclaration) parent).getScope();",
                        "\t}",
                        "",
                        "\tstatic ICPPScope getParentScope(IScope scope, IASTTranslationUnit unit) throws DOMException {",
                        "\t\tIScope parentScope = scope.getParent();",
                        "\t\t// The index cannot return the translation unit as parent scope.",
                        "\t\tif (parentScope == null && scope instanceof ICPPClassSpecializationScope",
                        "\t\t\t\t&& unit instanceof CPPASTTranslationUnit) {",
                        "\t\t\tparentScope = unit.getScope();",
                        "\t\t} else {",
                        "\t\t\tparentScope = SemanticUtil.mapToAST(parentScope, unit);",
                        "\t\t}",
                        "\t\treturn (ICPPScope) parentScope;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Stores the using directive with the scope where the members of the nominated namespace will",
                        "\t * appear. In case of an unqualified lookup the transitive directives are stored, also.",
                        "\t * This is important because the members nominated by a transitive directive can appear before",
                        "\t * those of the original directive.",
                        "\t */",
                        "\tprivate static void storeUsingDirective(LookupData data, ICPPNamespaceScope container, ICPPUsingDirective directive,",
                        "\t\t\tSet<ICPPNamespaceScope> handled) throws DOMException {",
                        "\t\tICPPNamespaceScope nominated = directive.getNominatedScope();",
                        "\t\tCPPASTTranslationUnit tu = data.getTranslationUnit();",
                        "\t\tif (tu != null) {",
                        "\t\t\tnominated = (ICPPNamespaceScope) tu.mapToASTScope(nominated);",
                        "\t\t}",
                        "\t\tif (nominated == null || data.visited.containsKey(nominated) || (handled != null && !handled.add(nominated))) {",
                        "\t\t\treturn;",
                        "\t\t}",
                        "\t\t// 7.3.4.1 names appear at end of common enclosing scope of container and nominated scope.",
                        "\t\tfinal IScope appearsIn = getCommonEnclosingScope(nominated, container, tu);",
                        "\t\tif (appearsIn instanceof ICPPNamespaceScope) {",
                        "\t\t\t// store the directive with the scope where it has to be considered",
                        "\t\t\tList<ICPPNamespaceScope> listOfNominated = data.usingDirectives.get(appearsIn);",
                        "\t\t\tif (listOfNominated == null) {",
                        "\t\t\t\tlistOfNominated = new ArrayList<>(1);",
                        "\t\t\t\tif (data.usingDirectives.isEmpty()) {",
                        "\t\t\t\t\tdata.usingDirectives = new HashMap<>();",
                        "\t\t\t\t}",
                        "\t\t\t\tdata.usingDirectives.put((ICPPNamespaceScope) appearsIn, listOfNominated);",
                        "\t\t\t}",
                        "\t\t\tlistOfNominated.add(nominated);",
                        "\t\t}",
                        "",
                        "\t\t// In a non-qualified lookup the transitive directive have to be stored right away,",
                        "\t\t// they may overtake the container.",
                        "\t\tif (!data.qualified || data.contentAssist) {",
                        "\t\t\tassert handled != null;",
                        "\t\t\tif (tu != null) {",
                        "\t\t\t\ttu.handleAdditionalDirectives(nominated);",
                        "\t\t\t}",
                        "\t\t\tICPPUsingDirective[] transitive = nominated.getUsingDirectives();",
                        "\t\t\tfor (ICPPUsingDirective element : transitive) {",
                        "\t\t\t\tstoreUsingDirective(data, container, element, handled);",
                        "\t\t\t}",
                        "\t\t}",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Computes the common enclosing scope of s1 and s2.",
                        "\t */",
                        "\tprivate static ICPPScope getCommonEnclosingScope(IScope s1, IScope s2, ICPPASTTranslationUnit tu)",
                        "\t\t\tthrows DOMException {",
                        "\t\tObjectSet<IScope> set = new ObjectSet<>(2);",
                        "\t\tIScope parent = s1;",
                        "\t\twhile (parent != null) {",
                        "\t\t\tset.put(parent);",
                        "\t\t\tparent = getParentScope(parent, tu);",
                        "\t\t}",
                        "\t\tparent = s2;",
                        "\t\twhile (parent != null && !set.containsKey(parent)) {",
                        "\t\t\tparent = getParentScope(parent, tu);",
                        "\t\t}",
                        "\t\treturn (ICPPScope) parent;",
                        "\t}",
                        "",
                        "\tpublic static void populateCache(ICPPASTInternalScope scope) {",
                        "\t\tIASTNode[] nodes = null;",
                        "\t\tIASTNode parent = ASTInternal.getPhysicalNodeOfScope(scope);",
                        "",
                        "\t\tIASTName[] namespaceDefs = null;",
                        "\t\tint namespaceIdx = -1;",
                        "",
                        "\t\tif (parent instanceof IASTCompoundStatement) {",
                        "\t\t\tIASTNode p = parent.getParent();",
                        "\t\t\tif (p instanceof IASTFunctionDefinition) {",
                        "\t\t\t\tICPPASTFunctionDeclarator dtor = (ICPPASTFunctionDeclarator) ((IASTFunctionDefinition) p)",
                        "\t\t\t\t\t\t.getDeclarator();",
                        "\t\t\t\tnodes = dtor.getParameters();",
                        "\t\t\t} else if (p instanceof ICPPASTLambdaExpression) {",
                        "\t\t\t\tICPPASTLambdaExpression lambdaExpression = (ICPPASTLambdaExpression) p;",
                        "\t\t\t\tfor (ICPPASTCapture capture : lambdaExpression.getCaptures()) {",
                        "\t\t\t\t\tif (capture instanceof ICPPASTInitCapture) {",
                        "\t\t\t\t\t\tIASTName name = capture.getIdentifier();",
                        "\t\t\t\t\t\tif (name != null) {",
                        "\t\t\t\t\t\t\tASTInternal.addName(scope, name);",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t\tICPPASTFunctionDeclarator lambdaDeclarator = lambdaExpression.getDeclarator();",
                        "\t\t\t\tif (lambdaDeclarator != null) {",
                        "\t\t\t\t\tnodes = lambdaDeclarator.getParameters();",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t\tif (p instanceof ICPPASTCatchHandler) {",
                        "\t\t\t\tparent = p;",
                        "\t\t\t} else if (nodes == null || nodes.length == 0) {",
                        "\t\t\t\tIASTCompoundStatement compound = (IASTCompoundStatement) parent;",
                        "\t\t\t\tnodes = compound.getStatements();",
                        "\t\t\t}",
                        "\t\t} else if (parent instanceof IASTTranslationUnit) {",
                        "\t\t\tIASTTranslationUnit translation = (IASTTranslationUnit) parent;",
                        "\t\t\tnodes = translation.getDeclarations();",
                        "\t\t} else if (parent instanceof ICPPASTCompositeTypeSpecifier) {",
                        "\t\t\tICPPASTCompositeTypeSpecifier comp = (ICPPASTCompositeTypeSpecifier) parent;",
                        "\t\t\tnodes = comp.getMembers();",
                        "\t\t} else if (parent instanceof ICPPASTNamespaceDefinition) {",
                        "\t\t\t// Need binding because namespaces can be split.",
                        "\t\t\tCPPNamespace namespace = (CPPNamespace) ((ICPPASTNamespaceDefinition) parent).getName().resolveBinding();",
                        "\t\t\tnamespaceDefs = namespace.getNamespaceDefinitions();",
                        "\t\t\tnodes = ((ICPPASTNamespaceDefinition) namespaceDefs[++namespaceIdx].getParent()).getDeclarations();",
                        "\t\t\twhile (nodes.length == 0 && ++namespaceIdx < namespaceDefs.length) {",
                        "\t\t\t\tnodes = ((ICPPASTNamespaceDefinition) namespaceDefs[namespaceIdx].getParent()).getDeclarations();",
                        "\t\t\t}",
                        "\t\t} else if (parent instanceof ICPPASTFunctionDeclarator) {",
                        "\t\t\tICPPASTFunctionDeclarator dtor = (ICPPASTFunctionDeclarator) parent;",
                        "\t\t\tnodes = dtor.getParameters();",
                        "\t\t} else if (parent instanceof ICPPASTTemplateDeclaration) {",
                        "\t\t\tICPPASTTemplateDeclaration template = (ICPPASTTemplateDeclaration) parent;",
                        "\t\t\tnodes = template.getTemplateParameters();",
                        "\t\t} else if (parent instanceof ICPPASTForStatement) {",
                        "\t\t\tICPPASTForStatement forStatement = (ICPPASTForStatement) parent;",
                        "\t\t\tfinal IASTDeclaration conditionDeclaration = forStatement.getConditionDeclaration();",
                        "\t\t\tIASTStatement initDeclaration = forStatement.getInitializerStatement();",
                        "\t\t\tif (conditionDeclaration != null) {",
                        "\t\t\t\tnodes = new IASTNode[] { initDeclaration, conditionDeclaration };",
                        "\t\t\t} else {",
                        "\t\t\t\tnodes = new IASTNode[] { initDeclaration };",
                        "\t\t\t}",
                        "\t\t} else if (parent instanceof ICPPASTSwitchStatement) {",
                        "\t\t\tICPPASTSwitchStatement ifStatement = (ICPPASTSwitchStatement) parent;",
                        "\t\t\tfinal IASTStatement initStatement = ifStatement.getInitializerStatement();",
                        "\t\t\tfinal IASTDeclaration controllerDeclaration = ifStatement.getControllerDeclaration();",
                        "\t\t\tif (initStatement != null) {",
                        "\t\t\t\tnodes = new IASTNode[] { initStatement, controllerDeclaration };",
                        "\t\t\t} else {",
                        "\t\t\t\tnodes = new IASTNode[] { controllerDeclaration };",
                        "\t\t\t}",
                        "\t\t} else if (parent instanceof ICPPASTIfStatement) {",
                        "\t\t\tICPPASTIfStatement ifStatement = (ICPPASTIfStatement) parent;",
                        "\t\t\tfinal IASTStatement initStatement = ifStatement.getInitializerStatement();",
                        "\t\t\tfinal IASTDeclaration conditionDeclaration = ifStatement.getConditionDeclaration();",
                        "\t\t\tif (initStatement != null) {",
                        "\t\t\t\tnodes = new IASTNode[] { initStatement, conditionDeclaration };",
                        "\t\t\t} else {",
                        "\t\t\t\tnodes = new IASTNode[] { conditionDeclaration };",
                        "\t\t\t}",
                        "\t\t} else if (parent instanceof ICPPASTWhileStatement) {",
                        "\t\t\tnodes = new IASTNode[] { ((ICPPASTWhileStatement) parent).getConditionDeclaration() };",
                        "\t\t} else if (parent instanceof ICPPASTRangeBasedForStatement) {",
                        "\t\t\tICPPASTRangeBasedForStatement forStatement = (ICPPASTRangeBasedForStatement) parent;",
                        "\t\t\tfinal IASTDeclaration decl = forStatement.getDeclaration();",
                        "\t\t\tnodes = new IASTNode[] { decl };",
                        "\t\t} else if (parent instanceof ICPPASTEnumerationSpecifier) {",
                        "\t\t\t// The enumeration scope contains the enumeration items",
                        "\t\t\tfor (IASTEnumerator enumerator : ((ICPPASTEnumerationSpecifier) parent).getEnumerators()) {",
                        "\t\t\t\tASTInternal.addName(scope, enumerator.getName());",
                        "\t\t\t}",
                        "\t\t\treturn;",
                        "\t\t} else if (parent instanceof ICPPASTTemplatedTypeTemplateParameter) {",
                        "\t\t\t// The template-template parameter scope contains the parameters",
                        "\t\t\tfor (ICPPASTTemplateParameter par : ((ICPPASTTemplatedTypeTemplateParameter) parent)",
                        "\t\t\t\t\t.getTemplateParameters()) {",
                        "\t\t\t\tIASTName name = CPPTemplates.getTemplateParameterName(par);",
                        "\t\t\t\tif (name != null) {",
                        "\t\t\t\t\tASTInternal.addName(scope, name);",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t\treturn;",
                        "\t\t}",
                        "",
                        "\t\tint idx = -1;",
                        "\t\tIASTNode item = (nodes != null ? (nodes.length > 0 ? nodes[++idx] : null) : parent);",
                        "\t\tIASTNode[][] nodeStack = null;",
                        "\t\tint[] nodeIdxStack = null;",
                        "\t\tint nodeStackPos = -1;",
                        "\t\twhile (item != null) {",
                        "\t\t\tif (item instanceof ICPPASTLinkageSpecification) {",
                        "\t\t\t\tIASTDeclaration[] decls = ((ICPPASTLinkageSpecification) item).getDeclarations();",
                        "\t\t\t\tif (decls != null && decls.length > 0) {",
                        "\t\t\t\t\tnodeStack = ArrayUtil.append(IASTNode[].class, nodeStack, nodes);",
                        "\t\t\t\t\tnodeIdxStack = ArrayUtil.setInt(nodeIdxStack, ++nodeStackPos, idx);",
                        "\t\t\t\t\tnodes = ((ICPPASTLinkageSpecification) item).getDeclarations();",
                        "\t\t\t\t\tidx = 0;",
                        "\t\t\t\t\titem = nodes[idx];",
                        "\t\t\t\t\tcontinue;",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t\twhile (item instanceof IASTLabelStatement) {",
                        "\t\t\t\titem = ((IASTLabelStatement) item).getNestedStatement();",
                        "\t\t\t}",
                        "\t\t\tif (item instanceof IASTDeclarationStatement)",
                        "\t\t\t\titem = ((IASTDeclarationStatement) item).getDeclaration();",
                        "\t\t\tif (item instanceof ICPPASTUsingDirective) {",
                        "\t\t\t\tif (scope instanceof ICPPNamespaceScope) {",
                        "\t\t\t\t\tfinal ICPPNamespaceScope nsscope = (ICPPNamespaceScope) scope;",
                        "\t\t\t\t\tfinal ICPPASTUsingDirective usingDirective = (ICPPASTUsingDirective) item;",
                        "\t\t\t\t\tnsscope.addUsingDirective(new CPPUsingDirective(usingDirective));",
                        "\t\t\t\t}",
                        "\t\t\t} else if (item instanceof ICPPASTNamespaceDefinition) {",
                        "\t\t\t\tfinal ICPPASTNamespaceDefinition nsDef = (ICPPASTNamespaceDefinition) item;",
                        "\t\t\t\tfinal boolean isUnnamed = nsDef.getName().getLookupKey().length == 0;",
                        "\t\t\t\tboolean isInline = nsDef.isInline();",
                        "\t\t\t\t// An inline namespace can be re-opened without repeating the inline keyword,",
                        "\t\t\t\t// so we need to consult the binding to check inlineness.",
                        "\t\t\t\tif (!isUnnamed && !isInline) {",
                        "\t\t\t\t\tIBinding nsBinding = nsDef.getName().resolveBinding();",
                        "\t\t\t\t\tif (nsBinding instanceof ICPPNamespace) {",
                        "\t\t\t\t\t\tisInline = ((ICPPNamespace) nsBinding).isInline();",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t\tif (isUnnamed || isInline) {",
                        "\t\t\t\t\tif (scope instanceof CPPNamespaceScope) {",
                        "\t\t\t\t\t\tfinal CPPNamespaceScope nsscope = (CPPNamespaceScope) scope;",
                        "\t\t\t\t\t\tnsscope.addUsingDirective(new CPPUsingDirective(nsDef));",
                        "\t\t\t\t\t\tif (isInline) {",
                        "\t\t\t\t\t\t\tnsscope.addInlineNamespace(nsDef);",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t\tif (!isUnnamed) {",
                        "\t\t\t\t\tpopulateCache(scope, item);",
                        "\t\t\t\t}",
                        "\t\t\t} else {",
                        "\t\t\t\tpopulateCache(scope, item);",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (nodes != null && ++idx < nodes.length) {",
                        "\t\t\t\titem = nodes[idx];",
                        "\t\t\t} else {",
                        "\t\t\t\titem = null;",
                        "\t\t\t\twhile (true) {",
                        "\t\t\t\t\tif (namespaceDefs != null) {",
                        "\t\t\t\t\t\t// Check all definitions of this namespace.",
                        "\t\t\t\t\t\twhile (++namespaceIdx < namespaceDefs.length) {",
                        "\t\t\t\t\t\t\tnodes = ((ICPPASTNamespaceDefinition) namespaceDefs[namespaceIdx].getParent())",
                        "\t\t\t\t\t\t\t\t\t.getDeclarations();",
                        "\t\t\t\t\t\t\tif (nodes.length > 0) {",
                        "\t\t\t\t\t\t\t\tidx = 0;",
                        "\t\t\t\t\t\t\t\titem = nodes[0];",
                        "\t\t\t\t\t\t\t\tbreak;",
                        "\t\t\t\t\t\t\t}",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t} else if (parent instanceof IASTCompoundStatement && nodes instanceof IASTParameterDeclaration[]) {",
                        "\t\t\t\t\t\t// Function body, we were looking at parameters, now check the body itself.",
                        "\t\t\t\t\t\tIASTCompoundStatement compound = (IASTCompoundStatement) parent;",
                        "\t\t\t\t\t\tnodes = compound.getStatements();",
                        "\t\t\t\t\t\tif (nodes.length > 0) {",
                        "\t\t\t\t\t\t\tidx = 0;",
                        "\t\t\t\t\t\t\titem = nodes[0];",
                        "\t\t\t\t\t\t\tbreak;",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t} else if (parent instanceof ICPPASTCatchHandler) {",
                        "\t\t\t\t\t\tparent = ((ICPPASTCatchHandler) parent).getCatchBody();",
                        "\t\t\t\t\t\tif (parent instanceof IASTCompoundStatement) {",
                        "\t\t\t\t\t\t\tnodes = ((IASTCompoundStatement) parent).getStatements();",
                        "\t\t\t\t\t\t\tif (nodes.length > 0) {",
                        "\t\t\t\t\t\t\t\tidx = 0;",
                        "\t\t\t\t\t\t\t\titem = nodes[0];",
                        "\t\t\t\t\t\t\t\tbreak;",
                        "\t\t\t\t\t\t\t}",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t}",
                        "\t\t\t\t\tif (item == null && nodeStack != null && nodeIdxStack != null && nodeStackPos >= 0) {",
                        "\t\t\t\t\t\tnodes = nodeStack[nodeStackPos];",
                        "\t\t\t\t\t\tnodeStack[nodeStackPos] = null;",
                        "\t\t\t\t\t\tidx = nodeIdxStack[nodeStackPos--];",
                        "\t\t\t\t\t\tif (++idx >= nodes.length)",
                        "\t\t\t\t\t\t\tcontinue;",
                        "",
                        "\t\t\t\t\t\titem = nodes[idx];",
                        "\t\t\t\t\t}",
                        "\t\t\t\t\tbreak;",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tpublic static void populateCache(ICPPASTInternalScope scope, IASTNode node) {",
                        "\t\tIASTDeclaration declaration = null;",
                        "\t\tif (node instanceof ICPPASTTemplateDeclaration) {",
                        "\t\t\tdeclaration = ((ICPPASTTemplateDeclaration) node).getDeclaration();",
                        "\t\t} else if (node instanceof IASTDeclaration) {",
                        "\t\t\tdeclaration = (IASTDeclaration) node;",
                        "\t\t} else if (node instanceof IASTDeclarationStatement) {",
                        "\t\t\tdeclaration = ((IASTDeclarationStatement) node).getDeclaration();",
                        "\t\t} else if (node instanceof ICPPASTCatchHandler) {",
                        "\t\t\tdeclaration = ((ICPPASTCatchHandler) node).getDeclaration();",
                        "\t\t} else if (node instanceof IASTParameterDeclaration) {",
                        "\t\t\tIASTParameterDeclaration parameterDeclaration = (IASTParameterDeclaration) node;",
                        "\t\t\tIASTDeclarator dtor = parameterDeclaration.getDeclarator();",
                        "\t\t\tIASTDeclarator innermost = dtor;",
                        "\t\t\twhile (dtor != null) {",
                        "\t\t\t\tif (dtor instanceof IASTAmbiguousDeclarator)",
                        "\t\t\t\t\treturn;",
                        "\t\t\t\tinnermost = dtor;",
                        "\t\t\t\tdtor = dtor.getNestedDeclarator();",
                        "\t\t\t}",
                        "\t\t\tif (innermost != null) { // Could be null when content assist in the declSpec",
                        "\t\t\t\tIASTName declName = innermost.getName();",
                        "\t\t\t\tASTInternal.addName(scope, declName);",
                        "\t\t\t\treturn;",
                        "\t\t\t}",
                        "\t\t} else if (node instanceof ICPPASTTemplateParameter) {",
                        "\t\t\tIASTName name = CPPTemplates.getTemplateParameterName((ICPPASTTemplateParameter) node);",
                        "\t\t\tASTInternal.addName(scope, name);",
                        "\t\t\treturn;",
                        "\t\t}",
                        "\t\tif (declaration == null || declaration instanceof ASTAmbiguousNode) {",
                        "\t\t\treturn;",
                        "\t\t}",
                        "",
                        "\t\tif (declaration instanceof IASTSimpleDeclaration) {",
                        "\t\t\tIASTSimpleDeclaration simpleDeclaration = (IASTSimpleDeclaration) declaration;",
                        "\t\t\tICPPASTDeclSpecifier declSpec = (ICPPASTDeclSpecifier) simpleDeclaration.getDeclSpecifier();",
                        "\t\t\tIASTDeclarator[] declarators = simpleDeclaration.getDeclarators();",
                        "\t\t\tif (!declSpec.isFriend()) {",
                        "\t\t\t\tfor (IASTDeclarator declarator : declarators) {",
                        "\t\t\t\t\tIASTDeclarator innermost = null;",
                        "\t\t\t\t\twhile (declarator != null) {",
                        "\t\t\t\t\t\tif (declarator instanceof IASTAmbiguousDeclarator) {",
                        "\t\t\t\t\t\t\tinnermost = null;",
                        "\t\t\t\t\t\t\tbreak;",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t\tinnermost = declarator;",
                        "\t\t\t\t\t\tdeclarator = declarator.getNestedDeclarator();",
                        "\t\t\t\t\t}",
                        "\t\t\t\t\tif (innermost != null) {",
                        "\t\t\t\t\t\tIASTName declaratorName = innermost.getName();",
                        "\t\t\t\t\t\tASTInternal.addName(scope, declaratorName);",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "",
                        "\t\t\t// Declaration specifiers defining or declaring a type",
                        "\t\t\tIASTName specName = null;",
                        "\t\t\tfinal EScopeKind scopeKind = scope.getKind();",
                        "\t\t\tif (declSpec instanceof IASTElaboratedTypeSpecifier) {",
                        "\t\t\t\t// 3.3.1.5 Point of declaration",
                        "\t\t\t\tif (!declSpec.isFriend()) {",
                        "\t\t\t\t\tif (declarators.length == 0 || scopeKind == EScopeKind.eGlobal",
                        "\t\t\t\t\t\t\t|| scopeKind == EScopeKind.eNamespace) {",
                        "\t\t\t\t\t\tspecName = ((IASTElaboratedTypeSpecifier) declSpec).getName();",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t} else if (declSpec instanceof ICPPASTCompositeTypeSpecifier) {",
                        "\t\t\t\tICPPASTCompositeTypeSpecifier compSpec = (ICPPASTCompositeTypeSpecifier) declSpec;",
                        "\t\t\t\tspecName = compSpec.getName();",
                        "",
                        "\t\t\t\t// Anonymous union or struct (GCC supports anonymous structs too)",
                        "\t\t\t\tif (declarators.length == 0 && specName.getLookupKey().length == 0) {",
                        "\t\t\t\t\tIASTDeclaration[] decls = compSpec.getMembers();",
                        "\t\t\t\t\tfor (IASTDeclaration decl : decls) {",
                        "\t\t\t\t\t\tpopulateCache(scope, decl);",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t} else if (declSpec instanceof ICPPASTEnumerationSpecifier) {",
                        "\t\t\t\tICPPASTEnumerationSpecifier enumeration = (ICPPASTEnumerationSpecifier) declSpec;",
                        "\t\t\t\tspecName = enumeration.getName();",
                        "",
                        "\t\t\t\thandleEnumeration(enumeration, scope);",
                        "\t\t\t}",
                        "\t\t\tif (specName != null) {",
                        "\t\t\t\tif (!(specName instanceof ICPPASTQualifiedName)) {",
                        "\t\t\t\t\tASTInternal.addName(scope, specName);",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t\t// Collect friends and elaborated type specifiers with declarators from nested classes.",
                        "\t\t\tif (declarators.length > 0 || declSpec instanceof ICPPASTCompositeTypeSpecifier) {",
                        "\t\t\t\tswitch (scopeKind) {",
                        "\t\t\t\tcase eLocal:",
                        "\t\t\t\tcase eGlobal:",
                        "\t\t\t\tcase eNamespace:",
                        "\t\t\t\t\tNamespaceTypeCollector visitor = new NamespaceTypeCollector(scope);",
                        "\t\t\t\t\tdeclSpec.accept(visitor);",
                        "\t\t\t\t\tfor (IASTDeclarator dtor : declarators) {",
                        "\t\t\t\t\t\tdtor.accept(visitor);",
                        "\t\t\t\t\t}",
                        "\t\t\t\t\tbreak;",
                        "",
                        "\t\t\t\tdefault:",
                        "\t\t\t\t\tbreak;",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t} else if (declaration instanceof ICPPASTUsingDeclaration) {",
                        "\t\t\tICPPASTUsingDeclaration using = (ICPPASTUsingDeclaration) declaration;",
                        "\t\t\tIASTName name = using.getName();",
                        "\t\t\tif (name instanceof ICPPASTQualifiedName) {",
                        "\t\t\t\tname = name.getLastName();",
                        "\t\t\t}",
                        "\t\t\tASTInternal.addName(scope, name);",
                        "\t\t} else if (declaration instanceof ICPPASTNamespaceDefinition) {",
                        "\t\t\tIASTName namespaceName = ((ICPPASTNamespaceDefinition) declaration).getName();",
                        "\t\t\tASTInternal.addName(scope, namespaceName);",
                        "\t\t} else if (declaration instanceof ICPPASTNamespaceAlias) {",
                        "\t\t\tIASTName alias = ((ICPPASTNamespaceAlias) declaration).getAlias();",
                        "\t\t\tASTInternal.addName(scope, alias);",
                        "\t\t} else if (declaration instanceof ICPPASTAliasDeclaration) {",
                        "\t\t\tICPPASTAliasDeclaration aliasDecl = (ICPPASTAliasDeclaration) declaration;",
                        "\t\t\tIASTName alias = aliasDecl.getAlias();",
                        "\t\t\tASTInternal.addName(scope, alias);",
                        "",
                        "\t\t\t// The mapping-type-id could declare an enumeration.",
                        "\t\t\tIASTDeclSpecifier declSpec = aliasDecl.getMappingTypeId().getDeclSpecifier();",
                        "\t\t\tif (declSpec instanceof ICPPASTEnumerationSpecifier) {",
                        "\t\t\t\thandleEnumeration((ICPPASTEnumerationSpecifier) declSpec, scope);",
                        "\t\t\t}",
                        "\t\t} else if (declaration instanceof IASTFunctionDefinition) {",
                        "\t\t\tIASTFunctionDefinition functionDef = (IASTFunctionDefinition) declaration;",
                        "\t\t\tfinal IASTDeclSpecifier declSpec = functionDef.getDeclSpecifier();",
                        "\t\t\tIASTFunctionDeclarator declarator = functionDef.getDeclarator();",
                        "",
                        "\t\t\tif (!((ICPPASTDeclSpecifier) declSpec).isFriend()) {",
                        "\t\t\t\t// Check the function itself",
                        "\t\t\t\tIASTName declName = ASTQueries.findInnermostDeclarator(declarator).getName();",
                        "\t\t\t\tASTInternal.addName(scope, declName);",
                        "\t\t\t}",
                        "\t\t\t// Collect elaborated type specifiers and friends",
                        "\t\t\tfinal EScopeKind scopeKind = scope.getKind();",
                        "\t\t\tswitch (scopeKind) {",
                        "\t\t\tcase eLocal:",
                        "\t\t\tcase eGlobal:",
                        "\t\t\tcase eNamespace:",
                        "\t\t\t\tNamespaceTypeCollector visitor = new NamespaceTypeCollector(scope);",
                        "\t\t\t\tdeclSpec.accept(visitor);",
                        "\t\t\t\tdeclarator.accept(visitor);",
                        "\t\t\t\tbreak;",
                        "",
                        "\t\t\tdefault:",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tprivate static void handleEnumeration(ICPPASTEnumerationSpecifier enumSpec, IScope enclosingScope) {",
                        "\t\t// Add unscoped enumerators to the enclosing scope",
                        "\t\tif (!enumSpec.isScoped()) {",
                        "\t\t\tfor (IASTEnumerator enumerator : enumSpec.getEnumerators()) {",
                        "\t\t\t\tASTInternal.addName(enclosingScope, enumerator.getName());",
                        "\t\t\t}",
                        "\t\t}",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Perform lookup in nominated namespaces that appear in the given scope. For unqualified",
                        "\t * lookups the method assumes that transitive directives have been stored in the lookup-data.",
                        "\t * For qualified lookups the transitive directives are considered if the lookup of the original",
                        "\t * directive returns empty.",
                        "\t */",
                        "\tprivate static void lookupInNominated(LookupData data, ICPPNamespaceScope scope) throws DOMException {",
                        "\t\tList<ICPPNamespaceScope> allNominated = data.usingDirectives.remove(scope);",
                        "\t\twhile (allNominated != null) {",
                        "\t\t\tfor (ICPPNamespaceScope nominated : allNominated) {",
                        "\t\t\t\tif (data.visited.containsKey(nominated)) {",
                        "\t\t\t\t\tcontinue;",
                        "\t\t\t\t}",
                        "\t\t\t\tdata.visited.put(nominated);",
                        "",
                        "\t\t\t\tboolean found = false;",
                        "\t\t\t\tIBinding[] bindings = getBindingsFromScope(nominated, data);",
                        "\t\t\t\tif (bindings != null && bindings.length > 0) {",
                        "\t\t\t\t\tmergeResults(data, bindings, true);",
                        "\t\t\t\t\tfound = true;",
                        "\t\t\t\t}",
                        "",
                        "\t\t\t\t// In the qualified lookup we have to nominate the transitive directives only when",
                        "\t\t\t\t// the lookup did not succeed. In the qualified case this is done earlier, when",
                        "\t\t\t\t// the directive is encountered.",
                        "\t\t\t\tif (!found && data.qualified && !data.contentAssist) {",
                        "\t\t\t\t\tfinal CPPASTTranslationUnit tu = data.getTranslationUnit();",
                        "\t\t\t\t\tif (tu != null) {",
                        "\t\t\t\t\t\ttu.handleAdditionalDirectives(nominated);",
                        "\t\t\t\t\t}",
                        "\t\t\t\t\tICPPUsingDirective[] usings = nominated.getUsingDirectives();",
                        "\t\t\t\t\tfor (ICPPUsingDirective using : usings) {",
                        "\t\t\t\t\t\tstoreUsingDirective(data, scope, using, null);",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t\t// Retry with transitive directives that may have been nominated in a qualified lookup",
                        "\t\t\tallNominated = data.usingDirectives.remove(scope);",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tpublic static IBinding resolveAmbiguities(IASTName name, Object[] bindings) {",
                        "\t\tbindings = ArrayUtil.trim(Object.class, bindings);",
                        "\t\tif (bindings == null || bindings.length == 0) {",
                        "\t\t\treturn null;",
                        "\t\t} else if (bindings.length == 1) {",
                        "\t\t\tIBinding candidate = null;",
                        "\t\t\tif (bindings[0] instanceof IBinding) {",
                        "\t\t\t\tcandidate = (IBinding) bindings[0];",
                        "\t\t\t} else if (bindings[0] instanceof IASTName) {",
                        "\t\t\t\tcandidate = ((IASTName) bindings[0]).getPreBinding();",
                        "\t\t\t} else {",
                        "\t\t\t\treturn null;",
                        "\t\t\t}",
                        "\t\t\tif (candidate != null) {",
                        "\t\t\t\tif (!(candidate instanceof IType) && !(candidate instanceof ICPPNamespace)",
                        "\t\t\t\t\t\t&& !(candidate instanceof ICPPUsingDeclaration) && LookupData.typesOnly(name)) {",
                        "\t\t\t\t\treturn null;",
                        "\t\t\t\t}",
                        "",
                        "\t\t\t\t// Bug 238180",
                        "\t\t\t\tif (candidate instanceof ICPPClassTemplatePartialSpecialization)",
                        "\t\t\t\t\treturn null;",
                        "",
                        "\t\t\t\t// Specialization is selected during instantiation",
                        "\t\t\t\tif (candidate instanceof ICPPTemplateInstance)",
                        "\t\t\t\t\tcandidate = ((ICPPTemplateInstance) candidate).getSpecializedBinding();",
                        "",
                        "\t\t\t\tif (!(candidate instanceof ICPPFunctionTemplate))",
                        "\t\t\t\t\treturn candidate;",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\tLookupData data = createLookupData(name);",
                        "\t\tdata.foundItems = bindings;",
                        "\t\ttry {",
                        "\t\t\treturn resolveAmbiguities(data);",
                        "\t\t} catch (DOMException e) {",
                        "\t\t\treturn e.getProblem();",
                        "\t\t}",
                        "\t\t//",
                        "\t\t//        IBinding[] result = null;",
                        "\t\t//        for (Object binding : bindings) {",
                        "\t\t//            if (binding instanceof IASTName) {",
                        "\t\t//                result = ArrayUtil.append(IBinding.class, result, ((IASTName) binding).resolveBinding());",
                        "\t\t//            } else if (binding instanceof IBinding) {",
                        "\t\t//                result = ArrayUtil.append(IBinding.class, result, (IBinding) binding);",
                        "\t\t//            }",
                        "\t\t//        }",
                        "\t\t//        return new CPPCompositeBinding(result);",
                        "\t}",
                        "",
                        "\tpublic static boolean declaredBefore(Object obj, IASTNode node, boolean indexBased) {",
                        "\t\tif (node instanceof IPDOMAdaptedASTNode) {",
                        "\t\t\t// Get the underlying ASTNode.",
                        "\t\t\tnode = ((IPDOMAdaptedASTNode) node).getDelegate();",
                        "\t\t}",
                        "\t\tif (!(node instanceof ASTNode))",
                        "\t\t\treturn true;",
                        "",
                        "\t\t// The pointOfRef and pointOfDecl variables contain node offsets scaled by a factor of two.",
                        "\t\t// This is done to distinguish between left and right points for the same offset.",
                        "\t\tfinal int pointOfRef = ((ASTNode) node).getOffset() * 2;",
                        "\t\tASTNode nd = null;",
                        "\t\twhile (obj instanceof ICPPSpecialization) {",
                        "\t\t\tobj = ((ICPPSpecialization) obj).getSpecializedBinding();",
                        "\t\t}",
                        "",
                        "\t\tint pointOfDecl = -1;",
                        "\t\tif (obj instanceof ICPPInternalBinding) {",
                        "\t\t\tICPPInternalBinding cpp = (ICPPInternalBinding) obj;",
                        "\t\t\tIASTNode[] n = cpp.getDeclarations();",
                        "\t\t\tif (n != null && n.length > 0) {",
                        "\t\t\t\tnd = (ASTNode) n[0];",
                        "\t\t\t}",
                        "\t\t\tASTNode def = (ASTNode) cpp.getDefinition();",
                        "\t\t\tif (def != null && (nd == null || def.getOffset() < nd.getOffset())) {",
                        "\t\t\t\tnd = def;",
                        "\t\t\t}",
                        "\t\t\tif (nd == null)",
                        "\t\t\t\treturn true;",
                        "\t\t} else {",
                        "\t\t\tif (indexBased && obj instanceof IASTName) {",
                        "\t\t\t\tIBinding b = ((IASTName) obj).getPreBinding();",
                        "\t\t\t\tif (b instanceof ICPPInternalBinding) {",
                        "\t\t\t\t\tif (acceptDeclaredAfter((ICPPInternalBinding) b))",
                        "\t\t\t\t\t\treturn true;",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t\tif (obj instanceof ASTNode) {",
                        "\t\t\t\tnd = (ASTNode) obj;",
                        "\t\t\t} else if (obj instanceof ICPPUsingDirective) {",
                        "\t\t\t\tpointOfDecl = ((ICPPUsingDirective) obj).getPointOfDeclaration() * 2;",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\tif (pointOfDecl < 0) {",
                        "\t\t\tif (nd != null) {",
                        "\t\t\t\tpointOfDecl = getPointOfDeclaration(nd);",
                        "\t\t\t} else if (obj instanceof IIndexBinding && !isUsingPromiscuousBindingResolution()) {",
                        "\t\t\t\tIIndexBinding indexBinding = (IIndexBinding) obj;",
                        "\t\t\t\tif (indexBinding instanceof ICPPMethod && ((ICPPMethod) indexBinding).isImplicit()) {",
                        "\t\t\t\t\treturn true;",
                        "\t\t\t\t}",
                        "\t\t\t\tIASTTranslationUnit tu = node.getTranslationUnit();",
                        "\t\t\t\tIIndexFileSet indexFileSet = tu.getIndexFileSet();",
                        "\t\t\t\treturn (indexFileSet != null && indexFileSet.containsDeclaration(indexBinding));",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\treturn pointOfDecl < pointOfRef;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Returns the point of declaration for the given AST node. The point of declaration is a node offset",
                        "\t * scaled by a factor of two. This is done to distinguish between left and right points for the offset.",
                        "\t */",
                        "\tprivate static int getPointOfDeclaration(ASTNode nd) {",
                        "\t\tASTNodeProperty prop = nd.getPropertyInParent();",
                        "\t\tif (prop == IASTDeclarator.DECLARATOR_NAME || nd instanceof IASTDeclarator) {",
                        "\t\t\t// Point of declaration for a name is immediately after its complete declarator",
                        "\t\t\t// and before its initializer.",
                        "\t\t\tIASTDeclarator dtor = (IASTDeclarator) ((nd instanceof IASTDeclarator) ? nd : nd.getParent());",
                        "\t\t\twhile (dtor.getParent() instanceof IASTDeclarator) {",
                        "\t\t\t\tdtor = (IASTDeclarator) dtor.getParent();",
                        "\t\t\t}",
                        "\t\t\tIASTInitializer init = dtor.getInitializer();",
                        "\t\t\t// [basic.scope.pdecl]/p9: The point of declaration for a template parameter",
                        "\t\t\t// is immediately after its complete template-parameter.",
                        "\t\t\t// Note: can't just check \"dtor.getParent() instanceof ICPPASTTemplateParameter\"",
                        "\t\t\t// because function parameter declarations implement ICPPASTTemplateParameter too.",
                        "\t\t\tboolean isTemplateParameter = dtor.getParent() instanceof ICPPASTTemplateParameter",
                        "\t\t\t\t\t&& dtor.getParent().getPropertyInParent() == ICPPASTTemplateDeclaration.PARAMETER;",
                        "\t\t\tif (init != null && !isTemplateParameter) {",
                        "\t\t\t\treturn ((ASTNode) init).getOffset() * 2 - 1;",
                        "\t\t\t} else {",
                        "\t\t\t\treturn (((ASTNode) dtor).getOffset() + ((ASTNode) dtor).getLength()) * 2 - 1;",
                        "\t\t\t}",
                        "\t\t} else if (prop == IASTEnumerator.ENUMERATOR_NAME) {",
                        "\t\t\t// Point of declaration for an enumerator is immediately after it",
                        "\t\t\t// enumerator-definition",
                        "\t\t\tIASTEnumerator enumtor = (IASTEnumerator) nd.getParent();",
                        "\t\t\tif (enumtor.getValue() != null) {",
                        "\t\t\t\tASTNode exp = (ASTNode) enumtor.getValue();",
                        "\t\t\t\treturn (exp.getOffset() + exp.getLength()) * 2 - 1;",
                        "\t\t\t} else {",
                        "\t\t\t\treturn (nd.getOffset() + nd.getLength()) * 2 - 1;",
                        "\t\t\t}",
                        "\t\t} else if (prop == ICPPASTUsingDeclaration.NAME) {",
                        "\t\t\tnd = (ASTNode) nd.getParent();",
                        "\t\t\treturn nd.getOffset() * 2;",
                        "\t\t} else if (prop == ICPPASTNamespaceAlias.ALIAS_NAME) {",
                        "\t\t\tnd = (ASTNode) nd.getParent();",
                        "\t\t\treturn (nd.getOffset() + nd.getLength()) * 2 - 1;",
                        "\t\t} else if (prop == ICPPASTAliasDeclaration.ALIAS_NAME) {",
                        "\t\t\t// [basic.scope.pdecl]/p3: The point of declaration of an alias or alias template",
                        "\t\t\t// immediately follows the type-id to which the alias refers.",
                        "\t\t\tASTNode targetType = (ASTNode) ((ICPPASTAliasDeclaration) nd.getParent()).getMappingTypeId();",
                        "\t\t\treturn (targetType.getOffset() + targetType.getLength()) * 2 - 1;",
                        "\t\t} else if (prop == ICPPASTSimpleTypeTemplateParameter.PARAMETER_NAME",
                        "\t\t\t\t|| prop == ICPPASTTemplatedTypeTemplateParameter.PARAMETER_NAME) {",
                        "\t\t\t// [basic.scope.pdecl]/p9: The point of declaration for a template parameter",
                        "\t\t\t// is immediately after its complete template-parameter.",
                        "\t\t\t// Type and template template parameters are handled here;",
                        "\t\t\t// non-type template parameters are handled in the DECLARATOR_NAME",
                        "\t\t\t// case above.",
                        "\t\t\tnd = (ASTNode) nd.getParent();",
                        "\t\t\treturn (nd.getOffset() + nd.getLength()) * 2 - 1;",
                        "\t\t} else {",
                        "\t\t\treturn (nd.getOffset() + nd.getLength()) * 2 - 1;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tprivate static boolean acceptDeclaredAfter(ICPPInternalBinding cpp) {",
                        "\t\ttry {",
                        "\t\t\tif (cpp instanceof ICPPNamespace || cpp instanceof ICPPFunction || cpp instanceof ICPPVariable) {",
                        "\t\t\t\tIScope scope = cpp.getScope();",
                        "\t\t\t\tif (!(scope instanceof ICPPBlockScope) && scope instanceof ICPPNamespaceScope) {",
                        "\t\t\t\t\treturn true;",
                        "\t\t\t\t}",
                        "\t\t\t} else if (cpp instanceof ICompositeType || cpp instanceof IEnumeration) {",
                        "\t\t\t\tIScope scope = cpp.getScope();",
                        "\t\t\t\tif (!(scope instanceof ICPPBlockScope) && scope instanceof ICPPNamespaceScope) {",
                        "\t\t\t\t\t// If this is not the definition, it may be found in a header. (bug 229571)",
                        "\t\t\t\t\tif (cpp.getDefinition() == null) {",
                        "\t\t\t\t\t\treturn true;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t} catch (DOMException e) {",
                        "\t\t}",
                        "\t\treturn false;",
                        "\t}",
                        "",
                        "\tprivate static IBinding resolveAmbiguities(LookupData data) throws DOMException {",
                        "\t\tif (!data.hasResults() || data.contentAssist)",
                        "\t\t\treturn null;",
                        "",
                        "\t\tfinal IASTName lookupName = data.getLookupName();",
                        "\t\tIASTNode lookupPoint = data.getLookupPoint();",
                        "\t\tfinal boolean indexBased = data.getIndex() != null;",
                        "\t\tfinal boolean checkWholeClass = lookupName == null || LookupData.checkWholeClassScope(lookupName);",
                        "\t\tObjectSet<ICPPFunction> fns = ObjectSet.emptySet();",
                        "\t\tIBinding type = null;",
                        "\t\tIBinding obj = null;",
                        "\t\tboolean ambiguous = false;",
                        "\t\tIBinding temp = null;",
                        "",
                        "\t\tfinal CPPASTTranslationUnit tu = data.getTranslationUnit();",
                        "\t\tObject[] items = (Object[]) data.foundItems;",
                        "\t\tfor (int i = 0; i < items.length && items[i] != null; i++) {",
                        "\t\t\tObject o = items[i];",
                        "\t\t\tboolean declaredBefore = data.isIgnorePointOfDeclaration() || declaredBefore(o, lookupPoint, indexBased);",
                        "\t\t\tboolean checkResolvedNamesOnly = false;",
                        "\t\t\tif (!checkWholeClass && !declaredBefore) {",
                        "\t\t\t\tif (lookupName != null && lookupName.getRoleOfName(false) != IASTNameOwner.r_reference) {",
                        "\t\t\t\t\tcheckResolvedNamesOnly = true;",
                        "\t\t\t\t\tdeclaredBefore = true;",
                        "\t\t\t\t} else {",
                        "\t\t\t\t\tcontinue;",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t\tif (o instanceof IASTName) {",
                        "\t\t\t\tIASTName on = (IASTName) o;",
                        "\t\t\t\tif (checkResolvedNamesOnly) {",
                        "\t\t\t\t\ttemp = on.getPreBinding();",
                        "\t\t\t\t} else {",
                        "\t\t\t\t\ttemp = on.resolvePreBinding();",
                        "\t\t\t\t}",
                        "\t\t\t\tif (temp == null)",
                        "\t\t\t\t\tcontinue;",
                        "\t\t\t} else if (o instanceof IBinding) {",
                        "\t\t\t\ttemp = (IBinding) o;",
                        "\t\t\t} else {",
                        "\t\t\t\tcontinue;",
                        "\t\t\t}",
                        "",
                        "\t\t\t// Select among those bindings that have been created without problems.",
                        "\t\t\tif (temp instanceof IProblemBinding) {",
                        "\t\t\t\t// If this ProblemBinding was the only binding, return it rather than",
                        "\t\t\t\t// creating a new ProblemBinding below. This way the caller potentially",
                        "\t\t\t\t// gets a more specific error than SEMANTIC_NAME_NOT_FOUND.",
                        "\t\t\t\tif (items.length == 1) {",
                        "\t\t\t\t\treturn temp;",
                        "\t\t\t\t}",
                        "\t\t\t\tcontinue;",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (!declaredBefore && !(temp instanceof ICPPMember) && !(temp instanceof IType)",
                        "\t\t\t\t\t&& !(temp instanceof IEnumerator)) {",
                        "\t\t\t\tcontinue;",
                        "\t\t\t}",
                        "",
                        "\t\t\t// Specializations are selected during instantiation.",
                        "\t\t\tif (temp instanceof ICPPPartialSpecialization)",
                        "\t\t\t\tcontinue;",
                        "\t\t\tif (temp instanceof ICPPTemplateInstance && lookupName instanceof ICPPASTTemplateId) {",
                        "\t\t\t\ttemp = ((ICPPTemplateInstance) temp).getSpecializedBinding();",
                        "\t\t\t\tif (!(temp instanceof IType))",
                        "\t\t\t\t\tcontinue;",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (temp instanceof ICPPUsingDeclaration) {",
                        "\t\t\t\tIBinding[] bindings = ((ICPPUsingDeclaration) temp).getDelegates();",
                        "\t\t\t\tmergeResults(data, bindings, false);",
                        "\t\t\t\titems = (Object[]) data.foundItems;",
                        "\t\t\t\tcontinue;",
                        "\t\t\t} else if (temp instanceof CPPCompositeBinding) {",
                        "\t\t\t\tIBinding[] bindings = ((CPPCompositeBinding) temp).getBindings();",
                        "\t\t\t\tmergeResults(data, bindings, false);",
                        "\t\t\t\titems = (Object[]) data.foundItems;",
                        "\t\t\t\tcontinue;",
                        "\t\t\t} else if (temp instanceof ICPPFunction) {",
                        "\t\t\t\tif (temp instanceof ICPPTemplateInstance) {",
                        "\t\t\t\t\ttemp = ((ICPPTemplateInstance) temp).getSpecializedBinding();",
                        "\t\t\t\t\tif (!(temp instanceof IFunction))",
                        "\t\t\t\t\t\tcontinue;",
                        "\t\t\t\t}",
                        "\t\t\t\tif (fns == ObjectSet.EMPTY_SET)",
                        "\t\t\t\t\tfns = new ObjectSet<>(2);",
                        "\t\t\t\tfns.put((ICPPFunction) temp);",
                        "\t\t\t} else if (temp instanceof IType) {",
                        "\t\t\t\tif (type == null) {",
                        "\t\t\t\t\ttype = temp;",
                        "\t\t\t\t\tambiguous = false;",
                        "\t\t\t\t} else if (!type.equals(temp)) {",
                        "\t\t\t\t\tint c = compareByRelevance(tu, type, temp);",
                        "\t\t\t\t\tif (c < 0) {",
                        "\t\t\t\t\t\ttype = temp;",
                        "\t\t\t\t\t\tambiguous = false;",
                        "\t\t\t\t\t} else if (c == 0) {",
                        "\t\t\t\t\t\tif (((IType) type).isSameType((IType) temp)) {",
                        "\t\t\t\t\t\t\tif (type instanceof ITypedef && !(temp instanceof ITypedef)) {",
                        "\t\t\t\t\t\t\t\t// Between same types prefer non-typedef.",
                        "\t\t\t\t\t\t\t\ttype = temp;",
                        "\t\t\t\t\t\t\t\tambiguous = false;",
                        "\t\t\t\t\t\t\t}",
                        "\t\t\t\t\t\t} else {",
                        "\t\t\t\t\t\t\tambiguous = true;",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t} else {",
                        "\t\t\t\tif (obj == null) {",
                        "\t\t\t\t\tobj = temp;",
                        "\t\t\t\t\tambiguous = false;",
                        "\t\t\t\t} else if (!obj.equals(temp)) {",
                        "\t\t\t\t\tif (obj instanceof ICPPNamespace && temp instanceof ICPPNamespace",
                        "\t\t\t\t\t\t\t&& SemanticUtil.isSameNamespace((ICPPNamespace) obj, (ICPPNamespace) temp)) {",
                        "\t\t\t\t\t\tcontinue;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t\tint c = compareByRelevance(tu, obj, temp);",
                        "\t\t\t\t\tif (c < 0) {",
                        "\t\t\t\t\t\tobj = temp;",
                        "\t\t\t\t\t\tambiguous = false;",
                        "\t\t\t\t\t} else if (c == 0) {",
                        "\t\t\t\t\t\tambiguous = true;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\tif (ambiguous) {",
                        "\t\t\treturn new ProblemBinding(lookupName, lookupPoint, IProblemBinding.SEMANTIC_AMBIGUOUS_LOOKUP,",
                        "\t\t\t\t\tdata.getFoundBindings());",
                        "\t\t}",
                        "",
                        "\t\tif (data.forUsingDeclaration) {",
                        "\t\t\tint cmp = -1;",
                        "\t\t\tif (obj != null) {",
                        "\t\t\t\tcmp = 1;",
                        "\t\t\t\tif (fns.size() > 0) {",
                        "\t\t\t\t\tIFunction[] fnArray = fns.keyArray(IFunction.class);",
                        "\t\t\t\t\tcmp = compareByRelevance(data, obj, fnArray);",
                        "\t\t\t\t\tif (cmp == 0) {",
                        "\t\t\t\t\t\treturn new ProblemBinding(lookupName, lookupPoint, IProblemBinding.SEMANTIC_AMBIGUOUS_LOOKUP,",
                        "\t\t\t\t\t\t\t\tdata.getFoundBindings());",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "",
                        "\t\t\tIBinding[] bindings = IBinding.EMPTY_BINDING_ARRAY;",
                        "\t\t\tif (cmp > 0) {",
                        "\t\t\t\tbindings = ArrayUtil.append(bindings, obj);",
                        "\t\t\t\tbindings = ArrayUtil.append(bindings, type);",
                        "\t\t\t} else {",
                        "\t\t\t\tbindings = ArrayUtil.append(bindings, type);",
                        "\t\t\t\tbindings = ArrayUtil.addAll(bindings, fns.keyArray());",
                        "\t\t\t}",
                        "\t\t\tbindings = ArrayUtil.trim(IBinding.class, bindings);",
                        "\t\t\tICPPUsingDeclaration composite = new CPPUsingDeclaration(lookupName, bindings);",
                        "\t\t\treturn composite;",
                        "\t\t}",
                        "",
                        "\t\tif (obj != null && type != null) {",
                        "\t\t\tif (obj instanceof ICPPNamespace) {",
                        "\t\t\t\tif (compareByRelevance(tu, type, obj) >= 0) {",
                        "\t\t\t\t\tobj = null;",
                        "\t\t\t\t}",
                        "\t\t\t} else if (!data.typesOnly && overrulesByRelevance(data, type, obj)) {",
                        "\t\t\t\tobj = null;",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\tif (data.typesOnly) {",
                        "\t\t\tif (obj instanceof ICPPNamespace)",
                        "\t\t\t\treturn obj;",
                        "",
                        "\t\t\treturn type;",
                        "\t\t}",
                        "",
                        "\t\tif (!fns.isEmpty()) {",
                        "\t\t\tfinal ICPPFunction[] fnArray = fns.keyArray(ICPPFunction.class);",
                        "\t\t\tif (type != null && overrulesByRelevance(data, type, fnArray)) {",
                        "\t\t\t\treturn type;",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (obj != null) {",
                        "\t\t\t\tint cmp = compareByRelevance(data, obj, fnArray);",
                        "\t\t\t\tif (cmp == 0) {",
                        "\t\t\t\t\treturn new ProblemBinding(lookupName, lookupPoint, IProblemBinding.SEMANTIC_AMBIGUOUS_LOOKUP,",
                        "\t\t\t\t\t\t\tdata.getFoundBindings());",
                        "\t\t\t\t}",
                        "\t\t\t\tif (cmp > 0) {",
                        "\t\t\t\t\treturn obj;",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t\treturn resolveFunction(data, fnArray, true, false);",
                        "\t\t}",
                        "",
                        "\t\tif (obj != null) {",
                        "\t\t\treturn obj;",
                        "\t\t}",
                        "\t\treturn type;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Compares two bindings for relevance in the context of an AST. AST bindings are",
                        "\t * considered more relevant than index ones since the index may be out of date,",
                        "\t * built for a different configuration, etc. Index bindings reachable through includes",
                        "\t * are more relevant than unreachable ones.",
                        "\t * @param ast",
                        "\t * @param b1",
                        "\t * @param b2",
                        "\t * @return 1 if binding <code>b1</code> is more relevant than <code>b2</code>; 0 if",
                        "\t * the two bindings have the same relevance; -1 if <code>b1</code> is less relevant than",
                        "\t * <code>b2</code>.",
                        "\t */",
                        "\tstatic int compareByRelevance(IASTTranslationUnit tu, IBinding b1, IBinding b2) {",
                        "\t\tboolean b1FromIndex = isFromIndex(b1);",
                        "\t\tboolean b2FromIndex = isFromIndex(b2);",
                        "\t\tif (b1FromIndex != b2FromIndex) {",
                        "\t\t\treturn !b1FromIndex ? 1 : -1;",
                        "\t\t} else if (b1FromIndex) {",
                        "\t\t\t// Both are from index.",
                        "\t\t\tif (tu != null) {",
                        "\t\t\t\tboolean b1Reachable = isReachableFromAst(tu, b1);",
                        "\t\t\t\tboolean b2Reachable = isReachableFromAst(tu, b2);",
                        "\t\t\t\tif (b1Reachable != b2Reachable) {",
                        "\t\t\t\t\treturn b1Reachable ? 1 : -1;",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\treturn 0;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Compares two bindings for relevance in the context of an AST. Type bindings are",
                        "\t * considered to overrule object bindings when the former is reachable but the",
                        "\t * latter is not.",
                        "\t */",
                        "\tstatic boolean overrulesByRelevance(LookupData data, IBinding type, IBinding b2) {",
                        "\t\tif (data == null)",
                        "\t\t\treturn false;",
                        "\t\tfinal CPPASTTranslationUnit tu = data.getTranslationUnit();",
                        "\t\tif (tu != null) {",
                        "\t\t\treturn !isReachableFromAst(tu, b2) && isReachableFromAst(tu, type);",
                        "\t\t}",
                        "\t\treturn false;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Compares a binding with a list of function candidates for relevance in the",
                        "\t * context of an AST. Types are considered to overrule object bindings when",
                        "\t * the former is reachable but none of the functions are.",
                        "\t */",
                        "\tstatic boolean overrulesByRelevance(LookupData data, IBinding type, IFunction[] fns) {",
                        "\t\tif (data == null)",
                        "\t\t\treturn false;",
                        "\t\tfinal CPPASTTranslationUnit tu = data.getTranslationUnit();",
                        "",
                        "\t\tfor (int i = 0; i < fns.length; i++) {",
                        "\t\t\tif (!isFromIndex(fns[i])) {",
                        "\t\t\t\treturn false; // function from ast",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\tif (!isReachableFromAst(tu, type)) {",
                        "\t\t\treturn false;",
                        "\t\t}",
                        "",
                        "\t\tfor (IFunction fn : fns) {",
                        "\t\t\tif (isReachableFromAst(tu, fn)) {",
                        "\t\t\t\treturn false; // function from ast",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\treturn true;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Compares two bindings for relevance in the context of an AST. AST bindings are",
                        "\t * considered more relevant than index ones since the index may be out of date,",
                        "\t * built for a different configuration, etc. Index bindings reachable through includes",
                        "\t * are more relevant than unreachable ones.",
                        "\t * @param ast",
                        "\t * @param b1",
                        "\t * @param b2",
                        "\t * @return 1 if binding <code>b1</code> is more relevant than <code>b2</code>; 0 if",
                        "\t * the two bindings have the same relevance; -1 if <code>b1</code> is less relevant than",
                        "\t * <code>b2</code>.",
                        "\t */",
                        "\tstatic int compareByRelevance(LookupData data, IName b1, IName b2) {",
                        "\t\tboolean b1FromIndex = (b1 instanceof IIndexName);",
                        "\t\tboolean b2FromIndex = (b2 instanceof IIndexName);",
                        "\t\tif (b1FromIndex != b2FromIndex) {",
                        "\t\t\treturn !b1FromIndex ? 1 : -1;",
                        "\t\t} else if (b1FromIndex) {",
                        "\t\t\t// Both are from index.",
                        "\t\t\tfinal CPPASTTranslationUnit tu = data.getTranslationUnit();",
                        "\t\t\tif (tu != null) {",
                        "\t\t\t\tboolean b1Reachable = isReachableFromAst(tu, b1);",
                        "\t\t\t\tboolean b2Reachable = isReachableFromAst(tu, b2);",
                        "\t\t\t\tif (b1Reachable != b2Reachable) {",
                        "\t\t\t\t\treturn b1Reachable ? 1 : -1;",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\treturn 0;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Compares a binding with a list of function candidates for relevance in the context of an AST. AST bindings are",
                        "\t * considered more relevant than index ones since the index may be out of date,",
                        "\t * built for a different configuration, etc. Index bindings reachable through includes",
                        "\t * are more relevant than unreachable ones.",
                        "\t * @return 1 if binding <code>obj</code> is more relevant than the function candidates; 0 if",
                        "\t * the they have the same relevance; -1 if <code>obj</code> is less relevant than",
                        "\t * the function candidates.",
                        "\t */",
                        "\tstatic int compareByRelevance(LookupData data, IBinding obj, IFunction[] fns) {",
                        "\t\tif (isFromIndex(obj)) {",
                        "\t\t\tfor (int i = 0; i < fns.length; i++) {",
                        "\t\t\t\tif (!isFromIndex(fns[i])) {",
                        "\t\t\t\t\treturn -1; // function from ast",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t\t// Everything is from the index",
                        "\t\t\tfinal CPPASTTranslationUnit tu = data.getTranslationUnit();",
                        "\t\t\tif (!isReachableFromAst(tu, obj)) {",
                        "\t\t\t\treturn -1; // obj not reachable",
                        "\t\t\t}",
                        "",
                        "\t\t\tfor (IFunction fn : fns) {",
                        "\t\t\t\tif (isReachableFromAst(tu, fn)) {",
                        "\t\t\t\t\treturn 0; // obj reachable, 1 function reachable",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t\treturn 1; // no function is reachable",
                        "\t\t}",
                        "",
                        "\t\t// obj is not from the index",
                        "\t\tfor (int i = 0; i < fns.length; i++) {",
                        "\t\t\tif (!isFromIndex(fns[i])) {",
                        "\t\t\t\treturn 0; // obj and function from ast",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\treturn 1; // only obj is from ast.",
                        "\t}",
                        "",
                        "\tprivate static boolean isFromIndex(IBinding binding) {",
                        "\t\tif (binding instanceof IIndexBinding) {",
                        "\t\t\treturn true;",
                        "\t\t}",
                        "\t\tif (binding instanceof ICPPSpecialization) {",
                        "\t\t\treturn ((ICPPSpecialization) binding).getSpecializedBinding() instanceof IIndexBinding;",
                        "\t\t}",
                        "\t\treturn false;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Checks if a binding is an AST binding, or is reachable from the AST through includes.",
                        "\t * The binding is assumed to belong to the AST, if it is not an {@link IIndexBinding} and not",
                        "\t * a specialization of an IIndexBinding.",
                        "\t *",
                        "\t * @param ast the ast to check",
                        "\t * @param binding the binding to check",
                        "\t * @return {@code true} if the {@code binding}> is reachable from the {@code ast}",
                        "\t */",
                        "\tprivate static boolean isReachableFromAst(IASTTranslationUnit ast, IBinding binding) {",
                        "\t\tIIndexBinding indexBinding = null;",
                        "\t\tif (binding instanceof IIndexBinding) {",
                        "\t\t\tindexBinding = (IIndexBinding) binding;",
                        "\t\t}",
                        "\t\tif (binding instanceof ICPPSpecialization) {",
                        "\t\t\tbinding = ((ICPPSpecialization) binding).getSpecializedBinding();",
                        "\t\t\tif (binding instanceof IIndexBinding) {",
                        "\t\t\t\tindexBinding = (IIndexBinding) binding;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\tif (indexBinding == null) {",
                        "\t\t\t// We don't check if the binding really belongs to the AST specified by the ast",
                        "\t\t\t// parameter assuming that the caller doesn't deal with two ASTs at a time.",
                        "\t\t\treturn true;",
                        "\t\t}",
                        "\t\tIIndexFileSet indexFileSet = ast.getIndexFileSet();",
                        "\t\tIIndexFileSet astFileSet = ast.getASTFileSet();",
                        "\t\treturn indexFileSet != null",
                        "\t\t\t\t&& (indexFileSet.containsDeclaration(indexBinding) || astFileSet.containsDeclaration(indexBinding));",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Checks if a name is an AST name, or is reachable from the AST through includes.",
                        "\t * The name is assumed to belong to the AST, if it is not an {@link IIndexName}.",
                        "\t *",
                        "\t * @param ast the ast to check",
                        "\t * @param name the name to check",
                        "\t * @return {@code true} if the {@code name}> is reachable from the {@code ast}",
                        "\t */",
                        "\tprivate static boolean isReachableFromAst(IASTTranslationUnit ast, IName name) {",
                        "\t\tif (!(name instanceof IIndexName)) {",
                        "\t\t\treturn true;",
                        "\t\t}",
                        "\t\tIIndexName indexName = (IIndexName) name;",
                        "\t\ttry {",
                        "\t\t\tIIndexFile file = indexName.getFile();",
                        "\t\t\tIIndexFileSet indexFileSet = ast.getIndexFileSet();",
                        "\t\t\treturn indexFileSet != null && indexFileSet.contains(file);",
                        "\t\t} catch (CoreException e) {",
                        "\t\t\treturn false;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tprivate static ICPPFunction[] selectByArgumentCount(LookupData data, ICPPFunction[] functions) throws DOMException {",
                        "\t\tassert data.forDeclaration() == null;",
                        "",
                        "\t\tfinal int argumentCount = data.getFunctionArgumentCount();",
                        "\t\tfinal int packExpansionCount = data.getFunctionArgumentPackExpansionCount();",
                        "",
                        "\t\t// Trim the list down to the set of viable functions",
                        "\t\tICPPFunction[] result = new ICPPFunction[functions.length];",
                        "\t\tint idx = 0;",
                        "\t\tfor (ICPPFunction fn : functions) {",
                        "\t\t\tif (fn != null && !(fn instanceof IProblemBinding)) {",
                        "\t\t\t\tif (fn instanceof ICPPUnknownBinding) {",
                        "\t\t\t\t\treturn new ICPPFunction[] { fn };",
                        "\t\t\t\t}",
                        "",
                        "\t\t\t\t// The index is optimized to provide the function type, try not to use the parameters",
                        "\t\t\t\t// as long as possible.",
                        "\t\t\t\tfinal ICPPFunctionType ft = fn.getType();",
                        "\t\t\t\tfinal IType[] parameterTypes = ft.getParameterTypes();",
                        "\t\t\t\tint numPars = parameterTypes.length;",
                        "\t\t\t\tif (numPars == 1 && SemanticUtil.isVoidType(parameterTypes[0]))",
                        "\t\t\t\t\tnumPars = 0;",
                        "",
                        "\t\t\t\tint numArgs = argumentCount;",
                        "\t\t\t\tif (fn instanceof ICPPMethod && data.argsContainImpliedObject)",
                        "\t\t\t\t\tnumArgs--;",
                        "",
                        "\t\t\t\tboolean ok;",
                        "\t\t\t\tif (numArgs - packExpansionCount > numPars) {",
                        "\t\t\t\t\t// More arguments than parameters --> need ellipsis or parameter pack",
                        "\t\t\t\t\tok = fn.takesVarArgs() || fn.hasParameterPack();",
                        "\t\t\t\t} else {",
                        "\t\t\t\t\tok = numArgs >= fn.getRequiredArgumentCount() || packExpansionCount > 0;",
                        "\t\t\t\t}",
                        "\t\t\t\tif (ok) {",
                        "\t\t\t\t\tif (fn instanceof IIndexBinding) {",
                        "\t\t\t\t\t\tfor (ICPPFunction other : result) {",
                        "\t\t\t\t\t\t\tif (other == null || other instanceof IIndexBinding)",
                        "\t\t\t\t\t\t\t\tbreak;",
                        "\t\t\t\t\t\t\tif (other.getType().isSameType(ft)) {",
                        "\t\t\t\t\t\t\t\tok = false;",
                        "\t\t\t\t\t\t\t\tbreak;",
                        "\t\t\t\t\t\t\t}",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t}",
                        "\t\t\t\t\tif (ok) {",
                        "\t\t\t\t\t\tresult[idx++] = fn;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\treturn result;",
                        "\t}",
                        "",
                        "\tpublic static IBinding resolveFunction(LookupData data, ICPPFunction[] fns, boolean allowUDC,",
                        "\t\t\tboolean resolveTargetedArgumentTypes) throws DOMException {",
                        "\t\tfinal IASTName lookupName = data.getLookupName();",
                        "\t\tif (fns == null || fns.length == 0 || fns[0] == null)",
                        "\t\t\treturn null;",
                        "\t\tfns = ArrayUtil.trim(fns);",
                        "",
                        "\t\tsortAstBeforeIndex(fns);",
                        "",
                        "\t\tif (data.forUsingDeclaration)",
                        "\t\t\treturn new CPPUsingDeclaration(lookupName, fns);",
                        "",
                        "\t\tif (lookupName instanceof ICPPASTConversionName) {",
                        "\t\t\treturn resolveUserDefinedConversion(data, fns);",
                        "\t\t}",
                        "",
                        "\t\tif (data.forDeclaration() != null) {",
                        "\t\t\treturn resolveFunctionDeclaration(data, fns);",
                        "\t\t}",
                        "",
                        "\t\t// No arguments to resolve function",
                        "\t\tfinal IASTNode lookupPoint = data.getLookupPoint();",
                        "\t\tif (!data.hasFunctionArguments()) {",
                        "\t\t\treturn createFunctionSet(fns, data.getTemplateArguments(), lookupName);",
                        "\t\t}",
                        "",
                        "\t\t// Reduce our set of candidate functions to only those who have the right number of parameters.",
                        "\t\tfinal IType[] argTypes = data.getFunctionArgumentTypes();",
                        "\t\tICPPFunction[] tmp = selectByArgumentCount(data, fns);",
                        "\t\tif (tmp.length == 0 || tmp[0] == null)",
                        "\t\t\treturn new ProblemBinding(lookupName, lookupPoint, IProblemBinding.SEMANTIC_NAME_NOT_FOUND, fns);",
                        "\t\ttmp = CPPTemplates.instantiateForFunctionCall(tmp, data.getTemplateArguments(), Arrays.asList(argTypes),",
                        "\t\t\t\tArrays.asList(data.getFunctionArgumentValueCategories()), data.argsContainImpliedObject);",
                        "\t\tif (tmp.length == 0 || tmp[0] == null)",
                        "\t\t\treturn new ProblemBinding(lookupName, lookupPoint, IProblemBinding.SEMANTIC_NAME_NOT_FOUND, fns);",
                        "",
                        "\t\tint viableCount = 0;",
                        "\t\tfor (IFunction f : tmp) {",
                        "\t\t\tif (f instanceof ICPPUnknownBinding) {",
                        "\t\t\t\tsetTargetedFunctionsToUnknown(argTypes);",
                        "\t\t\t\treturn f;",
                        "\t\t\t}",
                        "\t\t\tif (f == null)",
                        "\t\t\t\tbreak;",
                        "\t\t\t++viableCount;",
                        "\t\t}",
                        "\t\tif (viableCount == 0)",
                        "\t\t\treturn new ProblemBinding(lookupName, lookupPoint, IProblemBinding.SEMANTIC_NAME_NOT_FOUND, fns);",
                        "",
                        "\t\t// Check for dependent arguments",
                        "\t\tfns = tmp;",
                        "\t\tif (CPPTemplates.containsDependentType(argTypes)) {",
                        "\t\t\tsetTargetedFunctionsToUnknown(argTypes);",
                        "\t\t\treturn CPPDeferredFunction.createForCandidates(fns);",
                        "\t\t}",
                        "",
                        "\t\tIFunction[] ambiguousFunctions = null; // Ambiguity, two or more functions are equally good.",
                        "\t\tFunctionCost bestFnCost = null; // The cost of the best function.",
                        "",
                        "\t\t// Loop over all functions",
                        "\t\tList<FunctionCost> potentialCosts = null;",
                        "\t\tICPPFunction unknownFunction = null;",
                        "\t\tfinal CPPASTTranslationUnit tu = data.getTranslationUnit();",
                        "\t\tfor (ICPPFunction fn : fns) {",
                        "\t\t\tif (fn == null)",
                        "\t\t\t\tcontinue;",
                        "",
                        "\t\t\tUDCMode udc = allowUDC ? UDCMode.DEFER : UDCMode.FORBIDDEN;",
                        "\t\t\tFunctionCost fnCost = costForFunctionCall(fn, udc, data, resolveTargetedArgumentTypes);",
                        "\t\t\tif (fnCost == null)",
                        "\t\t\t\tcontinue;",
                        "",
                        "\t\t\tif (fnCost == CONTAINS_DEPENDENT_TYPES) {",
                        "\t\t\t\tif (viableCount == 1)",
                        "\t\t\t\t\treturn fn;",
                        "\t\t\t\tunknownFunction = fn;",
                        "\t\t\t\tcontinue;",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (fnCost.hasDeferredUDC()) {",
                        "\t\t\t\tif (potentialCosts == null) {",
                        "\t\t\t\t\tpotentialCosts = new ArrayList<>();",
                        "\t\t\t\t}",
                        "\t\t\t\tpotentialCosts.add(fnCost);",
                        "\t\t\t\tcontinue;",
                        "\t\t\t}"
                    ]
                },
                {
                    "a": [
                        "\t\t\tint cmp = fnCost.compareTo(tu, bestFnCost);"
                    ],
                    "b": [
                        "\t\t\tint cmp = fnCost.compareTo(tu, bestFnCost, data);"
                    ]
                },
                {
                    "ab": [
                        "\t\t\tif (cmp < 0) {",
                        "\t\t\t\tbestFnCost = fnCost;",
                        "\t\t\t\tambiguousFunctions = null;",
                        "\t\t\t} else if (cmp == 0) {",
                        "\t\t\t\tambiguousFunctions = ArrayUtil.append(IFunction.class, ambiguousFunctions, fn);",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\tif (potentialCosts != null) {",
                        "\t\t\tfor (FunctionCost fnCost : potentialCosts) {",
                        "\t\t\t\tif (!fnCost.mustBeWorse(bestFnCost) && fnCost.performUDC()) {"
                    ]
                },
                {
                    "a": [
                        "\t\t\t\t\tint cmp = fnCost.compareTo(tu, bestFnCost);"
                    ],
                    "b": [
                        "\t\t\t\t\tint cmp = fnCost.compareTo(tu, bestFnCost, data);"
                    ]
                },
                {
                    "ab": [
                        "\t\t\t\t\tif (cmp < 0) {",
                        "\t\t\t\t\t\tbestFnCost = fnCost;",
                        "\t\t\t\t\t\tambiguousFunctions = null;",
                        "\t\t\t\t\t} else if (cmp == 0) {",
                        "\t\t\t\t\t\tambiguousFunctions = ArrayUtil.append(IFunction.class, ambiguousFunctions,",
                        "\t\t\t\t\t\t\t\tfnCost.getFunction());",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\tif (bestFnCost == null) {",
                        "\t\t\tif (unknownFunction == null)",
                        "\t\t\t\treturn null;",
                        "",
                        "\t\t\tsetTargetedFunctionsToUnknown(argTypes);",
                        "\t\t\treturn CPPDeferredFunction.createForCandidates(fns);",
                        "\t\t}",
                        "",
                        "\t\tif (ambiguousFunctions != null) {",
                        "\t\t\tambiguousFunctions = ArrayUtil.append(IFunction.class, ambiguousFunctions, bestFnCost.getFunction());",
                        "\t\t\treturn new ProblemBinding(lookupName, lookupPoint, IProblemBinding.SEMANTIC_AMBIGUOUS_LOOKUP,",
                        "\t\t\t\t\tambiguousFunctions);",
                        "\t\t}",
                        "\t\tif (bestFnCost.hasAmbiguousUserDefinedConversion()) {",
                        "\t\t\treturn new ProblemBinding(lookupName, lookupPoint, IProblemBinding.SEMANTIC_AMBIGUOUS_LOOKUP,",
                        "\t\t\t\t\tdata.getFoundBindings());",
                        "\t\t}",
                        "",
                        "\t\tfor (int i = 0; i < argTypes.length; i++) {",
                        "\t\t\tIType iType = argTypes[i];",
                        "\t\t\tif (iType instanceof FunctionSetType) {",
                        "\t\t\t\t((FunctionSetType) iType).applySelectedFunction(bestFnCost.getCost(i).getSelectedFunction());",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\tIFunction result = bestFnCost.getFunction();",
                        "\t\tif (bestFnCost.isDirectInitWithCopyCtor()) {",
                        "\t\t\tCost c0 = bestFnCost.getCost(0);",
                        "\t\t\tIFunction firstConversion = c0.getUserDefinedConversion();",
                        "\t\t\tif (firstConversion instanceof ICPPConstructor)",
                        "\t\t\t\treturn firstConversion;",
                        "\t\t}",
                        "\t\treturn result;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * If {@code type} is a {@link FunctionSetType} or a pointer type containing a FunctionSetType,",
                        "\t * resolves the FunctionSetType using the given target type.",
                        "\t *",
                        "\t * @param type the type to resolve",
                        "\t * @param targetType the target type",
                        "\t * @param point the name lookup context",
                        "\t * @return the resolved type, or the given {@type} if the type didn't contain a FunctionSetType",
                        "\t *     or the targeted function resolution failed",
                        "\t */",
                        "\tprivate static IType resolveTargetedFunctionSetType(IType type, IType targetType) {",
                        "\t\tIType t = type;",
                        "\t\tif (type instanceof IPointerType) {",
                        "\t\t\tt = ((IPointerType) type).getType();",
                        "\t\t}",
                        "",
                        "\t\tif (t instanceof FunctionSetType) {",
                        "\t\t\tICPPFunction function = resolveTargetedFunction(targetType, ((FunctionSetType) t).getFunctionSet());",
                        "\t\t\tif (function != null && !(function instanceof IProblemBinding)) {",
                        "\t\t\t\ttype = function.getType();",
                        "\t\t\t\tif (targetType instanceof ITypeContainer) {",
                        "\t\t\t\t\tITypeContainer containerType = (ITypeContainer) targetType.clone();",
                        "\t\t\t\t\tcontainerType.setType(type);",
                        "\t\t\t\t\ttype = containerType;",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\treturn type;",
                        "\t}",
                        "",
                        "\tprivate static IBinding createFunctionSet(ICPPFunction[] fns, ICPPTemplateArgument[] args, IASTName name) {",
                        "\t\t// First try to find a unique function",
                        "\t\tif (name != null && name.getPropertyInParent() == ICPPASTTemplateId.TEMPLATE_NAME) {",
                        "\t\t\tname = (IASTName) name.getParent();",
                        "\t\t}",
                        "\t\tICPPFunction f = getUniqueFunctionForSet(fns, args);",
                        "\t\treturn f == null ? new CPPFunctionSet(fns, args, name) : f;",
                        "\t}",
                        "",
                        "\tprivate static ICPPFunction getUniqueFunctionForSet(ICPPFunction[] fns, ICPPTemplateArgument[] args) {",
                        "\t\t// First try to find a unique function",
                        "\t\tICPPFunction result = null;",
                        "\t\tboolean haveASTResult = false;",
                        "\t\tfor (ICPPFunction f : fns) {",
                        "\t\t\t// Use the ast binding",
                        "\t\t\tfinal boolean fromIndex = isFromIndex(f);",
                        "\t\t\tif (haveASTResult && fromIndex)",
                        "\t\t\t\tbreak;",
                        "",
                        "\t\t\tboolean isCandidate;",
                        "\t\t\tif (f instanceof ICPPFunctionTemplate) {",
                        "\t\t\t\tif (args == null) {",
                        "\t\t\t\t\tisCandidate = true;",
                        "\t\t\t\t} else {",
                        "\t\t\t\t\t// See 14.3-7",
                        "\t\t\t\t\tICPPFunctionTemplate funcTemp = (ICPPFunctionTemplate) f;",
                        "\t\t\t\t\tfinal ICPPTemplateParameter[] tpars = funcTemp.getTemplateParameters();",
                        "\t\t\t\t\tfinal CPPTemplateParameterMap map = new CPPTemplateParameterMap(tpars.length);",
                        "\t\t\t\t\tif (!TemplateArgumentDeduction.addExplicitArguments(funcTemp, tpars, args, map)) {",
                        "\t\t\t\t\t\tisCandidate = false;",
                        "\t\t\t\t\t} else {",
                        "\t\t\t\t\t\tf = CPPTemplates.instantiateForAddressOfFunction(funcTemp, null, args);",
                        "\t\t\t\t\t\tisCandidate = f != null;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t} else {",
                        "\t\t\t\tisCandidate = args == null;",
                        "\t\t\t}",
                        "\t\t\tif (isCandidate) {",
                        "\t\t\t\tif (result != null)",
                        "\t\t\t\t\treturn null;",
                        "\t\t\t\tresult = f;",
                        "\t\t\t\thaveASTResult = !fromIndex;",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\tif (result instanceof ICPPFunctionTemplate)",
                        "\t\t\treturn CPPTemplates.instantiateForAddressOfFunction((ICPPFunctionTemplate) result, null, args);",
                        "",
                        "\t\treturn result;",
                        "\t}",
                        "",
                        "\tprivate static void setTargetedFunctionsToUnknown(IType[] argTypes) {",
                        "\t\tfor (IType argType : argTypes) {",
                        "\t\t\tif (argType instanceof FunctionSetType) {",
                        "\t\t\t\t((FunctionSetType) argType).setToUnknown();",
                        "\t\t\t}",
                        "\t\t}",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Called for declarations with qualified name or template-id. Also for explicit function",
                        "\t * specializations or instantiations.",
                        "\t */",
                        "\tprivate static IBinding resolveFunctionDeclaration(LookupData data, ICPPFunction[] fns) throws DOMException {",
                        "\t\tfinal IASTDeclarator dtor = ASTQueries.findTypeRelevantDeclarator(data.getDeclarator());",
                        "\t\tfinal IType t = CPPVisitor.createType(dtor);",
                        "\t\tif (!(t instanceof ICPPFunctionType))",
                        "\t\t\treturn null;",
                        "",
                        "\t\tfinal ICPPFunctionType ft = (ICPPFunctionType) t;",
                        "",
                        "\t\tIASTName templateID = data.getLookupName();",
                        "\t\tif (templateID.getPropertyInParent() == ICPPASTTemplateId.TEMPLATE_NAME) {",
                        "\t\t\ttemplateID = (ICPPASTTemplateId) templateID.getParent();",
                        "\t\t}",
                        "",
                        "\t\t// 14.5.4 Friends with template ids require instantiation",
                        "\t\tboolean isFriend = CPPVisitor.isFriendDeclaration(data.forDeclaration());",
                        "\t\tif (!data.forExplicitFunctionSpecialization() && !(isFriend && templateID instanceof ICPPASTTemplateId)) {",
                        "\t\t\t// Search for a matching function",
                        "\t\t\tfor (ICPPFunction fn : fns) {",
                        "\t\t\t\tif (fn != null && !(fn instanceof IProblemBinding) && !(fn instanceof ICPPUnknownBinding)) {",
                        "\t\t\t\t\tif (isSameFunction(fn, dtor)) {",
                        "\t\t\t\t\t\treturn fn;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t\t// 14.5.4 Friends with qualified ids allow for instantiation",
                        "\t\t\tif (!data.forExplicitFunctionInstantiation()",
                        "\t\t\t\t\t&& !(isFriend && templateID.getParent() instanceof ICPPASTQualifiedName)) {",
                        "\t\t\t\treturn null;",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\t// Try to instantiate a template",
                        "\t\tIASTTranslationUnit tu = data.getTranslationUnit();",
                        "\t\tICPPTemplateArgument[] tmplArgs = ICPPTemplateArgument.EMPTY_ARGUMENTS;",
                        "\t\tif (templateID instanceof ICPPASTTemplateId) {",
                        "\t\t\ttmplArgs = CPPTemplates.createTemplateArgumentArray((ICPPASTTemplateId) templateID);",
                        "\t\t}",
                        "",
                        "\t\tICPPFunctionTemplate bestTemplate = null;",
                        "\t\tICPPFunction bestInst = null;",
                        "\t\tboolean isAmbiguous = false;",
                        "\t\tfor (ICPPFunction fn : fns) {",
                        "\t\t\tif (fn instanceof ICPPFunctionTemplate && !(fn instanceof IProblemBinding)",
                        "\t\t\t\t\t&& !(fn instanceof ICPPUnknownBinding)) {",
                        "\t\t\t\t// If the declared function type is dependent, there is no point trying to use it",
                        "\t\t\t\t// to instantiate the template, so return a deferred function instead.",
                        "\t\t\t\t// Note that CPPTemplates.instantiateForFunctionCall() behaves similarly.",
                        "\t\t\t\tif (CPPTemplates.isDependentType(ft)) {",
                        "\t\t\t\t\treturn CPPDeferredFunction.createForCandidates(fns);",
                        "\t\t\t\t}",
                        "\t\t\t\tICPPFunctionTemplate template = (ICPPFunctionTemplate) fn;",
                        "\t\t\t\tICPPFunction inst = CPPTemplates.instantiateForFunctionDeclaration(template, tmplArgs, ft);",
                        "\t\t\t\tif (inst != null) {",
                        "\t\t\t\t\tint cmp = CPPTemplates.orderFunctionTemplates(bestTemplate, template,",
                        "\t\t\t\t\t\t\tTypeSelection.PARAMETERS_AND_RETURN_TYPE);",
                        "\t\t\t\t\tif (cmp == 0)",
                        "\t\t\t\t\t\tcmp = compareByRelevance(tu, bestTemplate, template);",
                        "",
                        "\t\t\t\t\tif (cmp == 0)",
                        "\t\t\t\t\t\tisAmbiguous = true;",
                        "",
                        "\t\t\t\t\tif (cmp < 0) {",
                        "\t\t\t\t\t\tisAmbiguous = false;",
                        "\t\t\t\t\t\tbestTemplate = template;",
                        "\t\t\t\t\t\tbestInst = inst;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\tif (isAmbiguous)",
                        "\t\t\treturn new ProblemBinding(data.getLookupName(), data.getLookupPoint(),",
                        "\t\t\t\t\tIProblemBinding.SEMANTIC_AMBIGUOUS_LOOKUP, fns);",
                        "",
                        "\t\treturn bestInst;",
                        "\t}",
                        "",
                        "\tpublic static void sortAstBeforeIndex(IFunction[] fns) {",
                        "\t\tint iast = 0;",
                        "\t\tfor (int i = 0; i < fns.length; i++) {",
                        "\t\t\tIFunction fn = fns[i];",
                        "\t\t\tif (!(fn instanceof IIndexBinding)) {",
                        "\t\t\t\tif (iast != i) {",
                        "\t\t\t\t\tfns[i] = fns[iast];",
                        "\t\t\t\t\tfns[iast] = fn;",
                        "\t\t\t\t}",
                        "\t\t\t\tiast++;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tprivate static FunctionCost costForFunctionCall(ICPPFunction fn, UDCMode udc, LookupData data,",
                        "\t\t\tboolean resolveTargetedArgumentTypes) throws DOMException {",
                        "\t\tfinal ICPPFunctionType ftype = fn.getType();",
                        "\t\tif (ftype == null)",
                        "\t\t\treturn null;",
                        "",
                        "\t\tIType[] argTypes = data.getFunctionArgumentTypes();",
                        "\t\tValueCategory[] argValueCategories = data.getFunctionArgumentValueCategories();",
                        "\t\tif (resolveTargetedArgumentTypes) {",
                        "\t\t\tIType[] newArgTypes = null;",
                        "\t\t\tIType[] paramTypes = fn.getType().getParameterTypes();",
                        "\t\t\tfor (int i = 0; i < argTypes.length && i < paramTypes.length; i++) {",
                        "\t\t\t\tIType argType = argTypes[i];",
                        "\t\t\t\tIType paramType = paramTypes[i];",
                        "\t\t\t\tIType newArgType = resolveTargetedFunctionSetType(argType, paramType);",
                        "\t\t\t\tif (newArgType != argType) {",
                        "\t\t\t\t\tif (newArgTypes == null) {",
                        "\t\t\t\t\t\tnewArgTypes = new IType[argTypes.length];",
                        "\t\t\t\t\t\tSystem.arraycopy(argTypes, 0, newArgTypes, 0, argTypes.length);",
                        "\t\t\t\t\t}",
                        "\t\t\t\t\tnewArgTypes[i] = newArgType;",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t\tif (newArgTypes != null) {",
                        "\t\t\t\targTypes = newArgTypes;",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\tint skipArg = 0;",
                        "\t\tIType implicitParameterType = null;",
                        "\t\tIType impliedObjectType = null;",
                        "\t\tValueCategory impliedObjectValueCategory = null;",
                        "\t\tfinal IType[] paramTypes = ftype.getParameterTypes();",
                        "\t\tif (fn instanceof ICPPMethod && !(fn instanceof ICPPConstructor)) {",
                        "\t\t\timplicitParameterType = getImplicitParameterType((ICPPMethod) fn);",
                        "\t\t\tif (data.argsContainImpliedObject) {",
                        "\t\t\t\timpliedObjectType = argTypes[0];",
                        "\t\t\t\timpliedObjectValueCategory = argValueCategories[0];",
                        "\t\t\t\tskipArg = 1;",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\tint k = 0;",
                        "\t\tCost cost;",
                        "\t\tfinal int sourceLen = argTypes.length - skipArg;",
                        "\t\tfinal FunctionCost result;",
                        "\t\tif (implicitParameterType == null) {",
                        "\t\t\tresult = new FunctionCost(fn, sourceLen);",
                        "\t\t} else {",
                        "\t\t\tresult = new FunctionCost(fn, sourceLen + 1);",
                        "",
                        "\t\t\tif (impliedObjectType == null) {",
                        "\t\t\t\timpliedObjectType = data.getImpliedObjectType();",
                        "\t\t\t}",
                        "\t\t\tif (impliedObjectValueCategory == null) {",
                        "\t\t\t\timpliedObjectValueCategory = data.getImpliedObjectValueCategory();",
                        "\t\t\t\tif (impliedObjectValueCategory == null)",
                        "\t\t\t\t\timpliedObjectValueCategory = ValueCategory.LVALUE;",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (fn instanceof ICPPMethod && (((ICPPMethod) fn).isDestructor() || ASTInternal.isStatic(fn, false))) {",
                        "\t\t\t\t// 13.3.1-4 for static member functions, the implicit object parameter always matches, no cost",
                        "\t\t\t\tcost = new Cost(impliedObjectType, implicitParameterType, Rank.IDENTITY);",
                        "\t\t\t\tcost.setImpliedObject();",
                        "\t\t\t} else if (impliedObjectType == null) {",
                        "\t\t\t\treturn null;",
                        "\t\t\t} else if (impliedObjectType.isSameType(implicitParameterType)) {",
                        "\t\t\t\tcost = new Cost(impliedObjectType, implicitParameterType, Rank.IDENTITY);",
                        "\t\t\t\tcost.setImpliedObject();",
                        "\t\t\t} else {",
                        "\t\t\t\tContext context = ftype.hasRefQualifier() ? Context.IMPLICIT_OBJECT_FOR_METHOD_WITH_REF_QUALIFIER",
                        "\t\t\t\t\t\t: Context.IMPLICIT_OBJECT_FOR_METHOD_WITHOUT_REF_QUALIFIER;",
                        "\t\t\t\tcost = Conversions.checkImplicitConversionSequence(implicitParameterType, impliedObjectType,",
                        "\t\t\t\t\t\timpliedObjectValueCategory, UDCMode.FORBIDDEN, context);",
                        "\t\t\t\tif (cost.converts()) {",
                        "\t\t\t\t\tcost.setImpliedObject();",
                        "\t\t\t\t} else {",
                        "\t\t\t\t\tif (CPPTemplates.isDependentType(implicitParameterType)",
                        "\t\t\t\t\t\t\t|| CPPTemplates.isDependentType(impliedObjectType)) {",
                        "\t\t\t\t\t\tIType s = getNestedType(impliedObjectType, TDEF | REF | CVTYPE);",
                        "\t\t\t\t\t\tIType t = getNestedType(implicitParameterType, TDEF | REF | CVTYPE);",
                        "\t\t\t\t\t\tif (SemanticUtil.calculateInheritanceDepth(s, t) >= 0)",
                        "\t\t\t\t\t\t\treturn null;",
                        "",
                        "\t\t\t\t\t\treturn CONTAINS_DEPENDENT_TYPES;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t\tif (!cost.converts())",
                        "\t\t\t\treturn null;",
                        "",
                        "\t\t\tresult.setCost(k++, cost, impliedObjectValueCategory);",
                        "\t\t}",
                        "",
                        "\t\tfor (int j = 0; j < sourceLen; j++) {",
                        "\t\t\tfinal IType argType = SemanticUtil.getNestedType(argTypes[j + skipArg], TDEF | REF);",
                        "\t\t\tif (argType == null)",
                        "\t\t\t\treturn null;",
                        "",
                        "\t\t\tfinal ValueCategory argValueCategory = argValueCategories[j + skipArg];",
                        "",
                        "\t\t\tIType paramType;",
                        "\t\t\tif (j < paramTypes.length) {",
                        "\t\t\t\tparamType = getNestedType(paramTypes[j], TDEF);",
                        "\t\t\t} else if (!fn.takesVarArgs()) {",
                        "\t\t\t\tparamType = VOID_TYPE;",
                        "\t\t\t} else {",
                        "\t\t\t\tcost = new Cost(argType, null, Rank.ELLIPSIS_CONVERSION);",
                        "\t\t\t\tresult.setCost(k++, cost, argValueCategory);",
                        "\t\t\t\tcontinue;",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (argType instanceof FunctionSetType) {",
                        "\t\t\t\tcost = ((FunctionSetType) argType).costForTarget(paramType);",
                        "\t\t\t} else if (argType.isSameType(paramType)) {",
                        "\t\t\t\tcost = new Cost(argType, paramType, Rank.IDENTITY);",
                        "\t\t\t} else {",
                        "\t\t\t\tif (CPPTemplates.isDependentType(paramType))",
                        "\t\t\t\t\treturn CONTAINS_DEPENDENT_TYPES;",
                        "",
                        "\t\t\t\tContext ctx = Context.ORDINARY;",
                        "\t\t\t\tif (j == 0 && sourceLen == 1 && fn instanceof ICPPConstructor) {",
                        "\t\t\t\t\tif (paramType instanceof ICPPReferenceType) {",
                        "\t\t\t\t\t\tif (((ICPPConstructor) fn).getClassOwner()",
                        "\t\t\t\t\t\t\t\t.isSameType(getNestedType(paramType, TDEF | REF | CVTYPE))) {",
                        "\t\t\t\t\t\t\tctx = Context.FIRST_PARAM_OF_DIRECT_COPY_CTOR;",
                        "\t\t\t\t\t\t\tresult.setIsDirectInitWithCopyCtor(true);",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t\tcost = Conversions.checkImplicitConversionSequence(paramType, argType, argValueCategory, udc, ctx);",
                        "\t\t\t\tif (data.fNoNarrowing && cost.isNarrowingConversion()) {",
                        "\t\t\t\t\tcost = Cost.NO_CONVERSION;",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t\tif (!cost.converts())",
                        "\t\t\t\treturn null;",
                        "",
                        "\t\t\tresult.setCost(k++, cost, argValueCategory);",
                        "\t\t}",
                        "\t\treturn result;",
                        "\t}",
                        "",
                        "\tstatic IType getImplicitParameterType(ICPPMethod m) {",
                        "\t\tIType implicitType;",
                        "\t\tICPPClassType owner = m.getClassOwner();",
                        "\t\tif (owner instanceof ICPPClassTemplate) {",
                        "\t\t\towner = (ICPPClassType) ((ICPPClassTemplate) owner).asDeferredInstance();",
                        "\t\t}",
                        "\t\tICPPFunctionType ft = m.getType();",
                        "\t\timplicitType = SemanticUtil.addQualifiers(owner, ft.isConst(), ft.isVolatile(), false);",
                        "\t\treturn new CPPReferenceType(implicitType, ft.isRValueReference());",
                        "\t}",
                        "",
                        "\tprivate static IBinding resolveUserDefinedConversion(LookupData data, ICPPFunction[] fns) {",
                        "\t\tICPPASTConversionName astName = (ICPPASTConversionName) data.getLookupName();",
                        "\t\tIType t = CPPVisitor.createType(astName.getTypeId());",
                        "\t\tif (t instanceof ISemanticProblem) {",
                        "\t\t\treturn new ProblemBinding(astName, data.getLookupPoint(), IProblemBinding.SEMANTIC_INVALID_TYPE,",
                        "\t\t\t\t\tdata.getFoundBindings());",
                        "\t\t}",
                        "\t\tif (data.forDeclaration() == null || data.forExplicitFunctionSpecialization()",
                        "\t\t\t\t|| data.forExplicitFunctionInstantiation()) {",
                        "\t\t\tfns = CPPTemplates.instantiateConversionTemplates(fns, t);",
                        "\t\t}",
                        "",
                        "\t\tIFunction unknown = null;",
                        "\t\tfor (IFunction function : fns) {",
                        "\t\t\tif (function != null) {",
                        "\t\t\t\tIType t2 = function.getType().getReturnType();",
                        "\t\t\t\tif (t.isSameType(t2))",
                        "\t\t\t\t\treturn function;",
                        "\t\t\t\tif (unknown == null && function instanceof ICPPUnknownBinding) {",
                        "\t\t\t\t\tunknown = function;",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\tif (unknown != null)",
                        "\t\t\treturn unknown;",
                        "\t\treturn new ProblemBinding(astName, data.getLookupPoint(), IProblemBinding.SEMANTIC_NAME_NOT_FOUND,",
                        "\t\t\t\tdata.getFoundBindings());",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * 13.4-1 A use of an overloaded function without arguments is resolved in certain contexts to",
                        "\t * a function.",
                        "\t */",
                        "\tstatic IBinding resolveTargetedFunction(IASTName name, CPPFunctionSet functionSet) {",
                        "\t\tpushLookupPoint(name);",
                        "\t\ttry {",
                        "\t\t\tboolean addressOf = false;",
                        "\t\t\tIASTNode node = name.getParent();",
                        "\t\t\twhile (node instanceof IASTName) {",
                        "\t\t\t\tnode = node.getParent();",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (!(node instanceof IASTIdExpression))",
                        "\t\t\t\treturn new ProblemBinding(name, IProblemBinding.SEMANTIC_INVALID_OVERLOAD);",
                        "",
                        "\t\t\tASTNodeProperty prop = node.getPropertyInParent();",
                        "\t\t\tIASTNode parent = node.getParent();",
                        "\t\t\twhile (parent instanceof IASTUnaryExpression) {",
                        "\t\t\t\tfinal int op = ((IASTUnaryExpression) parent).getOperator();",
                        "\t\t\t\tif (op == IASTUnaryExpression.op_bracketedPrimary) {",
                        "\t\t\t\t} else if (!addressOf && op == IASTUnaryExpression.op_amper) {",
                        "\t\t\t\t\taddressOf = true;",
                        "\t\t\t\t} else {",
                        "\t\t\t\t\tbreak;",
                        "\t\t\t\t}",
                        "\t\t\t\tnode = parent;",
                        "\t\t\t\tprop = node.getPropertyInParent();",
                        "\t\t\t\tparent = node.getParent();",
                        "\t\t\t}",
                        "",
                        "\t\t\tIType targetType = null;",
                        "\t\t\tif (prop == IASTDeclarator.INITIALIZER) {",
                        "\t\t\t\t// Target is an object or reference being initialized",
                        "\t\t\t\tIASTDeclarator dtor = (IASTDeclarator) parent;",
                        "\t\t\t\ttargetType = CPPVisitor.createType(dtor);",
                        "\t\t\t} else if (prop == IASTEqualsInitializer.INITIALIZER) {",
                        "\t\t\t\tfinal IASTNode grandpa = parent.getParent();",
                        "\t\t\t\tif (grandpa instanceof IASTDeclarator) {",
                        "\t\t\t\t\tIASTDeclarator dtor = ASTQueries.findInnermostDeclarator((IASTDeclarator) grandpa);",
                        "\t\t\t\t\tIBinding var = dtor.getName().resolvePreBinding();",
                        "\t\t\t\t\tif (var instanceof IVariable)",
                        "\t\t\t\t\t\ttargetType = ((IVariable) var).getType();",
                        "\t\t\t\t}",
                        "\t\t\t} else if (prop == ICPPASTConstructorInitializer.ARGUMENT) {",
                        "\t\t\t\tICPPASTConstructorInitializer init = (ICPPASTConstructorInitializer) parent;",
                        "\t\t\t\tfinal IASTNode parentOfInit = init.getParent();",
                        "\t\t\t\tif (parentOfInit instanceof IASTDeclarator) {",
                        "\t\t\t\t\tIASTDeclarator dtor = (IASTDeclarator) parentOfInit;",
                        "\t\t\t\t\ttargetType = CPPVisitor.createType(dtor);",
                        "\t\t\t\t} else if (parentOfInit instanceof ICPPASTConstructorChainInitializer) {",
                        "\t\t\t\t\tICPPASTConstructorChainInitializer memInit = (ICPPASTConstructorChainInitializer) parentOfInit;",
                        "\t\t\t\t\tIBinding var = memInit.getMemberInitializerId().resolveBinding();",
                        "\t\t\t\t\tif (var instanceof IVariable) {",
                        "\t\t\t\t\t\ttargetType = ((IVariable) var).getType();",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t\ttargetType = getNestedType(targetType, TDEF | REF | CVTYPE | PTR | MPTR);",
                        "\t\t\t\tif (init.getArguments().length != 1 || !(targetType instanceof ICPPFunctionType)) {",
                        "\t\t\t\t\tif (targetType instanceof ICPPClassType) {",
                        "\t\t\t\t\t\tLookupData data = new LookupData(name);",
                        "\t\t\t\t\t\tdata.setFunctionArguments(false, init.getArguments());",
                        "\t\t\t\t\t\ttry {",
                        "\t\t\t\t\t\t\tIBinding ctor = resolveFunction(data, ((ICPPClassType) targetType).getConstructors(), true,",
                        "\t\t\t\t\t\t\t\t\tfalse);",
                        "\t\t\t\t\t\t\tif (ctor instanceof ICPPConstructor) {",
                        "\t\t\t\t\t\t\t\tint i = 0;",
                        "\t\t\t\t\t\t\t\tfor (IASTNode arg : init.getArguments()) {",
                        "\t\t\t\t\t\t\t\t\tif (arg == node) {",
                        "\t\t\t\t\t\t\t\t\t\tIType[] params = ((ICPPConstructor) ctor).getType().getParameterTypes();",
                        "\t\t\t\t\t\t\t\t\t\tif (params.length > i) {",
                        "\t\t\t\t\t\t\t\t\t\t\ttargetType = params[i];",
                        "\t\t\t\t\t\t\t\t\t\t}",
                        "\t\t\t\t\t\t\t\t\t\tbreak;",
                        "\t\t\t\t\t\t\t\t\t}",
                        "\t\t\t\t\t\t\t\t\ti++;",
                        "\t\t\t\t\t\t\t\t}",
                        "\t\t\t\t\t\t\t}",
                        "\t\t\t\t\t\t} catch (DOMException e) {",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t} else if (prop == IASTBinaryExpression.OPERAND_TWO) {",
                        "\t\t\t\tIASTBinaryExpression binaryExp = (IASTBinaryExpression) parent;",
                        "\t\t\t\tif (binaryExp.getOperator() == IASTBinaryExpression.op_assign) {",
                        "\t\t\t\t\ttargetType = binaryExp.getOperand1().getExpressionType();",
                        "\t\t\t\t}",
                        "\t\t\t} else if (prop == IASTFunctionCallExpression.ARGUMENT) {",
                        "\t\t\t\t// Target is a parameter of a function, need to resolve the function call",
                        "\t\t\t\tIASTFunctionCallExpression fnCall = (IASTFunctionCallExpression) parent;",
                        "\t\t\t\tIType t = SemanticUtil.getNestedType(fnCall.getFunctionNameExpression().getExpressionType(),",
                        "\t\t\t\t\t\tTDEF | REF | CVTYPE);",
                        "\t\t\t\tif (t instanceof IPointerType) {",
                        "\t\t\t\t\tt = SemanticUtil.getNestedType(((IPointerType) t).getType(), TDEF | REF | CVTYPE);",
                        "\t\t\t\t}",
                        "\t\t\t\tif (t instanceof IFunctionType) {",
                        "\t\t\t\t\tint i = 0;",
                        "\t\t\t\t\tfor (IASTNode arg : fnCall.getArguments()) {",
                        "\t\t\t\t\t\tif (arg == node) {",
                        "\t\t\t\t\t\t\tIType[] params = ((IFunctionType) t).getParameterTypes();",
                        "\t\t\t\t\t\t\tif (params.length > i) {",
                        "\t\t\t\t\t\t\t\ttargetType = params[i];",
                        "\t\t\t\t\t\t\t}",
                        "\t\t\t\t\t\t\tbreak;",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t\ti++;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t} else if (prop == IASTCastExpression.OPERAND) {",
                        "\t\t\t\t// target is an explicit type conversion",
                        "\t\t\t\tIASTCastExpression cast = (IASTCastExpression) parent;",
                        "\t\t\t\ttargetType = CPPVisitor.createType(cast.getTypeId().getAbstractDeclarator());",
                        "\t\t\t} else if (prop == ICPPASTTemplateId.TEMPLATE_ID_ARGUMENT) {",
                        "\t\t\t\t// target is a template non-type parameter (14.3.2-5)",
                        "\t\t\t\tICPPASTTemplateId id = (ICPPASTTemplateId) parent;",
                        "\t\t\t\tIASTNode[] args = id.getTemplateArguments();",
                        "\t\t\t\tint i = 0;",
                        "\t\t\t\tfor (; i < args.length; i++) {",
                        "\t\t\t\t\tif (args[i] == node) {",
                        "\t\t\t\t\t\tbreak;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t\tIBinding template = id.getTemplateName().resolveBinding();",
                        "\t\t\t\tif (template instanceof ICPPTemplateDefinition) {",
                        "\t\t\t\t\tICPPTemplateParameter[] ps = ((ICPPTemplateDefinition) template).getTemplateParameters();",
                        "\t\t\t\t\tif (i < args.length && i < ps.length && ps[i] instanceof ICPPTemplateNonTypeParameter) {",
                        "\t\t\t\t\t\ttargetType = ((ICPPTemplateNonTypeParameter) ps[i]).getType();",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t} else if (prop == IASTReturnStatement.RETURNVALUE) {",
                        "\t\t\t\t// target is the return value of a function, operator or conversion",
                        "\t\t\t\twhile (parent != null && !(parent instanceof IASTFunctionDefinition)) {",
                        "\t\t\t\t\tparent = parent.getParent();",
                        "\t\t\t\t}",
                        "\t\t\t\tif (parent instanceof IASTFunctionDefinition) {",
                        "\t\t\t\t\tIASTDeclarator dtor = ((IASTFunctionDefinition) parent).getDeclarator();",
                        "\t\t\t\t\tdtor = ASTQueries.findInnermostDeclarator(dtor);",
                        "\t\t\t\t\tIBinding binding = dtor.getName().resolveBinding();",
                        "\t\t\t\t\tif (binding instanceof IFunction) {",
                        "\t\t\t\t\t\tIFunctionType ft = ((IFunction) binding).getType();",
                        "\t\t\t\t\t\ttargetType = ft.getReturnType();",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t\tif (targetType == null && parent instanceof ICPPASTExpression && parent instanceof IASTImplicitNameOwner) {",
                        "\t\t\t\t// Trigger resolution of overloaded operator, which may resolve the",
                        "\t\t\t\t// function set.",
                        "\t\t\t\t((IASTImplicitNameOwner) parent).getImplicitNames();",
                        "\t\t\t\tfinal IBinding newBinding = name.getPreBinding();",
                        "\t\t\t\tif (!(newBinding instanceof CPPFunctionSet))",
                        "\t\t\t\t\treturn newBinding;",
                        "",
                        "\t\t\t\t// If we're in a dependent context, we don't have enough information",
                        "\t\t\t\t// to resolve the function set.",
                        "\t\t\t\tif (((ICPPASTExpression) parent).getEvaluation().isTypeDependent()) {",
                        "\t\t\t\t\treturn CPPDeferredFunction.createForCandidates(functionSet.getBindings());",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "",
                        "\t\t\tICPPFunction function = resolveTargetedFunction(targetType, functionSet);",
                        "\t\t\tif (function == null)",
                        "\t\t\t\treturn new ProblemBinding(name, IProblemBinding.SEMANTIC_INVALID_OVERLOAD);",
                        "",
                        "\t\t\treturn function;",
                        "\t\t} finally {",
                        "\t\t\tpopLookupPoint();",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tprivate static boolean isViableUserDefinedLiteralOperator(IBinding binding, int kind) {",
                        "\t\tif (binding == null || binding instanceof ProblemBinding) {",
                        "\t\t\treturn false;",
                        "\t\t}",
                        "\t\tif (binding instanceof ICPPFunction) {",
                        "\t\t\tICPPFunction func = (ICPPFunction) binding;",
                        "\t\t\tif (func.getRequiredArgumentCount() == 1) {",
                        "\t\t\t\tIType type = null;",
                        "\t\t\t\tif (kind == IASTLiteralExpression.lk_integer_constant) {",
                        "\t\t\t\t\ttype = new CPPBasicType(Kind.eInt, IBasicType.IS_UNSIGNED | IBasicType.IS_LONG_LONG);",
                        "\t\t\t\t} else if (kind == IASTLiteralExpression.lk_float_constant) {",
                        "\t\t\t\t\ttype = new CPPBasicType(Kind.eDouble, IBasicType.IS_LONG);",
                        "\t\t\t\t}",
                        "\t\t\t\treturn SemanticUtil.getNestedType(func.getParameters()[0].getType(), CVTYPE).isSameType(type);",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\treturn false;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Given a LiteralExpression with a user-defined literal suffix,",
                        "\t * finds the corresponding defined operator.",
                        "\t * Tries to implement 2.14.8.(2-10)",
                        "\t * @param exp <code>IASTLiteralExpression</code> which has a user-defined literal suffix",
                        "\t * @return CPPFunction or null",
                        "\t * @throws DOMException",
                        "\t */",
                        "\tpublic static IBinding findUserDefinedLiteralOperator(IASTLiteralExpression exp) throws DOMException {",
                        "\t\tpushLookupPoint(exp);",
                        "\t\tIBinding ret = null;",
                        "\t\ttry {",
                        "\t\t\t/*",
                        "\t\t\t * 2.14.8.2",
                        "\t\t\t * Let `IASTLiteralExpression exp` = L",
                        "\t\t\t * Let `exp.getSuffix()` = X",
                        "\t\t\t * Let `bindings` = S",
                        "\t\t\t * A user-defined-literal is treated as a call to a literal operator or",
                        "\t\t\t * literal operator template (13.5.8). To determine the form of this",
                        "\t\t\t * call for a given user-defined-literal L with ud-suffix X, the",
                        "\t\t\t * literal-operator-id whose literal suffix identifier is X is looked up",
                        "\t\t\t * in the context of L using the rules for unqualified name lookup (3.4.1).",
                        "\t\t\t * Let S be the set of declarations found by this lookup.",
                        "\t\t\t * S shall not be empty.",
                        "\t\t\t *",
                        "\t\t\t */",
                        "\t\t\tint kind = exp.getKind();",
                        "\t\t\tIScope lookupScope = CPPVisitor.getContainingScope(exp);",
                        "\t\t\tIBinding[] bindings = findBindings(lookupScope, ((CPPASTLiteralExpression) exp).getOperatorName(), false);",
                        "\t\t\tICPPFunction[] funcs = new ICPPFunction[bindings.length];",
                        "\t\t\tICPPFunctionTemplate[] tplFunctions = new ICPPFunctionTemplate[bindings.length];",
                        "\t\t\tLookupData data = new LookupData(((CPPASTLiteralExpression) exp).getOperatorName(), null, exp);",
                        "",
                        "\t\t\tint i = 0, j = 0;",
                        "\t\t\tfor (IBinding binding : bindings) {",
                        "\t\t\t\tif (binding instanceof ICPPFunction || binding instanceof ICPPFunctionTemplate) {",
                        "\t\t\t\t\tfuncs[i++] = (ICPPFunction) binding;",
                        "\t\t\t\t\tif (binding instanceof ICPPFunctionTemplate) {",
                        "\t\t\t\t\t\ttplFunctions[j++] = (ICPPFunctionTemplate) binding;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "",
                        "\t\t\tfuncs = ArrayUtil.trim(funcs, i);",
                        "\t\t\ttplFunctions = ArrayUtil.trim(tplFunctions, j);",
                        "",
                        "\t\t\tif (funcs.length == 0) {",
                        "\t\t\t\t// S shall not be empty",
                        "\t\t\t\treturn new ProblemBinding(data.getLookupName(), exp, IProblemBinding.SEMANTIC_NAME_NOT_FOUND);",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (kind == IASTLiteralExpression.lk_integer_constant || kind == IASTLiteralExpression.lk_float_constant) {",
                        "\t\t\t\tif (kind == IASTLiteralExpression.lk_integer_constant) {",
                        "\t\t\t\t\t/*",
                        "\t\t\t\t\t * 2.14.8.3",
                        "\t\t\t\t\t * Let `exp.getValue()` = n",
                        "\t\t\t\t\t * If L is a user-defined-integer-literal, let n be the literal",
                        "\t\t\t\t\t * without its ud-suffix. If S contains a literal operator with",
                        "\t\t\t\t\t * parameter type unsigned long long, then use operator \"\" X(n ULL)",
                        "\t\t\t\t\t */",
                        "\t\t\t\t\tCPPBasicType t = new CPPBasicType(Kind.eInt, IBasicType.IS_UNSIGNED | IBasicType.IS_LONG_LONG, exp);",
                        "\t\t\t\t\tdata.setFunctionArguments(false, createArgForType(exp, t));",
                        "\t\t\t\t\tret = resolveFunction(data, funcs, true, false);",
                        "\t\t\t\t\tif (isViableUserDefinedLiteralOperator(ret, kind)) {",
                        "\t\t\t\t\t\treturn ret;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t} else if (kind == IASTLiteralExpression.lk_float_constant) {",
                        "\t\t\t\t\t/*",
                        "\t\t\t\t\t * 2.14.8.4",
                        "\t\t\t\t\t * Let `exp.getValue()` = f",
                        "\t\t\t\t\t * If L is a user-defined-floating-literal, let f be the literal",
                        "\t\t\t\t\t * without its ud-suffix. If S contains a literal operator with",
                        "\t\t\t\t\t * parameter type long double, then use operator \"\" X(f L)",
                        "\t\t\t\t\t */",
                        "\t\t\t\t\tCPPBasicType t = new CPPBasicType(Kind.eDouble, IBasicType.IS_LONG, exp);",
                        "\t\t\t\t\tdata.setFunctionArguments(false, createArgForType(exp, t));",
                        "\t\t\t\t\tret = resolveFunction(data, funcs, true, false);",
                        "\t\t\t\t\tif (isViableUserDefinedLiteralOperator(ret, kind)) {",
                        "\t\t\t\t\t\treturn ret;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "",
                        "\t\t\t\t/*",
                        "\t\t\t\t * 2.14.8.3 (cont.), 2.14.8.4 (cont.)",
                        "\t\t\t\t * Otherwise, S shall contain a raw literal operator or a literal",
                        "\t\t\t\t * operator template but not both.",
                        "\t\t\t\t */",
                        "\t\t\t\t// Raw literal operator `operator \"\" _op(const char * c)`",
                        "\t\t\t\tCPPPointerType charArray = new CPPPointerType(CPPBasicType.CHAR, true, false, false);",
                        "\t\t\t\tdata = new LookupData(((CPPASTLiteralExpression) exp).getOperatorName(), null, exp);",
                        "\t\t\t\tdata.setFunctionArguments(false, createArgForType(exp, charArray));",
                        "\t\t\t\tret = resolveFunction(data, funcs, true, false);",
                        "",
                        "\t\t\t\t//",
                        "\t\t\t\tchar[] stringLiteral = exp.getValue(); // The string literal that was passed to the operator",
                        "",
                        "\t\t\t\t// The string literal is passed to the operator as chars:",
                        "\t\t\t\t// \"literal\"_op -> operator \"\" _op<'l', 'i', 't', 'e', 'r', 'a', 'l'>();",
                        "\t\t\t\tICPPTemplateArgument args[] = new ICPPTemplateArgument[stringLiteral.length];",
                        "\t\t\t\tfor (int k = 0; k < stringLiteral.length; k++) {",
                        "\t\t\t\t\targs[k] = new CPPTemplateNonTypeArgument(",
                        "\t\t\t\t\t\t\tnew EvalFixed(CPPBasicType.CHAR, PRVALUE, IntegralValue.create(stringLiteral[k])));",
                        "\t\t\t\t}",
                        "",
                        "\t\t\t\tdata = new LookupData(((CPPASTLiteralExpression) exp).getOperatorName(), args, exp);",
                        "\t\t\t\tIBinding litTpl = resolveFunction(data, tplFunctions, true, false);",
                        "",
                        "\t\t\t\t// Do we have valid template and non-template bindings?",
                        "\t\t\t\tif (ret != null && !(ret instanceof IProblemBinding)) {",
                        "\t\t\t\t\t// Do we have valid template and non-template bindings?",
                        "\t\t\t\t\tif (litTpl instanceof ICPPFunctionInstance) {",
                        "\t\t\t\t\t\t// Ambiguity? It has two valid options, and the spec says it shouldn't",
                        "\t\t\t\t\t\treturn new ProblemBinding(data.getLookupName(), exp, IProblemBinding.SEMANTIC_AMBIGUOUS_LOOKUP,",
                        "\t\t\t\t\t\t\t\ttplFunctions);",
                        "\t\t\t\t\t}",
                        "\t\t\t\t} else {",
                        "\t\t\t\t\tif (litTpl instanceof ICPPFunctionInstance) {",
                        "\t\t\t\t\t\t// Only the template binding is valid",
                        "\t\t\t\t\t\tret = litTpl;",
                        "\t\t\t\t\t} else {",
                        "\t\t\t\t\t\t// Couldn't find a valid operator",
                        "\t\t\t\t\t\treturn ret;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t} else if (kind == IASTLiteralExpression.lk_string_literal) {",
                        "\t\t\t\t/*",
                        "\t\t\t\t * 2.14.8.5",
                        "\t\t\t\t * If L is a user-defined-string-literal, let str be the literal",
                        "\t\t\t\t * without its ud-suffix and let len be the number of code units in",
                        "\t\t\t\t * str (i.e., its length excluding the terminating null character).",
                        "\t\t\t\t * L is treated as operator \"\" X(str, len)",
                        "\t\t\t\t */",
                        "\t\t\t\tCPPPointerType strType = new CPPPointerType(",
                        "\t\t\t\t\t\tnew CPPBasicType(((CPPASTLiteralExpression) exp).getBasicCharKind(), 0, null), true, false,",
                        "\t\t\t\t\t\tfalse);",
                        "\t\t\t\tIASTInitializerClause[] initializer = new IASTInitializerClause[] { createArgForType(exp, strType),",
                        "\t\t\t\t\t\tcreateArgForType(null, CPPBasicType.UNSIGNED_INT) };",
                        "\t\t\t\tdata.setFunctionArguments(false, initializer);",
                        "\t\t\t\tret = resolveFunction(data, funcs, true, false);",
                        "\t\t\t} else if (kind == IASTLiteralExpression.lk_char_constant) {",
                        "\t\t\t\t/*",
                        "\t\t\t\t * 2.14.8.6",
                        "\t\t\t\t * If L is a user-defined-character-literal, let ch be the literal",
                        "\t\t\t\t * without its ud-suffix. S shall contain a literal operator whose",
                        "\t\t\t\t * only parameter has the type ch and the literal L is treated as a",
                        "\t\t\t\t * call operator \"\" X(ch)",
                        "\t\t\t\t */",
                        "\t\t\t\tCPPBasicType t = new CPPBasicType(((CPPASTLiteralExpression) exp).getBasicCharKind(), 0, exp);",
                        "\t\t\t\tdata.setFunctionArguments(false, createArgForType(exp, t));",
                        "\t\t\t\tret = resolveFunction(data, funcs, true, false);",
                        "\t\t\t}",
                        "\t\t} finally {",
                        "\t\t\tpopLookupPoint();",
                        "\t\t}",
                        "",
                        "\t\treturn ret;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * 13.4-1 A use of an overloaded function without arguments is resolved in certain contexts to",
                        "\t * a function.",
                        "\t */",
                        "\tstatic ICPPFunction resolveTargetedFunction(IType targetType, CPPFunctionSet set) {",
                        "\t\ttargetType = getNestedType(targetType, TDEF | REF | CVTYPE | PTR | MPTR);",
                        "\t\tif (!(targetType instanceof ICPPFunctionType))",
                        "\t\t\treturn null;",
                        "",
                        "\t\t// First pass, consider functions",
                        "\t\tICPPFunction[] fns = set.getBindings();",
                        "\t\tfor (ICPPFunction fn : fns) {",
                        "\t\t\tif (!(fn instanceof ICPPFunctionTemplate)) {",
                        "\t\t\t\tif (targetType.isSameType(fn.getType()))",
                        "\t\t\t\t\treturn fn;",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\t// Second pass, consider templates",
                        "\t\tICPPFunction result = null;",
                        "\t\tICPPFunctionTemplate resultTemplate = null;",
                        "\t\tboolean isAmbiguous = false;",
                        "\t\tfinal IASTTranslationUnit tu = CPPSemantics.getCurrentLookupPoint().getTranslationUnit();",
                        "\t\tfor (IFunction fn : fns) {",
                        "\t\t\ttry {",
                        "\t\t\t\tif (fn instanceof ICPPFunctionTemplate) {",
                        "\t\t\t\t\tfinal ICPPFunctionTemplate template = (ICPPFunctionTemplate) fn;",
                        "\t\t\t\t\tICPPFunction inst = CPPTemplates.instantiateForAddressOfFunction(template,",
                        "\t\t\t\t\t\t\t(ICPPFunctionType) targetType, set.getTemplateArguments());",
                        "\t\t\t\t\tif (inst != null) {",
                        "\t\t\t\t\t\tint cmp = CPPTemplates.orderFunctionTemplates(resultTemplate, template,",
                        "\t\t\t\t\t\t\t\tTypeSelection.PARAMETERS_AND_RETURN_TYPE);",
                        "\t\t\t\t\t\tif (cmp == 0)",
                        "\t\t\t\t\t\t\tcmp = compareByRelevance(tu, resultTemplate, template);",
                        "",
                        "\t\t\t\t\t\tif (cmp == 0)",
                        "\t\t\t\t\t\t\tisAmbiguous = true;",
                        "",
                        "\t\t\t\t\t\tif (cmp < 0) {",
                        "\t\t\t\t\t\t\tisAmbiguous = false;",
                        "\t\t\t\t\t\t\tresultTemplate = template;",
                        "\t\t\t\t\t\t\tresult = inst;",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t} catch (DOMException e) {",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\tif (isAmbiguous)",
                        "\t\t\treturn null;",
                        "",
                        "\t\treturn result;",
                        "\t}",
                        "",
                        "\tpublic static ICPPFunction findOverloadedBinaryOperator(IScope pointOfDefinition, OverloadableOperator op,",
                        "\t\t\tICPPEvaluation arg1, ICPPEvaluation arg2) {",
                        "\t\tif (op == null || arg1 == null || arg2 == null)",
                        "\t\t\treturn null;",
                        "",
                        "\t\tIType op1type = getNestedType(arg1.getType(), TDEF | REF | CVTYPE);",
                        "\t\tif (!isUserDefined(op1type) && !isUserDefined(getNestedType(arg2.getType(), TDEF | REF | CVTYPE)))",
                        "\t\t\treturn null;",
                        "",
                        "\t\tfinal LookupMode lookupNonMember;",
                        "\t\tif (op == OverloadableOperator.ASSIGN || op == OverloadableOperator.BRACKET) {",
                        "\t\t\tlookupNonMember = LookupMode.NO_GLOBALS;",
                        "\t\t} else {",
                        "\t\t\tlookupNonMember = LookupMode.LIMITED_GLOBALS;",
                        "\t\t}",
                        "\t\treturn findOverloadedOperator(pointOfDefinition, new ICPPEvaluation[] { arg1, arg2 }, op1type, op,",
                        "\t\t\t\tlookupNonMember);",
                        "\t}",
                        "",
                        "\tpublic static ICPPFunction findOverloadedOperator(ICPPASTNewExpression expr) {",
                        "\t\tpushLookupPoint(expr);",
                        "\t\ttry {",
                        "\t\t\tOverloadableOperator op = OverloadableOperator.fromNewExpression(expr);",
                        "\t\t\tfinal ICPPEvaluation evaluation = expr.getEvaluation();",
                        "\t\t\tif (evaluation.isTypeDependent())",
                        "\t\t\t\treturn null;",
                        "",
                        "\t\t\tfinal IASTInitializerClause[] placement = expr.getPlacementArguments();",
                        "\t\t\tfinal ICPPEvaluation arg1 = new EvalUnary(IASTUnaryExpression.op_star, evaluation, null, expr);",
                        "\t\t\tfinal ICPPEvaluation arg2 = new EvalUnary(IASTUnaryExpression.op_sizeof, evaluation, null, expr);",
                        "",
                        "\t\t\tICPPEvaluation[] args;",
                        "\t\t\tif (placement == null) {",
                        "\t\t\t\targs = new ICPPEvaluation[] { arg1, arg2 };",
                        "\t\t\t} else {",
                        "\t\t\t\targs = new ICPPEvaluation[2 + placement.length];",
                        "\t\t\t\targs[0] = arg1;",
                        "\t\t\t\targs[1] = arg2;",
                        "\t\t\t\tint i = 2;",
                        "\t\t\t\tfor (IASTInitializerClause p : placement) {",
                        "\t\t\t\t\tfinal ICPPEvaluation a = ((ICPPASTInitializerClause) p).getEvaluation();",
                        "\t\t\t\t\tif (a.isTypeDependent())",
                        "\t\t\t\t\t\treturn null;",
                        "\t\t\t\t\targs[i++] = a;",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t\tIType type = getNestedType(arg1.getType(), TDEF | REF | CVTYPE);",
                        "\t\t\treturn findOverloadedOperator(null, args, type, op, LookupMode.GLOBALS_IF_NO_MEMBERS);",
                        "\t\t} finally {",
                        "\t\t\tpopLookupPoint();",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tpublic static ICPPFunction findOverloadedOperator(ICPPASTDeleteExpression expr) {",
                        "\t\tpushLookupPoint(expr);",
                        "\t\ttry {",
                        "\t\t\tOverloadableOperator op = OverloadableOperator.fromDeleteExpression(expr);",
                        "\t\t\tIType type = getTypeOfPointer(expr.getOperand().getExpressionType());",
                        "\t\t\tif (type == null)",
                        "\t\t\t\treturn null;",
                        "",
                        "\t\t\tICPPEvaluation[] args = { new EvalFixed(type, LVALUE, IntegralValue.UNKNOWN),",
                        "\t\t\t\t\t((ICPPASTExpression) expr.getOperand()).getEvaluation() };",
                        "\t\t\treturn findOverloadedOperator(null, args, type, op, LookupMode.GLOBALS_IF_NO_MEMBERS);",
                        "\t\t} finally {",
                        "\t\t\tpopLookupPoint();",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tprivate static IType getTypeOfPointer(IType type) {",
                        "\t\ttype = SemanticUtil.getNestedType(type, SemanticUtil.TDEF | SemanticUtil.REF | SemanticUtil.CVTYPE);",
                        "\t\tif (type instanceof IPointerType) {",
                        "\t\t\treturn getNestedType(((IPointerType) type).getType(), TDEF | REF | CVTYPE);",
                        "\t\t}",
                        "\t\treturn null;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Returns constructor called by a declarator, or {@code null} if no constructor is called.",
                        "\t */",
                        "\tpublic static IBinding findImplicitlyCalledConstructor(final ICPPASTDeclarator declarator) {",
                        "\t\tpushLookupPoint(declarator);",
                        "\t\ttry {",
                        "\t\t\tif (declarator.getNestedDeclarator() != null)",
                        "\t\t\t\treturn null;",
                        "\t\t\tIASTDeclarator dtor = ASTQueries.findOutermostDeclarator(declarator);",
                        "\t\t\tIASTNode parent = dtor.getParent();",
                        "\t\t\tif (parent instanceof IASTSimpleDeclaration) {",
                        "\t\t\t\tfinal IASTInitializer initializer = dtor.getInitializer();",
                        "\t\t\t\tif (initializer == null) {",
                        "\t\t\t\t\tIASTDeclSpecifier declSpec = ((IASTSimpleDeclaration) parent).getDeclSpecifier();",
                        "\t\t\t\t\tparent = parent.getParent();",
                        "\t\t\t\t\tif (parent instanceof IASTCompositeTypeSpecifier",
                        "\t\t\t\t\t\t\t|| declSpec.getStorageClass() == IASTDeclSpecifier.sc_extern) {",
                        "\t\t\t\t\t\t// No initialization is performed for class members and extern declarations",
                        "\t\t\t\t\t\t// without an initializer.",
                        "\t\t\t\t\t\treturn null;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t\treturn findImplicitlyCalledConstructor(declarator.getName(), initializer);",
                        "\t\t\t}",
                        "\t\t} finally {",
                        "\t\t\tpopLookupPoint();",
                        "\t\t}",
                        "\t\treturn null;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Returns constructor called by a class member initializer in a constructor initializer chain.",
                        "\t * Returns {@code null} if no constructor is called. Returns a {@link IProblemBinding} if the called",
                        "\t * constructor cannot be uniquely resolved.",
                        "\t */",
                        "\tpublic static IBinding findImplicitlyCalledConstructor(ICPPASTConstructorChainInitializer initializer) {",
                        "\t\treturn findImplicitlyCalledConstructor(initializer.getMemberInitializerId(), initializer.getInitializer());",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Returns constructor called by a variable declarator or an initializer in a constructor",
                        "\t * initializer chain. Returns {@code null} if no constructor is called.",
                        "\t */",
                        "\tprivate static IBinding findImplicitlyCalledConstructor(IASTName name, IASTInitializer initializer) {",
                        "\t\tIBinding binding = name.resolveBinding();",
                        "\t\tif (!(binding instanceof ICPPVariable))",
                        "\t\t\treturn null;",
                        "",
                        "\t\tIType type = ((ICPPVariable) binding).getType();",
                        "\t\ttype = SemanticUtil.getNestedType(type, TDEF | CVTYPE);",
                        "\t\tif (!(type instanceof ICPPClassType))",
                        "\t\t\treturn null;",
                        "\t\tif (type instanceof ICPPClassTemplate || type instanceof ICPPUnknownType || type instanceof ISemanticProblem)",
                        "\t\t\treturn null;",
                        "",
                        "\t\t// The class type may be declared in a header but defined in the AST.",
                        "\t\t// In such a case, we want the constructors as AST bindings (since as",
                        "\t\t// index bindings they would fail declaredBefore() filtering), so map",
                        "\t\t// the class type to its AST representation.",
                        "\t\ttype = SemanticUtil.mapToAST(type);",
                        "",
                        "\t\treturn findImplicitlyCalledConstructor((ICPPClassType) type, initializer, name);",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Returns the constructor implicitly called by the given expression, or {@code null} if there is no",
                        "\t * constructor call, or a {@link IProblemBinding} if the called constructor cannot be uniquely resolved.",
                        "\t */",
                        "\tpublic static IBinding findImplicitlyCalledConstructor(ICPPASTNewExpression expr) {",
                        "\t\tIType type = getNestedType(expr.getExpressionType(), TDEF | REF | CVTYPE);",
                        "\t\tif (!(type instanceof IPointerType))",
                        "\t\t\treturn null;",
                        "\t\ttype = ((IPointerType) type).getType();",
                        "\t\tif (type instanceof ICPPClassType) {",
                        "\t\t\treturn findImplicitlyCalledConstructor((ICPPClassType) type, expr.getInitializer(), expr.getTypeId());",
                        "\t\t}",
                        "\t\treturn null;",
                        "\t}",
                        "",
                        "\tprivate static IBinding findImplicitlyCalledConstructor(ICPPClassType type, IASTInitializer initializer,",
                        "\t\t\tIASTNode typeId) {",
                        "\t\tpushLookupPoint(typeId);",
                        "\t\ttry {",
                        "\t\t\tif (initializer instanceof IASTEqualsInitializer) {",
                        "\t\t\t\t// Copy initialization.",
                        "\t\t\t\tIASTEqualsInitializer eqInit = (IASTEqualsInitializer) initializer;",
                        "\t\t\t\tICPPASTInitializerClause evalOwner = (ICPPASTInitializerClause) eqInit.getInitializerClause();",
                        "\t\t\t\tfinal ICPPEvaluation evaluation = evalOwner.getEvaluation();",
                        "\t\t\t\tIType sourceType = evaluation.getType();",
                        "\t\t\t\tValueCategory isLValue = evaluation.getValueCategory();",
                        "\t\t\t\tif (sourceType != null) {",
                        "\t\t\t\t\tCost c;",
                        "\t\t\t\t\tif (calculateInheritanceDepth(sourceType, type) >= 0) {",
                        "\t\t\t\t\t\tc = Conversions.copyInitializationOfClass(isLValue, sourceType, type, false);",
                        "\t\t\t\t\t} else {",
                        "\t\t\t\t\t\tc = Conversions.checkImplicitConversionSequence(type, sourceType, isLValue, UDCMode.ALLOWED,",
                        "\t\t\t\t\t\t\t\tContext.ORDINARY);",
                        "\t\t\t\t\t}",
                        "\t\t\t\t\tif (c.converts()) {",
                        "\t\t\t\t\t\tICPPFunction f = c.getUserDefinedConversion();",
                        "\t\t\t\t\t\tif (f instanceof ICPPConstructor)",
                        "\t\t\t\t\t\t\treturn f;",
                        "\t\t\t\t\t\t// If a conversion is used, the constructor is elided.",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t} else if (initializer instanceof ICPPASTInitializerList) {",
                        "\t\t\t\t// List initialization.",
                        "\t\t\t\tICPPEvaluation eval = ((ICPPASTInitializerClause) initializer).getEvaluation();",
                        "\t\t\t\tif (eval instanceof EvalInitList) {",
                        "\t\t\t\t\tCost c = Conversions.listInitializationSequence((EvalInitList) eval, type, UDCMode.ALLOWED, true);",
                        "\t\t\t\t\tif (c.converts()) {",
                        "\t\t\t\t\t\tICPPFunction f = c.getUserDefinedConversion();",
                        "\t\t\t\t\t\tif (f instanceof ICPPConstructor)",
                        "\t\t\t\t\t\t\treturn f;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t} else if (initializer instanceof ICPPASTConstructorInitializer) {",
                        "\t\t\t\t// Direct initialization.",
                        "\t\t\t\treturn findImplicitlyCalledConstructor(type, (ICPPASTConstructorInitializer) initializer, typeId);",
                        "\t\t\t} else if (initializer == null) {",
                        "\t\t\t\t// Default initialization.",
                        "\t\t\t\tICPPConstructor[] ctors = type.getConstructors();",
                        "\t\t\t\tfor (ICPPConstructor ctor : ctors) {",
                        "\t\t\t\t\tif (ctor.getRequiredArgumentCount() == 0)",
                        "\t\t\t\t\t\treturn ctor;",
                        "\t\t\t\t}",
                        "\t\t\t\treturn null;",
                        "\t\t\t}",
                        "\t\t} catch (DOMException e) {",
                        "\t\t} finally {",
                        "\t\t\tpopLookupPoint();",
                        "\t\t}",
                        "\t\treturn null;",
                        "\t}",
                        "",
                        "\tprivate static IBinding findImplicitlyCalledConstructor(ICPPClassType classType,",
                        "\t\t\tICPPASTConstructorInitializer initializer, IASTNode typeId) {",
                        "\t\tfinal IASTInitializerClause[] arguments = initializer.getArguments();",
                        "\t\tCPPASTName astName = new CPPASTName();",
                        "\t\tastName.setName(classType.getNameCharArray());",
                        "\t\tastName.setOffsetAndLength((ASTNode) typeId);",
                        "\t\tCPPASTIdExpression idExp = new CPPASTIdExpression(astName);",
                        "\t\tidExp.setParent(typeId.getParent());",
                        "\t\tidExp.setPropertyInParent(IASTFunctionCallExpression.FUNCTION_NAME);",
                        "",
                        "\t\tLookupData data = new LookupData(astName);",
                        "\t\tdata.setFunctionArguments(false, arguments);",
                        "\t\tdata.qualified = true;",
                        "\t\tdata.foundItems = classType.getConstructors();",
                        "\t\ttry {",
                        "\t\t\treturn resolveAmbiguities(data);",
                        "\t\t} catch (DOMException e) {",
                        "\t\t\treturn null;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tpublic static ICPPFunction findImplicitlyCalledDestructor(ICPPASTDeleteExpression expr) {",
                        "\t\tIType t = getTypeOfPointer(expr.getOperand().getExpressionType());",
                        "\t\tif (!(t instanceof ICPPClassType))",
                        "\t\t\treturn null;",
                        "",
                        "\t\tICPPClassType cls = (ICPPClassType) t;",
                        "\t\tIScope scope = cls.getCompositeScope();",
                        "\t\tif (scope == null)",
                        "\t\t\treturn null;",
                        "",
                        "\t\tfinal char[] name = CharArrayUtils.concat(\"~\".toCharArray(), cls.getNameCharArray()); //$NON-NLS-1$",
                        "\t\tLookupData data = new LookupData(name, null, expr);",
                        "\t\tdata.qualified = true;",
                        "\t\tdata.setFunctionArguments(true, new EvalFixed(cls, LVALUE, IntegralValue.UNKNOWN));",
                        "\t\ttry {",
                        "\t\t\tlookup(data, scope);",
                        "\t\t\tIBinding[] found = data.getFoundBindings();",
                        "\t\t\tif (found.length > 0 && found[0] instanceof ICPPFunction) {",
                        "\t\t\t\treturn (ICPPFunction) found[0];",
                        "\t\t\t}",
                        "\t\t} catch (DOMException e) {",
                        "\t\t}",
                        "\t\treturn null;",
                        "\t}",
                        "",
                        "\tpublic static ICPPASTExpression createArgForType(IASTNode node, final IType type) {",
                        "\t\tCPPASTName x = new CPPASTName();",
                        "\t\tx.setBinding(new CPPVariable(x) {",
                        "\t\t\t@Override",
                        "\t\t\tpublic IType getType() {",
                        "\t\t\t\treturn type;",
                        "\t\t\t}",
                        "\t\t});",
                        "\t\tfinal CPPASTIdExpression idExpression = new CPPASTIdExpression(x);",
                        "\t\tidExpression.setParent(node);",
                        "\t\treturn idExpression;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * For simplicity returns an operator of form RT (T, T) rather than RT (boolean, T, T)",
                        "\t */",
                        "\tpublic static ICPPFunction findOverloadedConditionalOperator(IScope pointOfDefinition, ICPPEvaluation positive,",
                        "\t\t\tICPPEvaluation negative) {",
                        "\t\tfinal ICPPEvaluation[] args = new ICPPEvaluation[] { positive, negative };",
                        "\t\treturn findOverloadedOperator(pointOfDefinition, args, null, OverloadableOperator.CONDITIONAL_OPERATOR,",
                        "\t\t\t\tLookupMode.NO_GLOBALS);",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Returns the operator,() function that would apply to the two given arguments.",
                        "\t * The lookup type of the class where the operator,() might be found must also be provided.",
                        "\t */",
                        "\tpublic static ICPPFunction findOverloadedOperatorComma(IScope pointOfDefinition, ICPPEvaluation arg1,",
                        "\t\t\tICPPEvaluation arg2) {",
                        "\t\tIType op1type = getNestedType(arg1.getType(), TDEF | REF | CVTYPE);",
                        "\t\tIType op2type = getNestedType(arg2.getType(), TDEF | REF | CVTYPE);",
                        "\t\tif (!isUserDefined(op1type) && !isUserDefined(op2type))",
                        "\t\t\treturn null;",
                        "",
                        "\t\tICPPEvaluation[] args = { arg1, arg2 };",
                        "\t\treturn findOverloadedOperator(pointOfDefinition, args, op1type, OverloadableOperator.COMMA,",
                        "\t\t\t\tLookupMode.LIMITED_GLOBALS);",
                        "\t}",
                        "",
                        "\tstatic enum LookupMode {",
                        "\t\tNO_GLOBALS, GLOBALS_IF_NO_MEMBERS, LIMITED_GLOBALS, ALL_GLOBALS",
                        "\t}",
                        "",
                        "\tstatic LookupData findOverloadedMemberOperator(IType methodLookupType, OverloadableOperator operator,",
                        "\t\t\tICPPEvaluation[] args, IASTNode pointOfInstantiation) {",
                        "\t\tLookupData methodData = null;",
                        "\t\tif (methodLookupType instanceof ISemanticProblem)",
                        "\t\t\treturn null;",
                        "\t\tif (methodLookupType instanceof ICPPClassType) {",
                        "\t\t\tICPPClassType classType = (ICPPClassType) methodLookupType;",
                        "\t\t\tmethodData = new LookupData(operator.toCharArray(), null, pointOfInstantiation);",
                        "\t\t\tmethodData.setFunctionArguments(true, args);",
                        "\t\t\tmethodData.qualified = true; // (13.3.1.2.3)",
                        "",
                        "\t\t\ttry {",
                        "\t\t\t\tIScope scope = classType.getCompositeScope();",
                        "\t\t\t\tif (scope == null)",
                        "\t\t\t\t\treturn null;",
                        "\t\t\t\tlookup(methodData, scope);",
                        "",
                        "\t\t\t} catch (DOMException e) {",
                        "\t\t\t\treturn null;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\treturn methodData;",
                        "\t}",
                        "",
                        "\tstatic LookupData findOverloadedNonmemberOperator(IType methodLookupType, OverloadableOperator operator,",
                        "\t\t\tICPPEvaluation[] args, IASTNode pointOfInstantiation, IScope pointOfDefinition, LookupData methodData,",
                        "\t\t\tLookupMode mode, IType type2, ICPPClassType callToObjectOfClassType) {",
                        "\t\tLookupData funcData = new LookupData(operator.toCharArray(), null, pointOfInstantiation);",
                        "",
                        "\t\t// Global new and delete operators do not take an argument for the this pointer.",
                        "\t\tswitch (operator) {",
                        "\t\tcase DELETE:",
                        "\t\tcase DELETE_ARRAY:",
                        "\t\tcase NEW:",
                        "\t\tcase NEW_ARRAY:",
                        "\t\t\targs = ArrayUtil.removeFirst(args);",
                        "\t\t\tbreak;",
                        "\t\tdefault:",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\tfuncData.setFunctionArguments(true, args);",
                        "\t\tfuncData.ignoreMembers = true; // (13.3.1.2.3)",
                        "\t\tboolean haveMembers = methodData != null && methodData.hasResults();",
                        "\t\tif (mode == LookupMode.ALL_GLOBALS || mode == LookupMode.LIMITED_GLOBALS",
                        "\t\t\t\t|| (mode == LookupMode.GLOBALS_IF_NO_MEMBERS && !haveMembers)) {",
                        "\t\t\ttry {",
                        "\t\t\t\tIScope scope = CPPVisitor.getContainingScope(pointOfInstantiation);",
                        "\t\t\t\tif (scope == null)",
                        "\t\t\t\t\treturn funcData;",
                        "\t\t\t\tlookup(funcData, scope);",
                        "\t\t\t\ttry {",
                        "\t\t\t\t\tdoArgumentDependentLookup(funcData);",
                        "\t\t\t\t} catch (DOMException e) {",
                        "\t\t\t\t}",
                        "",
                        "\t\t\t\t// Also do a lookup at the point of definition.",
                        "\t\t\t\tif (pointOfDefinition != null) {",
                        "\t\t\t\t\tLookupData funcData2 = new LookupData(operator.toCharArray(), null, pointOfInstantiation);",
                        "\t\t\t\t\tfuncData2.setFunctionArguments(true, args);",
                        "\t\t\t\t\tfuncData2.ignoreMembers = true;",
                        "\t\t\t\t\tlookup(funcData2, pointOfDefinition);",
                        "\t\t\t\t\tif (funcData2.hasResults()) {",
                        "\t\t\t\t\t\tmergeResults(funcData, funcData2.foundItems, false);",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "",
                        "\t\t\t\t// Filter with file-set",
                        "\t\t\t\tIASTTranslationUnit tu = pointOfInstantiation.getTranslationUnit();",
                        "\t\t\t\tif (tu != null && funcData.foundItems instanceof Object[]) {",
                        "\t\t\t\t\tfinal IIndexFileSet fileSet = tu.getIndexFileSet();",
                        "\t\t\t\t\tif (fileSet != null) {",
                        "\t\t\t\t\t\tint j = 0;",
                        "\t\t\t\t\t\tfinal Object[] items = (Object[]) funcData.foundItems;",
                        "\t\t\t\t\t\tfor (int i = 0; i < items.length; i++) {",
                        "\t\t\t\t\t\t\tObject item = items[i];",
                        "\t\t\t\t\t\t\titems[i] = null;",
                        "\t\t\t\t\t\t\tif (item instanceof IIndexBinding) {",
                        "\t\t\t\t\t\t\t\tif (!indexBindingIsReachable(fileSet, (IIndexBinding) item)) {",
                        "\t\t\t\t\t\t\t\t\tcontinue;",
                        "\t\t\t\t\t\t\t\t}",
                        "\t\t\t\t\t\t\t}",
                        "\t\t\t\t\t\t\titems[j++] = item;",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t} catch (DOMException e) {",
                        "\t\t\t\treturn funcData;",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (operator == OverloadableOperator.NEW || operator == OverloadableOperator.DELETE",
                        "\t\t\t\t\t|| operator == OverloadableOperator.NEW_ARRAY || operator == OverloadableOperator.DELETE_ARRAY) {",
                        "\t\t\t\t// Those operators replace the built-in operator",
                        "\t\t\t\tObject[] items = (Object[]) funcData.foundItems;",
                        "\t\t\t\tint j = 0;",
                        "\t\t\t\tfor (Object object : items) {",
                        "\t\t\t\t\tif (object instanceof ICPPFunction) {",
                        "\t\t\t\t\t\tICPPFunction func = (ICPPFunction) object;",
                        "\t\t\t\t\t\tif (!(func instanceof CPPImplicitFunction))",
                        "\t\t\t\t\t\t\titems[j++] = func;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t\tif (j > 0) {",
                        "\t\t\t\t\twhile (j < items.length) {",
                        "\t\t\t\t\t\titems[j++] = null;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t\t// 13.3.1.2.3",
                        "\t\t\t// However, if no operand type has class type, only those non-member functions ...",
                        "\t\t\tif (mode == LookupMode.LIMITED_GLOBALS) {",
                        "\t\t\t\tif (funcData.foundItems != null && !(methodLookupType instanceof ICPPClassType)",
                        "\t\t\t\t\t\t&& !(type2 instanceof ICPPClassType)) {",
                        "\t\t\t\t\tIEnumeration enum1 = null;",
                        "\t\t\t\t\tIEnumeration enum2 = null;",
                        "\t\t\t\t\tif (methodLookupType instanceof IEnumeration) {",
                        "\t\t\t\t\t\tenum1 = (IEnumeration) methodLookupType;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t\tif (type2 instanceof IEnumeration) {",
                        "\t\t\t\t\t\tenum2 = (IEnumeration) type2;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t\tObject[] items = (Object[]) funcData.foundItems;",
                        "\t\t\t\t\tint j = 0;",
                        "\t\t\t\t\tfor (Object object : items) {",
                        "\t\t\t\t\t\tif (object instanceof ICPPFunction) {",
                        "\t\t\t\t\t\t\tICPPFunction func = (ICPPFunction) object;",
                        "\t\t\t\t\t\t\tICPPFunctionType ft = func.getType();",
                        "\t\t\t\t\t\t\tIType[] pts = ft.getParameterTypes();",
                        "\t\t\t\t\t\t\tif ((enum1 != null && pts.length > 0",
                        "\t\t\t\t\t\t\t\t\t&& enum1.isSameType(getUltimateTypeUptoPointers(pts[0])))",
                        "\t\t\t\t\t\t\t\t\t|| (enum2 != null && pts.length > 1",
                        "\t\t\t\t\t\t\t\t\t\t\t&& enum2.isSameType(getUltimateTypeUptoPointers(pts[1])))) {",
                        "\t\t\t\t\t\t\t\titems[j++] = object;",
                        "\t\t\t\t\t\t\t}",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t}",
                        "\t\t\t\t\twhile (j < items.length) {",
                        "\t\t\t\t\t\titems[j++] = null;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\tif (callToObjectOfClassType != null) {",
                        "\t\t\ttry {",
                        "\t\t\t\t// 13.3.1.1.2 call to object of class type",
                        "\t\t\t\tICPPMethod[] ops = SemanticUtil.getConversionOperators(callToObjectOfClassType);",
                        "\t\t\t\tfor (ICPPMethod op : ops) {",
                        "\t\t\t\t\tif (op.isExplicit())",
                        "\t\t\t\t\t\tcontinue;",
                        "\t\t\t\t\tIFunctionType ft = op.getType();",
                        "\t\t\t\t\tif (ft != null) {",
                        "\t\t\t\t\t\tIType rt = SemanticUtil.getNestedType(ft.getReturnType(), SemanticUtil.TDEF);",
                        "\t\t\t\t\t\tif (rt instanceof IPointerType) {",
                        "\t\t\t\t\t\t\tIType ptt = SemanticUtil.getNestedType(((IPointerType) rt).getType(), SemanticUtil.TDEF);",
                        "\t\t\t\t\t\t\tif (ptt instanceof IFunctionType) {",
                        "\t\t\t\t\t\t\t\tIFunctionType ft2 = (IFunctionType) ptt;",
                        "\t\t\t\t\t\t\t\tIBinding sf = createSurrogateCallFunction(",
                        "\t\t\t\t\t\t\t\t\t\tpointOfInstantiation.getTranslationUnit().getScope(), ft2.getReturnType(), rt,",
                        "\t\t\t\t\t\t\t\t\t\tft2.getParameterTypes());",
                        "\t\t\t\t\t\t\t\tmergeResults(funcData, sf, false);",
                        "\t\t\t\t\t\t\t}",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t} catch (DOMException e) {",
                        "\t\t\t\treturn funcData;",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\tif (methodLookupType instanceof ICPPClassType || type2 instanceof ICPPClassType) {",
                        "\t\t\tICPPFunction[] builtins = BuiltinOperators.create(operator, args, (Object[]) funcData.foundItems);",
                        "\t\t\tmergeResults(funcData, builtins, false);",
                        "\t\t}",
                        "",
                        "\t\treturn funcData;",
                        "\t}",
                        "",
                        "\tstatic ICPPFunction findOverloadedOperator(IScope pointOfDefinition, ICPPEvaluation[] args, IType methodLookupType,",
                        "\t\t\tOverloadableOperator operator, LookupMode mode) {",
                        "\t\tIASTNode pointOfInstantiation = CPPSemantics.getCurrentLookupPoint();",
                        "\t\twhile (pointOfInstantiation instanceof IASTName) {",
                        "\t\t\tpointOfInstantiation = pointOfInstantiation.getParent();",
                        "\t\t}",
                        "",
                        "\t\tICPPClassType callToObjectOfClassType = null;",
                        "\t\tIType type2 = null;",
                        "\t\tif (args.length >= 2) {",
                        "\t\t\ttype2 = args[1].getType();",
                        "\t\t\ttype2 = getNestedType(type2, TDEF | REF | CVTYPE);",
                        "\t\t}",
                        "",
                        "\t\t// Find a method",
                        "\t\tLookupData methodData = findOverloadedMemberOperator(methodLookupType, operator, args, pointOfInstantiation);",
                        "\t\tif (methodData != null && operator == OverloadableOperator.PAREN) {",
                        "\t\t\tcallToObjectOfClassType = (ICPPClassType) methodLookupType;",
                        "\t\t}",
                        "",
                        "\t\t// Find a function",
                        "\t\tLookupData funcData = findOverloadedNonmemberOperator(methodLookupType, operator, args, pointOfInstantiation,",
                        "\t\t\t\tpointOfDefinition, methodData, mode, type2, callToObjectOfClassType);",
                        "",
                        "\t\ttry {",
                        "\t\t\tIBinding binding = null;",
                        "\t\t\tif (methodData != null && funcData.hasResults()) {",
                        "\t\t\t\t// if there was two lookups then merge the results",
                        "\t\t\t\tmergeResults(funcData, methodData.foundItems, false);",
                        "\t\t\t\tbinding = resolveAmbiguities(funcData);",
                        "\t\t\t} else if (funcData.hasResults()) {",
                        "\t\t\t\tbinding = resolveAmbiguities(funcData);",
                        "\t\t\t} else if (methodData != null) {",
                        "\t\t\t\tbinding = resolveAmbiguities(methodData);",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (binding instanceof ICPPFunction)",
                        "\t\t\t\treturn (ICPPFunction) binding;",
                        "\t\t} catch (DOMException e) {",
                        "\t\t}",
                        "",
                        "\t\treturn null;",
                        "\t}",
                        "",
                        "\tprivate static boolean indexBindingIsReachable(IIndexFileSet fileSet, IIndexBinding item) {",
                        "\t\tif (fileSet.containsDeclaration(item)) {",
                        "\t\t\treturn true;",
                        "\t\t}",
                        "",
                        "\t\t// Specializations of friend functions are sometimes created in the context",
                        "\t\t// of the file for which the AST is created, and which is thus not in the index",
                        "\t\t// file set. In some cases, an AST binding cannot be created for such",
                        "\t\t// specializations. To support these cases, consider the binding reachable if",
                        "\t\t// the friend function being specialized is reachable.",
                        "\t\t// This situation only arises in the presence of #includes that are not at",
                        "\t\t// global scope. Once bug 315964 is fixed, this workaround can be removed.",
                        "\t\tif (item instanceof ICPPFunctionSpecialization && !(item instanceof ICPPFunctionInstance)) {",
                        "\t\t\tIBinding specialized = ((ICPPFunctionSpecialization) item).getSpecializedBinding();",
                        "\t\t\treturn !(specialized instanceof IIndexBinding) || fileSet.containsDeclaration((IIndexBinding) specialized);",
                        "\t\t}",
                        "",
                        "\t\treturn false;",
                        "\t}",
                        "",
                        "\tprivate static IBinding createSurrogateCallFunction(IScope scope, IType returnType, IType rt,",
                        "\t\t\tIType[] parameterTypes) {",
                        "\t\tIType[] parms = new IType[parameterTypes.length + 1];",
                        "\t\tICPPParameter[] theParms = new ICPPParameter[parms.length];",
                        "",
                        "\t\tparms[0] = rt;",
                        "\t\ttheParms[0] = new CPPBuiltinParameter(rt);",
                        "\t\tfor (int i = 1; i < parms.length; i++) {",
                        "\t\t\tIType t = parameterTypes[i - 1];",
                        "\t\t\tparms[i] = t;",
                        "\t\t\ttheParms[i] = new CPPBuiltinParameter(t);",
                        "\t\t}",
                        "\t\tICPPFunctionType functionType = new CPPFunctionType(returnType, parms);",
                        "\t\treturn new CPPImplicitFunction(CALL_FUNCTION, scope, functionType, theParms, false, false);",
                        "\t}",
                        "",
                        "\tstatic boolean isUserDefined(IType type) {",
                        "\t\tif (type instanceof ISemanticProblem)",
                        "\t\t\treturn false;",
                        "",
                        "\t\treturn type instanceof ICPPClassType || type instanceof IEnumeration || type instanceof ICPPUnknownType;",
                        "\t}",
                        "",
                        "\tpublic static IBinding[] findBindingsInScope(IScope scope, String name, IASTTranslationUnit tu) {",
                        "\t\tLookupData data = new LookupData(name.toCharArray(), null, tu);",
                        "\t\treturn standardLookup(data, scope);",
                        "\t}",
                        "",
                        "\tpublic static IBinding[] findBindings(IScope scope, String name, boolean qualified) {",
                        "\t\treturn findBindings(scope, name.toCharArray(), qualified, null);",
                        "\t}",
                        "",
                        "\tpublic static IBinding[] findBindings(IScope scope, char[] name, boolean qualified) {",
                        "\t\treturn findBindings(scope, name, qualified, null);",
                        "\t}",
                        "",
                        "\tpublic static IBinding[] findBindings(IScope scope, char[] name, boolean qualified, IASTNode beforeNode) {",
                        "\t\tLookupData data;",
                        "\t\tif (beforeNode == null) {",
                        "\t\t\tdata = new LookupData(name, null, ASTInternal.getPhysicalNodeOfScope(scope));",
                        "\t\t\tdata.setIgnorePointOfDeclaration(true);",
                        "\t\t} else {",
                        "\t\t\tdata = new LookupData(name, null, beforeNode);",
                        "\t\t\tdata.setIgnorePointOfDeclaration(false);",
                        "\t\t}",
                        "\t\tdata.qualified = qualified;",
                        "\t\treturn standardLookup(data, scope);",
                        "\t}",
                        "",
                        "\tpublic static IBinding[] findBindingsForContentAssist(IASTName name, boolean prefixLookup,",
                        "\t\t\tString[] additionalNamespaces) {",
                        "\t\tLookupData data = createLookupData(name);",
                        "\t\tdata.contentAssist = true;",
                        "\t\tdata.fHeuristicBaseLookup = true;",
                        "\t\tdata.setPrefixLookup(prefixLookup);",
                        "\t\tdata.foundItems = new CharArrayObjectMap<>(2);",
                        "",
                        "\t\t// Convert namespaces to scopes.",
                        "\t\tList<ICPPScope> nsScopes = new ArrayList<>();",
                        "\t\tIASTTranslationUnit tu = name.getTranslationUnit();",
                        "\t\tif (additionalNamespaces != null && tu instanceof CPPASTTranslationUnit) {",
                        "\t\t\tfor (String nsName : additionalNamespaces) {",
                        "\t\t\t\tnsName = nsName.trim();",
                        "\t\t\t\tif (nsName.startsWith(\"::\")) { //$NON-NLS-1$",
                        "\t\t\t\t\tnsName = nsName.substring(2);",
                        "\t\t\t\t}",
                        "\t\t\t\tString[] namespaceParts = nsName.split(\"::\"); //$NON-NLS-1$",
                        "\t\t\t\ttry {",
                        "\t\t\t\t\tICPPScope nsScope = getNamespaceScope((CPPASTTranslationUnit) tu, namespaceParts, name);",
                        "\t\t\t\t\tif (nsScope != null) {",
                        "\t\t\t\t\t\tnsScopes.add(nsScope);",
                        "\t\t\t\t\t}",
                        "\t\t\t\t} catch (DOMException e) {",
                        "\t\t\t\t\t// Errors in source code, continue with next candidate.",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\treturn contentAssistLookup(data, nsScopes);",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Similar to {@link CPPSemantics#findBindingsForContentAssist(IASTName, boolean, String[])},",
                        "\t * but in lieu of a name hooked up to the AST, accepts just a string, a position in the file",
                        "\t * (represented as an IASTNode, and used to serve as the point of reference for the lookup),",
                        "\t * and a starting scope (which is required).",
                        "\t */",
                        "\tpublic static IBinding[] findBindingsForContentAssist(char[] name, boolean prefixLookup, IScope lookupScope,",
                        "\t\t\tIASTNode point) {",
                        "\t\tLookupData data = new LookupData(name, null, point);",
                        "\t\tdata.contentAssist = true;",
                        "\t\tdata.fHeuristicBaseLookup = true;",
                        "\t\tdata.setPrefixLookup(prefixLookup);",
                        "\t\tdata.foundItems = new CharArrayObjectMap<>(2);",
                        "\t\ttry {",
                        "\t\t\tCPPSemantics.lookup(data, lookupScope);",
                        "\t\t} catch (DOMException e) {",
                        "\t\t}",
                        "\t\treturn collectContentAssistBindings(data);",
                        "\t}",
                        "",
                        "\tprivate static IScope getLookupScope(IASTNode node) {",
                        "\t\tif (node == null)",
                        "\t\t\treturn null;",
                        "",
                        "\t\tif (node instanceof IASTCompositeTypeSpecifier)",
                        "\t\t\treturn ((IASTCompositeTypeSpecifier) node).getScope();",
                        "",
                        "\t\tif (node instanceof ICPPASTNamespaceDefinition)",
                        "\t\t\treturn ((ICPPASTNamespaceDefinition) node).getScope();",
                        "",
                        "\t\tif (!(node instanceof ICPPInternalBinding))",
                        "\t\t\treturn null;",
                        "",
                        "\t\tIASTNode defn = ((ICPPInternalBinding) node).getDefinition();",
                        "\t\tif (defn == null)",
                        "\t\t\treturn null;",
                        "",
                        "\t\treturn getLookupScope(defn.getParent());",
                        "\t}",
                        "",
                        "\tprivate static IScope getLookupScope(IBinding binding) {",
                        "\t\tif (binding == null)",
                        "\t\t\treturn null;",
                        "",
                        "\t\tif (binding instanceof IASTCompositeTypeSpecifier)",
                        "\t\t\treturn ((IASTCompositeTypeSpecifier) binding).getScope();",
                        "",
                        "\t\tif (!(binding instanceof ICPPInternalBinding))",
                        "\t\t\treturn null;",
                        "",
                        "\t\tIASTNode defn = ((ICPPInternalBinding) binding).getDefinition();",
                        "\t\tif (defn == null)",
                        "\t\t\treturn null;",
                        "",
                        "\t\treturn getLookupScope(defn.getParent());",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Uses C++ lookup semantics to find the possible bindings for the given qualified name starting",
                        "\t * in the given scope.",
                        "\t */",
                        "\tpublic static IBinding[] findBindingsForQualifiedName(IScope scope, String qualifiedName) {",
                        "\t\t// Return immediately if the qualifiedName does not match a known format.",
                        "\t\tMatcher m = QUALNAME_REGEX.matcher(qualifiedName);",
                        "\t\tif (!m.matches())",
                        "\t\t\treturn IBinding.EMPTY_BINDING_ARRAY;",
                        "",
                        "\t\t// If the qualified name is rooted in the global namespace, then navigate to that scope.",
                        "\t\tboolean isGlobal = m.group(1) != null;",
                        "\t\tif (isGlobal) {",
                        "\t\t\tIScope global = scope;",
                        "\t\t\ttry {",
                        "\t\t\t\twhile (global.getParent() != null) {",
                        "\t\t\t\t\tglobal = global.getParent();",
                        "\t\t\t\t}",
                        "\t\t\t} catch (DOMException e) {",
                        "\t\t\t\tCCorePlugin.log(e);",
                        "\t\t\t}",
                        "\t\t\tscope = global;",
                        "\t\t}",
                        "",
                        "\t\tSet<IBinding> bindings = new HashSet<>();",
                        "",
                        "\t\t// Look for the name in the given scope.",
                        "\t\tfindBindingsForQualifiedName(scope, qualifiedName, bindings);",
                        "",
                        "\t\t// If the qualified name is not rooted in the global namespace (with a leading ::), then",
                        "\t\t// look at all parent scopes.",
                        "\t\tif (!isGlobal) {",
                        "\t\t\ttry {",
                        "\t\t\t\twhile (scope != null) {",
                        "\t\t\t\t\tscope = scope.getParent();",
                        "\t\t\t\t\tif (scope != null)",
                        "\t\t\t\t\t\tfindBindingsForQualifiedName(scope, qualifiedName, bindings);",
                        "\t\t\t\t}",
                        "\t\t\t} catch (DOMException e) {",
                        "\t\t\t\tCCorePlugin.log(e);",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\treturn bindings.size() == 0 ? IBinding.EMPTY_BINDING_ARRAY : bindings.toArray(new IBinding[bindings.size()]);",
                        "\t}",
                        "",
                        "\tprivate static void findBindingsForQualifiedName(IScope scope, String qualifiedName,",
                        "\t\t\tCollection<IBinding> bindings) {",
                        "\t\t// Split the qualified name into the first part (before the first :: qualifier) and the rest. All",
                        "\t\t// bindings for the first part are found and their scope is used to find the rest of the name.  When",
                        "\t\t// the call tree gets to a leaf (non-qualified name) then a simple lookup happens and all matching",
                        "\t\t// bindings are added to the result.",
                        "\t\tMatcher m = QUALNAME_REGEX.matcher(qualifiedName);",
                        "\t\tif (!m.matches())",
                        "\t\t\treturn;",
                        "",
                        "\t\tString part1 = m.group(2);",
                        "\t\tString part2 = m.group(3);",
                        "",
                        "\t\t// When we're down to a single component name, then use the normal lookup method.",
                        "\t\tif (part2 == null || part2.isEmpty()) {",
                        "\t\t\tbindings.addAll(Arrays.asList(findBindings(scope, part1, false)));",
                        "\t\t\treturn;",
                        "\t\t}",
                        "",
                        "\t\t// Find all bindings that match the first part of the name.  For each such binding,",
                        "\t\t// lookup the second part of the name.",
                        "\t\tfor (IBinding binding : findBindings(scope, part1, false)) {",
                        "\t\t\tfindBindingsForQualifiedName(getLookupScope(binding), part2, bindings);",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tprivate static ICPPScope getNamespaceScope(CPPASTTranslationUnit tu, String[] namespaceParts, IASTNode point)",
                        "\t\t\tthrows DOMException {",
                        "\t\tICPPScope nsScope = tu.getScope();",
                        "\t\touter: for (String nsPart : namespaceParts) {",
                        "\t\t\tnsPart = nsPart.trim();",
                        "\t\t\tif (nsPart.length() != 0) {",
                        "\t\t\t\tIBinding[] nsBindings = nsScope.getBindings(new ScopeLookupData(nsPart.toCharArray(), point));",
                        "\t\t\t\tfor (IBinding nsBinding : nsBindings) {",
                        "\t\t\t\t\tif (nsBinding instanceof ICPPNamespace) {",
                        "\t\t\t\t\t\tnsScope = ((ICPPNamespace) nsBinding).getNamespaceScope();",
                        "\t\t\t\t\t\tcontinue outer;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t\t// There was no matching namespace",
                        "\t\t\t\treturn null;",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\t// Name did not specify a namespace, e.g. \"::\"",
                        "\t\tif (nsScope == tu.getScope())",
                        "\t\t\treturn null;",
                        "",
                        "\t\treturn nsScope;",
                        "\t}",
                        "",
                        "\tprivate static IBinding[] contentAssistLookup(LookupData data, List<ICPPScope> additionalNamespaces) {",
                        "\t\ttry {",
                        "\t\t\tlookup(data, null);",
                        "",
                        "\t\t\tif (additionalNamespaces != null) {",
                        "\t\t\t\tdata.ignoreUsingDirectives = true;",
                        "\t\t\t\tdata.qualified = true;",
                        "\t\t\t\tfor (ICPPScope nsScope : additionalNamespaces) {",
                        "\t\t\t\t\tif (!data.visited.containsKey(nsScope)) {",
                        "\t\t\t\t\t\tlookup(data, nsScope);",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t} catch (DOMException e) {",
                        "\t\t}",
                        "\t\treturn collectContentAssistBindings(data);",
                        "\t}",
                        "",
                        "\tprivate static IBinding[] collectContentAssistBindings(LookupData data) {",
                        "\t\t@SuppressWarnings(\"unchecked\")",
                        "\t\tCharArrayObjectMap<Object> map = (CharArrayObjectMap<Object>) data.foundItems;",
                        "\t\tIBinding[] result = IBinding.EMPTY_BINDING_ARRAY;",
                        "\t\tif (!map.isEmpty()) {",
                        "\t\t\tchar[] key = null;",
                        "\t\t\tint size = map.size();",
                        "\t\t\tfor (int i = 0; i < size; i++) {",
                        "\t\t\t\tkey = map.keyAt(i);",
                        "\t\t\t\tresult = addContentAssistBinding(result, map.get(key));",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\treturn ArrayUtil.trim(result);",
                        "\t}",
                        "",
                        "\tpublic static IBinding[] addContentAssistBinding(IBinding[] result, Object obj) {",
                        "\t\tif (obj instanceof Object[]) {",
                        "\t\t\tfor (Object o : (Object[]) obj) {",
                        "\t\t\t\tresult = addContentAssistBinding(result, o);",
                        "\t\t\t}",
                        "\t\t\treturn result;",
                        "\t\t}",
                        "",
                        "\t\tif (obj instanceof IASTName) {",
                        "\t\t\treturn addContentAssistBinding(result, ((IASTName) obj).resolveBinding());",
                        "\t\t}",
                        "",
                        "\t\tif (obj instanceof IBinding && !(obj instanceof IProblemBinding)) {",
                        "\t\t\tfinal IBinding binding = (IBinding) obj;",
                        "\t\t\tif (binding instanceof ICPPFunction) {",
                        "\t\t\t\tfinal ICPPFunction function = (ICPPFunction) binding;",
                        "\t\t\t\tif (function.isDeleted()) {",
                        "\t\t\t\t\treturn result;",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t\treturn ArrayUtil.append(result, binding);",
                        "\t\t}",
                        "",
                        "\t\treturn result;",
                        "\t}",
                        "",
                        "\tprivate static IBinding[] standardLookup(LookupData data, IScope start) {",
                        "\t\ttry {",
                        "\t\t\tlookup(data, start);",
                        "\t\t} catch (DOMException e) {",
                        "\t\t\treturn new IBinding[] { e.getProblem() };",
                        "\t\t}",
                        "",
                        "\t\tObject[] items = (Object[]) data.foundItems;",
                        "\t\tif (items == null)",
                        "\t\t\treturn IBinding.EMPTY_BINDING_ARRAY;",
                        "",
                        "\t\tObjectSet<IBinding> set = new ObjectSet<>(items.length);",
                        "\t\tIBinding binding = null;",
                        "\t\tfor (Object item : items) {",
                        "\t\t\tif (item instanceof IASTName) {",
                        "\t\t\t\tbinding = ((IASTName) item).resolveBinding();",
                        "\t\t\t} else if (item instanceof IBinding) {",
                        "\t\t\t\tbinding = (IBinding) item;",
                        "\t\t\t} else {",
                        "\t\t\t\tbinding = null;",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (binding != null) {",
                        "\t\t\t\tif (binding instanceof ICPPUsingDeclaration) {",
                        "\t\t\t\t\tset.addAll(((ICPPUsingDeclaration) binding).getDelegates());",
                        "\t\t\t\t} else if (binding instanceof CPPCompositeBinding) {",
                        "\t\t\t\t\tset.addAll(((CPPCompositeBinding) binding).getBindings());",
                        "\t\t\t\t} else {",
                        "\t\t\t\t\tset.put(binding);",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\treturn set.keyArray(IBinding.class);",
                        "\t}",
                        "",
                        "\tpublic static boolean isSameFunction(ICPPFunction function, IASTDeclarator declarator) {",
                        "\t\tfinal ICPPASTDeclarator innerDtor = (ICPPASTDeclarator) ASTQueries.findInnermostDeclarator(declarator);",
                        "\t\tIASTName name = innerDtor.getName();",
                        "\t\tICPPASTTemplateDeclaration templateDecl = CPPTemplates.getTemplateDeclaration(name);",
                        "\t\tif (templateDecl != null) {",
                        "",
                        "\t\t\tif (templateDecl instanceof ICPPASTTemplateSpecialization) {",
                        "\t\t\t\tif (!(function instanceof ICPPTemplateInstance))",
                        "\t\t\t\t\treturn false;",
                        "\t\t\t\tif (!((ICPPTemplateInstance) function).isExplicitSpecialization())",
                        "\t\t\t\t\treturn false;",
                        "\t\t\t} else {",
                        "\t\t\t\tif (function instanceof ICPPTemplateDefinition) {",
                        "\t\t\t\t\tfinal ICPPTemplateDefinition funcTemplate = (ICPPTemplateDefinition) function;",
                        "\t\t\t\t\tif (!isSameTemplateParameterList(funcTemplate.getTemplateParameters(),",
                        "\t\t\t\t\t\t\ttemplateDecl.getTemplateParameters())) {",
                        "\t\t\t\t\t\treturn false;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t} else {",
                        "\t\t\t\t\treturn false;",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t} else if (function instanceof ICPPTemplateDefinition) {",
                        "\t\t\treturn false;",
                        "\t\t}",
                        "",
                        "\t\tdeclarator = ASTQueries.findTypeRelevantDeclarator(declarator);",
                        "\t\tif (declarator instanceof ICPPASTFunctionDeclarator) {",
                        "\t\t\t// For declaration matching, compare the declared types (placeholders not resolved).",
                        "\t\t\tIType type = function.getDeclaredType();",
                        "\t\t\treturn type.isSameType(CPPVisitor.createType(declarator, CPPVisitor.DO_NOT_RESOLVE_PLACEHOLDERS));",
                        "\t\t}",
                        "\t\treturn false;",
                        "\t}",
                        "",
                        "\tprivate static boolean isSameTemplateParameterList(ICPPTemplateParameter[] tplist, ICPPASTTemplateParameter[] tps) {",
                        "\t\tif (tplist.length != tps.length)",
                        "\t\t\treturn false;",
                        "",
                        "\t\tfor (int i = 0; i < tps.length; i++) {",
                        "\t\t\tif (!isSameTemplateParameter(tplist[i], tps[i]))",
                        "\t\t\t\treturn false;",
                        "\t\t}",
                        "\t\treturn true;",
                        "\t}",
                        "",
                        "\tstatic boolean isSameTemplateParameter(ICPPTemplateParameter tp1, ICPPASTTemplateParameter tp2) {",
                        "\t\tif (tp1.isParameterPack() != tp2.isParameterPack())",
                        "\t\t\treturn false;",
                        "",
                        "\t\tif (tp1 instanceof ICPPTemplateNonTypeParameter) {",
                        "\t\t\tif (tp2 instanceof ICPPASTParameterDeclaration) {",
                        "\t\t\t\tIType t1 = ((ICPPTemplateNonTypeParameter) tp1).getType();",
                        "\t\t\t\tIType t2 = CPPVisitor.createType((ICPPASTParameterDeclaration) tp2, true);",
                        "\t\t\t\treturn t1 != null && t1.isSameType(t2);",
                        "\t\t\t}",
                        "\t\t\treturn false;",
                        "\t\t}",
                        "\t\tif (tp1 instanceof ICPPTemplateTypeParameter) {",
                        "\t\t\tif (tp2 instanceof ICPPASTSimpleTypeTemplateParameter) {",
                        "\t\t\t\treturn true;",
                        "\t\t\t}",
                        "\t\t\treturn false;",
                        "\t\t}",
                        "\t\tif (tp1 instanceof ICPPTemplateTemplateParameter) {",
                        "\t\t\tif (tp2 instanceof ICPPASTTemplatedTypeTemplateParameter) {",
                        "\t\t\t\tfinal ICPPTemplateTemplateParameter ttp1 = (ICPPTemplateTemplateParameter) tp1;",
                        "\t\t\t\tfinal ICPPASTTemplatedTypeTemplateParameter ttp2 = (ICPPASTTemplatedTypeTemplateParameter) tp2;",
                        "\t\t\t\treturn isSameTemplateParameterList(ttp1.getTemplateParameters(), ttp2.getTemplateParameters());",
                        "\t\t\t}",
                        "\t\t\treturn false;",
                        "\t\t}",
                        "",
                        "\t\treturn false;",
                        "\t}",
                        "",
                        "\tprotected static IBinding resolveUnknownName(IScope scope, ICPPUnknownBinding unknown) {",
                        "\t\tfinal char[] unknownName = unknown.getNameCharArray();",
                        "\t\tIASTNode point = CPPSemantics.getCurrentLookupPoint();",
                        "\t\tLookupData data = new LookupData(unknownName, null, point);",
                        "\t\tdata.setIgnorePointOfDeclaration(true);",
                        "\t\tdata.typesOnly = unknown instanceof IType;",
                        "\t\tdata.qualified = true;",
                        "",
                        "\t\ttry {",
                        "\t\t\t// 2: Lookup",
                        "\t\t\tlookup(data, scope);",
                        "\t\t} catch (DOMException e) {",
                        "\t\t\tdata.problem = (ProblemBinding) e.getProblem();",
                        "\t\t}",
                        "",
                        "\t\tif (data.problem != null)",
                        "\t\t\treturn data.problem;",
                        "",
                        "\t\t// 3: Resolve ambiguities",
                        "\t\tIBinding binding;",
                        "\t\ttry {",
                        "\t\t\tbinding = resolveAmbiguities(data);",
                        "\t\t} catch (DOMException e) {",
                        "\t\t\tbinding = e.getProblem();",
                        "\t\t}",
                        "\t\t// 4: Normal post processing is not possible, because the name is not rooted in AST",
                        "\t\tif (binding == null)",
                        "\t\t\tbinding = new ProblemBinding(new CPPASTName(unknownName), point, IProblemBinding.SEMANTIC_NAME_NOT_FOUND);",
                        "",
                        "\t\treturn binding;",
                        "\t}",
                        "",
                        "\tpublic static void enablePromiscuousBindingResolution() {",
                        "\t\tfAllowPromiscuousBindingResolution.set(true);",
                        "\t}",
                        "",
                        "\tpublic static void disablePromiscuousBindingResolution() {",
                        "\t\tfAllowPromiscuousBindingResolution.set(false);",
                        "\t}",
                        "",
                        "\tpublic static boolean isUsingPromiscuousBindingResolution() {",
                        "\t\treturn fAllowPromiscuousBindingResolution.get();",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Compute decltype(expr) for an expression represented by an evaluation.",
                        "\t * This is similar to CPPVisitor.getDeclType(IASTExpression), but used in cases where the",
                        "\t * original expression was dependent, so we had to represent it as an evaluation and",
                        "\t * instantiate it.",
                        "\t *",
                        "\t * @param eval the (instantiated) evaluation representing the expression",
                        "\t */",
                        "\tpublic static IType getDeclTypeForEvaluation(ICPPEvaluation eval) {",
                        "\t\tIType expressionType = eval.getType();",
                        "\t\tboolean namedEntity = eval instanceof EvalBinding || eval instanceof EvalMemberAccess;",
                        "\t\tif (!namedEntity && !(expressionType instanceof ICPPReferenceType)) {",
                        "\t\t\tswitch (eval.getValueCategory()) {",
                        "\t\t\tcase XVALUE:",
                        "\t\t\t\treturn new CPPReferenceType(expressionType, true);",
                        "\t\t\tcase LVALUE:",
                        "\t\t\t\treturn new CPPReferenceType(expressionType, false);",
                        "\t\t\tcase PRVALUE:",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\treturn expressionType;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * This method performs type deduction for auto, decltype or typeof",
                        "\t * declarations. This is used by {@code CSourceHover} and",
                        "\t * {@code OpenDeclarationsJob} after checking (see",
                        "\t * {@code SemanticUtil#isAutoOrDecltype(String)}) whether the selected text",
                        "\t * equals any of the mentioned keywords.",
                        "\t *",
                        "\t * @param node",
                        "\t *            The decl-specifier or decltype-specifier in which the 'auto'",
                        "\t *            or 'decltype' occurs.",
                        "\t * @return the deduced type or null",
                        "\t */",
                        "\tpublic static IType resolveDecltypeOrAutoType(IASTNode node) {",
                        "\t\tIType type = null;",
                        "\t\tif (node instanceof ICPPASTDecltypeSpecifier) {",
                        "\t\t\ttype = ((ICPPASTDecltypeSpecifier) node).getDecltypeExpression().getExpressionType();",
                        "\t\t}",
                        "\t\tif (node instanceof ICPPASTSimpleDeclSpecifier) {",
                        "\t\t\tint builtin = ((ICPPASTSimpleDeclSpecifier) node).getType();",
                        "\t\t\tif (builtin == ICPPASTSimpleDeclSpecifier.t_auto || builtin == ICPPASTSimpleDeclSpecifier.t_typeof",
                        "\t\t\t\t\t|| builtin == ICPPASTSimpleDeclSpecifier.t_decltype) {",
                        "\t\t\t\tIASTNode parent = node.getParent();",
                        "\t\t\t\tIASTDeclarator declarator = null;",
                        "\t\t\t\tif (parent instanceof IASTSimpleDeclaration) {",
                        "\t\t\t\t\tIASTDeclarator[] declarators = ((IASTSimpleDeclaration) parent).getDeclarators();",
                        "\t\t\t\t\t// It's invalid for different declarators to deduce",
                        "\t\t\t\t\t// different types with 'auto', so just get the type based on the",
                        "\t\t\t\t\t// first declarator.",
                        "\t\t\t\t\tif (declarators.length > 0)",
                        "\t\t\t\t\t\tdeclarator = declarators[0];",
                        "\t\t\t\t} else if (parent instanceof IASTParameterDeclaration && builtin != ICPPASTSimpleDeclSpecifier.t_auto) {",
                        "\t\t\t\t\tdeclarator = ((IASTParameterDeclaration) parent).getDeclarator();",
                        "\t\t\t\t} else if (parent instanceof ICPPASTTypeId && builtin != ICPPASTSimpleDeclSpecifier.t_auto) {",
                        "\t\t\t\t\tdeclarator = ((ICPPASTTypeId) parent).getAbstractDeclarator();",
                        "\t\t\t\t} else if (parent instanceof ICPPASTFunctionDefinition) {",
                        "\t\t\t\t\tdeclarator = ((ICPPASTFunctionDefinition) parent).getDeclarator();",
                        "\t\t\t\t}",
                        "\t\t\t\tif (declarator != null) {",
                        "\t\t\t\t\ttype = CPPVisitor.createType(declarator);",
                        "\t\t\t\t\tif (type instanceof ICPPFunctionType) {",
                        "\t\t\t\t\t\ttype = ((ICPPFunctionType) type).getReturnType();",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\treturn type;",
                        "\t}",
                        "}",
                        ""
                    ]
                }
            ]
        },
        "core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/CPPTemplates.java": {
            "meta_a": {
                "name": "core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/CPPTemplates.java",
                "content_type": "text/x-java",
                "lines": 3410,
                "web_links": [
                    {
                        "name": "browse",
                        "url": "/r/plugins/gitiles/cdt/org.eclipse.cdt/+/d085e955c72e7ce382620a78dee2643e093d9d96/core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/CPPTemplates.java",
                        "target": "_blank"
                    }
                ]
            },
            "meta_b": {
                "name": "core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/CPPTemplates.java",
                "content_type": "text/x-java",
                "lines": 3417,
                "web_links": [
                    {
                        "name": "browse",
                        "url": "/r/plugins/gitiles/cdt/org.eclipse.cdt/+/refs/changes/40/133040/1/core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/CPPTemplates.java",
                        "target": "_blank"
                    }
                ]
            },
            "change_type": "MODIFIED",
            "diff_header": [
                "diff --git a/core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/CPPTemplates.java b/core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/CPPTemplates.java",
                "index d894fc5..6cefad6 100644",
                "--- a/core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/CPPTemplates.java",
                "+++ b/core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/CPPTemplates.java"
            ],
            "content": [
                {
                    "ab": [
                        "/*******************************************************************************",
                        " * Copyright (c) 2005, 2016 IBM Corporation and others.",
                        " *",
                        " * This program and the accompanying materials",
                        " * are made available under the terms of the Eclipse Public License 2.0",
                        " * which accompanies this distribution, and is available at",
                        " * https://www.eclipse.org/legal/epl-2.0/",
                        " *",
                        " * SPDX-License-Identifier: EPL-2.0",
                        " *",
                        " * Contributors:",
                        " *     IBM - Initial API and implementation",
                        " *     Bryan Wilkinson (QNX)",
                        " *     Markus Schorn (Wind River Systems)",
                        " *     Sergey Prigogin (Google)",
                        " *     Thomas Corbat (IFS)",
                        " *     Nathan Ridge",
                        " *******************************************************************************/",
                        "package org.eclipse.cdt.internal.core.dom.parser.cpp.semantics;",
                        "",
                        "import static org.eclipse.cdt.core.dom.ast.IASTExpression.ValueCategory.LVALUE;",
                        "import static org.eclipse.cdt.internal.core.dom.parser.cpp.InstantiationContext.getContextClassSpecialization;",
                        "import static org.eclipse.cdt.internal.core.dom.parser.cpp.semantics.SemanticUtil.ALLCVQ;",
                        "import static org.eclipse.cdt.internal.core.dom.parser.cpp.semantics.SemanticUtil.CVTYPE;",
                        "import static org.eclipse.cdt.internal.core.dom.parser.cpp.semantics.SemanticUtil.REF;",
                        "import static org.eclipse.cdt.internal.core.dom.parser.cpp.semantics.SemanticUtil.TDEF;",
                        "import static org.eclipse.cdt.internal.core.dom.parser.cpp.semantics.SemanticUtil.getNestedType;",
                        "",
                        "import java.util.ArrayList;",
                        "import java.util.HashSet;",
                        "import java.util.List;",
                        "import java.util.Map;",
                        "import java.util.Set;",
                        "",
                        "import org.eclipse.cdt.core.CCorePlugin;",
                        "import org.eclipse.cdt.core.dom.ast.ASTTypeUtil;",
                        "import org.eclipse.cdt.core.dom.ast.ASTVisitor;",
                        "import org.eclipse.cdt.core.dom.ast.DOMException;",
                        "import org.eclipse.cdt.core.dom.ast.IASTCompositeTypeSpecifier;",
                        "import org.eclipse.cdt.core.dom.ast.IASTDeclSpecifier;",
                        "import org.eclipse.cdt.core.dom.ast.IASTDeclaration;",
                        "import org.eclipse.cdt.core.dom.ast.IASTDeclarator;",
                        "import org.eclipse.cdt.core.dom.ast.IASTElaboratedTypeSpecifier;",
                        "import org.eclipse.cdt.core.dom.ast.IASTExpression.ValueCategory;",
                        "import org.eclipse.cdt.core.dom.ast.IASTFunctionDeclarator;",
                        "import org.eclipse.cdt.core.dom.ast.IASTFunctionDefinition;",
                        "import org.eclipse.cdt.core.dom.ast.IASTIdExpression;",
                        "import org.eclipse.cdt.core.dom.ast.IASTName;",
                        "import org.eclipse.cdt.core.dom.ast.IASTNameOwner;",
                        "import org.eclipse.cdt.core.dom.ast.IASTNode;",
                        "import org.eclipse.cdt.core.dom.ast.IASTSimpleDeclaration;",
                        "import org.eclipse.cdt.core.dom.ast.IASTTranslationUnit;",
                        "import org.eclipse.cdt.core.dom.ast.IASTTypeId;",
                        "import org.eclipse.cdt.core.dom.ast.IArrayType;",
                        "import org.eclipse.cdt.core.dom.ast.IBinding;",
                        "import org.eclipse.cdt.core.dom.ast.IEnumerator;",
                        "import org.eclipse.cdt.core.dom.ast.IFunction;",
                        "import org.eclipse.cdt.core.dom.ast.IFunctionType;",
                        "import org.eclipse.cdt.core.dom.ast.IPointerType;",
                        "import org.eclipse.cdt.core.dom.ast.IProblemBinding;",
                        "import org.eclipse.cdt.core.dom.ast.IScope;",
                        "import org.eclipse.cdt.core.dom.ast.ISemanticProblem;",
                        "import org.eclipse.cdt.core.dom.ast.IType;",
                        "import org.eclipse.cdt.core.dom.ast.ITypedef;",
                        "import org.eclipse.cdt.core.dom.ast.IValue;",
                        "import org.eclipse.cdt.core.dom.ast.IVariable;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTAliasDeclaration;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTAmbiguousTemplateArgument;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTCompositeTypeSpecifier;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTCompositeTypeSpecifier.ICPPASTBaseSpecifier;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTDeclSpecifier;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTDeclarator;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTElaboratedTypeSpecifier;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTExplicitTemplateInstantiation;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTExpression;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTNameSpecifier;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTNamedTypeSpecifier;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTParameterDeclaration;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTQualifiedName;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTSimpleTypeTemplateParameter;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTTemplateDeclaration;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTTemplateId;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTTemplateParameter;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTTemplateSpecialization;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTTemplatedTypeTemplateParameter;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPAliasTemplate;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPAliasTemplateInstance;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPBasicType;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPClassScope;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPClassSpecialization;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPClassTemplate;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPClassTemplatePartialSpecialization;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPClassType;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPConstructor;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPConstructorSpecialization;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPEnumeration;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPEnumerationSpecialization;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPField;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPFieldTemplate;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPFunction;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPFunctionInstance;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPFunctionSpecialization;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPFunctionTemplate;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPFunctionType;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPMethod;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPParameter;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPParameterPackType;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPPartialSpecialization;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPPartiallySpecializable;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPPointerToMemberType;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPScope;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPSpecialization;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPTemplateArgument;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPTemplateDefinition;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPTemplateInstance;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPTemplateNonTypeParameter;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPTemplateParameter;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPTemplateParameterMap;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPTemplateTemplateParameter;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPTemplateTypeParameter;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPTypeSpecialization;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPUnaryTypeTransformation;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPUsingDeclaration;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPVariable;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPVariableInstance;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPVariableTemplate;",
                        "import org.eclipse.cdt.core.index.IIndexBinding;",
                        "import org.eclipse.cdt.core.parser.util.ArrayUtil;",
                        "import org.eclipse.cdt.core.parser.util.CharArraySet;",
                        "import org.eclipse.cdt.core.parser.util.ObjectMap;",
                        "import org.eclipse.cdt.internal.core.dom.parser.ASTAmbiguousNode;",
                        "import org.eclipse.cdt.internal.core.dom.parser.ASTInternal;",
                        "import org.eclipse.cdt.internal.core.dom.parser.ASTQueries;",
                        "import org.eclipse.cdt.internal.core.dom.parser.DependentValue;",
                        "import org.eclipse.cdt.internal.core.dom.parser.IASTInternalScope;",
                        "import org.eclipse.cdt.internal.core.dom.parser.ITypeContainer;",
                        "import org.eclipse.cdt.internal.core.dom.parser.IntegralValue;",
                        "import org.eclipse.cdt.internal.core.dom.parser.ProblemBinding;",
                        "import org.eclipse.cdt.internal.core.dom.parser.ProblemFunctionType;",
                        "import org.eclipse.cdt.internal.core.dom.parser.ProblemType;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPASTName;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPASTTranslationUnit;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPAliasTemplateInstance;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPAliasTemplateSpecialization;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPArrayType;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPClassInstance;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPClassSpecialization;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPClassSpecialization.RecursionResolvingBinding;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPClassTemplatePartialSpecialization;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPClassTemplatePartialSpecializationSpecialization;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPClassTemplateSpecialization;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPClosureType;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPConstructorInstance;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPConstructorSpecialization;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPConstructorTemplateSpecialization;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPDeferredClassInstance;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPDeferredFunction;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPDeferredVariableInstance;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPEnumerationSpecialization;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPFieldInstance;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPFieldSpecialization;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPFieldTemplatePartialSpecialization;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPFieldTemplateSpecialization;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPFunctionInstance;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPFunctionSpecialization;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPFunctionTemplateSpecialization;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPFunctionType;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPMethodInstance;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPMethodSpecialization;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPMethodTemplateSpecialization;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPParameterPackType;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPParameterSpecialization;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPPointerToMemberType;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPPointerType;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPTemplateDefinition;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPTemplateNonTypeArgument;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPTemplateNonTypeParameter;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPTemplateNonTypeParameterSpecialization;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPTemplateParameterMap;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPTemplateTemplateParameter;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPTemplateTemplateParameterSpecialization;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPTemplateTypeArgument;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPTemplateTypeParameter;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPTemplateTypeParameterSpecialization;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPTypedefSpecialization;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPUnknownClassInstance;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPUnknownMemberClass;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPUnknownMethod;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPUsingDeclarationSpecialization;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPVariableInstance;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPVariableSpecialization;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPVariableTemplate;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPVariableTemplatePartialSpecialization;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.ICPPASTInternalTemplateDeclaration;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.ICPPComputableFunction;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.ICPPDeferredClassInstance;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.ICPPDeferredVariableInstance;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.ICPPEvaluation;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.ICPPExecution;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.ICPPInstanceCache;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.ICPPInternalBinding;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.ICPPInternalClassTemplate;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.ICPPUnknownBinding;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.ICPPUnknownMember;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.ICPPUnknownMemberClass;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.ICPPUnknownMemberClassInstance;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.ICPPUnknownType;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.InstantiationContext;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.semantics.Conversions.Context;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.semantics.Conversions.UDCMode;",
                        "import org.eclipse.cdt.internal.core.index.IIndexType;",
                        "",
                        "/**",
                        " * Collection of static methods to perform template instantiation, member specialization and",
                        " * type instantiation.",
                        " */",
                        "public class CPPTemplates {",
                        "\t// The three constants below are used as special return values for the various overloads",
                        "\t// of CPPTemplates.determinePackSize() and for ICPPEvaluation.determinePackSize(), which",
                        "\t// search a type, template argument, or value for a usage of a template parameter pack",
                        "\t// and return the number of arguments bound to that parameter pack in an",
                        "\t// ICPPTemplateParameterMap.",
                        "",
                        "\t// Used to indicate that the parameter pack is not bound to any arguments in the",
                        "\t// template parameter map. Computation of the pack size needs to be deferred until",
                        "\t// arguments for it become available.",
                        "\tstatic final int PACK_SIZE_DEFER = -1;",
                        "",
                        "\t// Used to indicate that two different packs with different sizes were found.",
                        "\tstatic final int PACK_SIZE_FAIL = -2;",
                        "",
                        "\t// Used to indicate that no template parameter packs were found.",
                        "\tstatic final int PACK_SIZE_NOT_FOUND = Integer.MAX_VALUE;",
                        "",
                        "\tstatic enum TypeSelection {",
                        "\t\tPARAMETERS, RETURN_TYPE, PARAMETERS_AND_RETURN_TYPE",
                        "\t}",
                        "",
                        "\t// Infrastructure to protect against rogue template metaprograms that don't terminate.",
                        "\tprivate static final int TEMPLATE_INSTANTIATION_DEPTH_LIMIT = 128;",
                        "\tprivate static final ThreadLocal<Integer> fTemplateInstantiationDepth = new ThreadLocal<Integer>() {",
                        "\t\t@Override",
                        "\t\tprotected Integer initialValue() {",
                        "\t\t\treturn 0;",
                        "\t\t}",
                        "\t};",
                        "\tprivate static final ThreadLocal<Set<TypeInstantiationRequest>> instantiationsInProgress = new ThreadLocal<Set<TypeInstantiationRequest>>() {",
                        "\t\t@Override",
                        "\t\tprotected Set<TypeInstantiationRequest> initialValue() {",
                        "\t\t\treturn new HashSet<>();",
                        "\t\t}",
                        "\t};",
                        "",
                        "\t/**",
                        "\t * Instantiates a class or variable template with the given arguments. May return {@code null}.",
                        "\t */",
                        "\tpublic static IBinding instantiate(ICPPPartiallySpecializable template, ICPPTemplateArgument[] args) {",
                        "\t\treturn instantiate(template, args, false, false);",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Instantiates a class template with the given arguments. May return {@code null}.",
                        "\t */",
                        "\tprivate static IBinding instantiate(ICPPPartiallySpecializable template, ICPPTemplateArgument[] args,",
                        "\t\t\tboolean isDefinition, boolean isExplicitSpecialization) {",
                        "\t\ttry {",
                        "\t\t\tICPPTemplateArgument[] arguments = SemanticUtil.getSimplifiedArguments(args);",
                        "\t\t\t// Add default arguments, if necessary.",
                        "\t\t\targuments = addDefaultArguments(template, arguments);",
                        "\t\t\tif (arguments == null)",
                        "\t\t\t\treturn createProblem(template, IProblemBinding.SEMANTIC_INVALID_TEMPLATE_ARGUMENTS);",
                        "",
                        "\t\t\tif (template instanceof ICPPTemplateTemplateParameter || hasDependentArgument(arguments)) {",
                        "\t\t\t\treturn deferredInstance(template, arguments);",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (template instanceof ICPPClassTemplatePartialSpecialization) {",
                        "\t\t\t\treturn instantiatePartialSpecialization((ICPPClassTemplatePartialSpecialization) template, arguments,",
                        "\t\t\t\t\t\tisDefinition, null);",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (arguments == args) {",
                        "\t\t\t\targuments = args.clone(); // The createParameterMap call may modify the arguments array.",
                        "\t\t\t}",
                        "\t\t\tCPPTemplateParameterMap map = createParameterMap(template, arguments);",
                        "\t\t\tif (map == null) {",
                        "\t\t\t\treturn createProblem(template, IProblemBinding.SEMANTIC_INVALID_TEMPLATE_ARGUMENTS);",
                        "\t\t\t}",
                        "",
                        "\t\t\tICPPTemplateInstance prim = getInstance(template, arguments, isDefinition);",
                        "\t\t\tif (prim != null && (isExplicitSpecialization || prim.isExplicitSpecialization()))",
                        "\t\t\t\treturn prim;",
                        "",
                        "\t\t\tif (!isExplicitSpecialization) {",
                        "\t\t\t\tIBinding result = selectSpecialization(template, arguments, isDefinition);",
                        "\t\t\t\tif (result != null)",
                        "\t\t\t\t\treturn result;",
                        "\t\t\t}",
                        "",
                        "\t\t\treturn instantiatePrimaryTemplate(template, arguments, new InstantiationContext(map), isDefinition);",
                        "\t\t} catch (DOMException e) {",
                        "\t\t\treturn e.getProblem();",
                        "\t\t}",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Instantiates an alias template with the given arguments.",
                        "\t */",
                        "\tpublic static IBinding instantiateAliasTemplate(ICPPAliasTemplate aliasTemplate, ICPPTemplateArgument[] args) {",
                        "\t\ttry {",
                        "\t\t\targs = addDefaultArguments(aliasTemplate, args);",
                        "\t\t\tif (args == null) {",
                        "\t\t\t\treturn createProblem(aliasTemplate, IProblemBinding.SEMANTIC_INVALID_TEMPLATE_ARGUMENTS);",
                        "\t\t\t}",
                        "\t\t\tICPPTemplateParameterMap parameterMap = createParameterMap(aliasTemplate, args);",
                        "\t\t\tif (parameterMap == null) {",
                        "\t\t\t\treturn createProblem(aliasTemplate, IProblemBinding.SEMANTIC_INVALID_TEMPLATE_ARGUMENTS);",
                        "\t\t\t}",
                        "\t\t\tIType aliasedType = aliasTemplate.getType();",
                        "\t\t\tIBinding owner = aliasTemplate.getOwner();",
                        "\t\t\treturn createAliasTemplaceInstance(aliasTemplate, args, parameterMap, aliasedType, owner);",
                        "\t\t} catch (DOMException e) {",
                        "\t\t\treturn e.getProblem();",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tprivate static IBinding createProblem(ICPPTemplateDefinition template, int id) {",
                        "\t\treturn new ProblemBinding(CPPSemantics.getCurrentLookupPoint(), id, template.getNameCharArray());",
                        "\t}",
                        "",
                        "\tstatic IBinding isUsedInClassTemplateScope(ICPPClassTemplate ct, IASTName name) {",
                        "\t\ttry {",
                        "\t\t\tIScope scope = null;",
                        "\t\t\tIASTNode node = name;",
                        "\t\t\twhile (node != null) {",
                        "\t\t\t\tif (node.getPropertyInParent() == IASTCompositeTypeSpecifier.TYPE_NAME)",
                        "\t\t\t\t\treturn null;",
                        "\t\t\t\tif (node instanceof IASTFunctionDefinition) {",
                        "\t\t\t\t\tIASTName functionName = ASTQueries",
                        "\t\t\t\t\t\t\t.findInnermostDeclarator(((IASTFunctionDefinition) node).getDeclarator()).getName()",
                        "\t\t\t\t\t\t\t.getLastName();",
                        "\t\t\t\t\t// 'name' may be inside the qualifier of a method name in a out-of-line method definition.",
                        "\t\t\t\t\t// In such a case, calling getContainingScope() on the method name will attempt to",
                        "\t\t\t\t\t// resolve the qualifier, which will attempt to resolve 'name', which will get into",
                        "\t\t\t\t\t// a recursion as 'name' is currently being resolved. Since an out-of-line method",
                        "\t\t\t\t\t// definition cannot be inside a template scope, we can accurately return null",
                        "\t\t\t\t\t// in this case.",
                        "\t\t\t\t\tif (functionName.getParent() instanceof ICPPASTQualifiedName",
                        "\t\t\t\t\t\t\t&& ASTQueries.isAncestorOf(functionName.getParent(), name)) {",
                        "\t\t\t\t\t\treturn null;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t\tscope = CPPVisitor.getContainingScope(functionName);",
                        "\t\t\t\t\tbreak;",
                        "\t\t\t\t}",
                        "\t\t\t\tif (node instanceof ICPPASTCompositeTypeSpecifier) {",
                        "\t\t\t\t\tscope = ((ICPPASTCompositeTypeSpecifier) node).getScope();",
                        "\t\t\t\t\tbreak;",
                        "\t\t\t\t}",
                        "\t\t\t\tnode = node.getParent();",
                        "\t\t\t}",
                        "",
                        "\t\t\twhile (scope != null) {",
                        "\t\t\t\tif (scope instanceof ISemanticProblem)",
                        "\t\t\t\t\treturn null;",
                        "\t\t\t\tif (scope instanceof ICPPClassScope) {",
                        "\t\t\t\t\tICPPClassType b = ((ICPPClassScope) scope).getClassType();",
                        "\t\t\t\t\tif (b != null && ct.isSameType(b)) {",
                        "\t\t\t\t\t\treturn ct;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t\tif (b instanceof ICPPClassTemplatePartialSpecialization) {",
                        "\t\t\t\t\t\tICPPClassTemplatePartialSpecialization pspec = (ICPPClassTemplatePartialSpecialization) b;",
                        "\t\t\t\t\t\tif (ct.isSameType(pspec.getPrimaryClassTemplate())) {",
                        "\t\t\t\t\t\t\treturn pspec;",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t} else if (b instanceof ICPPClassSpecialization) {",
                        "\t\t\t\t\t\tICPPClassSpecialization specialization = (ICPPClassSpecialization) b;",
                        "\t\t\t\t\t\tif (ct.isSameType(specialization.getSpecializedBinding())) {",
                        "\t\t\t\t\t\t\treturn specialization;",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t\tif (scope instanceof IASTInternalScope) {",
                        "\t\t\t\t\tIASTInternalScope internalScope = (IASTInternalScope) scope;",
                        "\t\t\t\t\tIASTNode physicalNode = internalScope.getPhysicalNode();",
                        "\t\t\t\t\tif (physicalNode instanceof ICPPASTCompositeTypeSpecifier",
                        "\t\t\t\t\t\t\t&& ((ICPPASTCompositeTypeSpecifier) physicalNode)",
                        "\t\t\t\t\t\t\t\t\t.getName() instanceof ICPPASTQualifiedName) {",
                        "\t\t\t\t\t\tscope = scope.getParent();",
                        "\t\t\t\t\t} else {",
                        "\t\t\t\t\t\tscope = CPPVisitor.getContainingScope(physicalNode);",
                        "\t\t\t\t\t\tif (scope == internalScope)",
                        "\t\t\t\t\t\t\treturn null;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t} else {",
                        "\t\t\t\t\tscope = scope.getParent();",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t} catch (DOMException e) {",
                        "\t\t}",
                        "\t\treturn null;",
                        "\t}",
                        "",
                        "\tprivate static IBinding instantiateFunctionTemplate(ICPPFunctionTemplate template, ICPPTemplateArgument[] arguments,",
                        "\t\t\tCPPTemplateParameterMap tpMap) throws DOMException {",
                        "\t\tICPPTemplateInstance instance = getInstance(template, arguments, false);",
                        "\t\tif (instance != null) {",
                        "\t\t\treturn instance;",
                        "\t\t}",
                        "",
                        "\t\tIBinding owner = template.getOwner();",
                        "\t\tinstance = createInstance(owner, template, tpMap, arguments);",
                        "\t\tif (instance instanceof ICPPFunction && SemanticUtil.isValidType(((ICPPFunction) instance).getType())) {",
                        "\t\t\taddInstance(template, arguments, instance);",
                        "\t\t}",
                        "\t\treturn instance;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Instantiates a partial class template specialization.",
                        "\t */",
                        "\tprivate static IBinding instantiatePartialSpecialization(ICPPPartialSpecialization partialSpec,",
                        "\t\t\tICPPTemplateArgument[] args, boolean isDef, CPPTemplateParameterMap tpMap) throws DOMException {",
                        "\t\tICPPTemplateInstance instance = getInstance(partialSpec, args, isDef);",
                        "\t\tif (instance != null)",
                        "\t\t\treturn instance;",
                        "",
                        "\t\tif (tpMap == null) {",
                        "\t\t\ttpMap = new CPPTemplateParameterMap(args.length);",
                        "\t\t\tif (!TemplateArgumentDeduction.fromTemplateArguments(partialSpec.getTemplateParameters(),",
                        "\t\t\t\t\tpartialSpec.getTemplateArguments(), args, tpMap)) {",
                        "\t\t\t\treturn null;",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\tinstance = createInstance(partialSpec.getOwner(), partialSpec, tpMap, args);",
                        "\t\taddInstance(partialSpec, args, instance);",
                        "\t\treturn instance;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Instantiates the selected template, without looking for specializations.",
                        "\t * May return {@code null}.",
                        "\t */",
                        "\tprivate static IBinding instantiatePrimaryTemplate(ICPPPartiallySpecializable template,",
                        "\t\t\tICPPTemplateArgument[] arguments, InstantiationContext context, boolean isDef) throws DOMException {",
                        "\t\tassert !(template instanceof ICPPClassTemplatePartialSpecialization);",
                        "\t\tICPPTemplateInstance instance = getInstance(template, arguments, isDef);",
                        "\t\tif (instance != null) {",
                        "\t\t\treturn instance;",
                        "\t\t}",
                        "",
                        "\t\tIBinding owner = template.getOwner();",
                        "\t\tinstance = createInstance(owner, template, context.getParameterMap(), arguments);",
                        "\t\taddInstance(template, arguments, instance);",
                        "\t\treturn instance;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Obtains a cached instance from the template.",
                        "\t */",
                        "\tprivate static ICPPTemplateInstance getInstance(ICPPTemplateDefinition template, ICPPTemplateArgument[] args,",
                        "\t\t\tboolean forDefinition) {",
                        "\t\tif (template instanceof ICPPInstanceCache) {",
                        "\t\t\tICPPTemplateInstance result = ((ICPPInstanceCache) template).getInstance(args);",
                        "\t\t\tif (forDefinition && result instanceof IIndexBinding)",
                        "\t\t\t\treturn null;",
                        "\t\t\tif (result != null && !result.isExplicitSpecialization()) {",
                        "\t\t\t\t// Don't use the cached instance if its argument is an index type and the requested",
                        "\t\t\t\t// argument is an AST type. Despite identical signatures the types may be different.",
                        "\t\t\t\tICPPTemplateArgument[] instanceArgs = result.getTemplateArguments();",
                        "\t\t\t\tfor (int i = 0; i < args.length; i++) {",
                        "\t\t\t\t\tif (!(args[i].getTypeValue() instanceof IIndexType)",
                        "\t\t\t\t\t\t\t&& (instanceArgs[i].getTypeValue() instanceof IIndexType)) {",
                        "\t\t\t\t\t\treturn null;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t\treturn result;",
                        "\t\t}",
                        "\t\treturn null;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Caches an instance with the template.",
                        "\t */",
                        "\tprivate static void addInstance(ICPPTemplateDefinition template, ICPPTemplateArgument[] args,",
                        "\t\t\tICPPTemplateInstance instance) {",
                        "\t\tif (template instanceof ICPPInstanceCache) {",
                        "\t\t\t((ICPPInstanceCache) template).addInstance(args, instance);",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tprivate static IBinding deferredInstance(ICPPPartiallySpecializable template, ICPPTemplateArgument[] arguments)",
                        "\t\t\tthrows DOMException {",
                        "\t\tICPPTemplateInstance instance = getInstance(template, arguments, false);",
                        "\t\tif (instance != null)",
                        "\t\t\treturn instance;",
                        "",
                        "\t\tif (template instanceof ICPPClassTemplate) {",
                        "\t\t\tinstance = new CPPDeferredClassInstance((ICPPClassTemplate) template, arguments);",
                        "\t\t\taddInstance(template, arguments, instance);",
                        "\t\t}",
                        "\t\tif (template instanceof ICPPVariableTemplate) {",
                        "\t\t\tinstance = new CPPDeferredVariableInstance((ICPPVariableTemplate) template, arguments);",
                        "\t\t\taddInstance(template, arguments, instance);",
                        "\t\t}",
                        "\t\treturn instance;",
                        "\t}",
                        "",
                        "\tprivate static ICPPTemplateArgument[] addDefaultArguments(ICPPTemplateDefinition template,",
                        "\t\t\tICPPTemplateArgument[] arguments) throws DOMException {",
                        "\t\tif (template instanceof ICPPClassTemplatePartialSpecialization)",
                        "\t\t\treturn arguments;",
                        "",
                        "\t\tboolean havePackExpansion = false;",
                        "\t\tfor (int i = 0; i < arguments.length; i++) {",
                        "\t\t\tICPPTemplateArgument arg = arguments[i];",
                        "\t\t\tif (arg.isPackExpansion()) {",
                        "\t\t\t\tif (i != arguments.length - 1) {",
                        "\t\t\t\t\treturn arguments;",
                        "\t\t\t\t}",
                        "\t\t\t\thavePackExpansion = true;",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\tICPPTemplateParameter[] tpars = template.getTemplateParameters();",
                        "\t\tint tparCount = tpars.length;",
                        "\t\tfinal int argCount = arguments.length;",
                        "",
                        "\t\tif (tparCount == argCount)",
                        "\t\t\treturn arguments;",
                        "",
                        "\t\tif (tparCount == 0)",
                        "\t\t\treturn null;",
                        "",
                        "\t\t// More arguments allowed if we have a parameter pack.",
                        "\t\tif (tparCount < argCount) {",
                        "\t\t\tif (tpars[tparCount - 1].isParameterPack())",
                        "\t\t\t\treturn arguments;",
                        "",
                        "\t\t\tif (havePackExpansion && tparCount + 1 == argCount)",
                        "\t\t\t\treturn arguments;",
                        "\t\t\treturn null;",
                        "\t\t}",
                        "",
                        "\t\t// Fewer arguments are allowed with a pack expansion",
                        "\t\tif (havePackExpansion)",
                        "\t\t\treturn arguments;",
                        "",
                        "\t\t// Fewer arguments are allowed with\tdefault arguments",
                        "\t\tif (tpars[tparCount - 1].isParameterPack())",
                        "\t\t\ttparCount--;",
                        "",
                        "\t\tif (tparCount == argCount)",
                        "\t\t\treturn arguments;",
                        "",
                        "\t\tICPPTemplateArgument[] completeArgs = new ICPPTemplateArgument[tparCount];",
                        "\t\tCPPTemplateParameterMap map = new CPPTemplateParameterMap(tparCount);",
                        "\t\tInstantiationContext context = new InstantiationContext(map);",
                        "\t\tfor (int i = 0; i < tparCount; i++) {",
                        "\t\t\tfinal ICPPTemplateParameter tpar = tpars[i];",
                        "\t\t\tif (tpar.isParameterPack()) {",
                        "\t\t\t\t// Parameter pack must be last template parameter.",
                        "\t\t\t\treturn null;",
                        "\t\t\t}",
                        "\t\t\tICPPTemplateArgument arg;",
                        "\t\t\tif (i < argCount) {",
                        "\t\t\t\targ = arguments[i];",
                        "\t\t\t} else {",
                        "\t\t\t\tICPPTemplateArgument defaultArg = tpar.getDefaultValue();",
                        "\t\t\t\tif (defaultArg == null) {",
                        "\t\t\t\t\tif (template instanceof ICPPInternalClassTemplate) {",
                        "\t\t\t\t\t\tdefaultArg = ((ICPPInternalClassTemplate) template).getDefaultArgFromIndex(i);",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t\tif (defaultArg == null)",
                        "\t\t\t\t\treturn null;",
                        "\t\t\t\targ = instantiateArgument(defaultArg, context);",
                        "\t\t\t\targ = SemanticUtil.getSimplifiedArgument(arg);",
                        "\t\t\t\tif (!isValidArgument(arg)) {",
                        "\t\t\t\t\treturn null;",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t\tcontext.addToParameterMap(tpar, arg);",
                        "\t\t\tcompleteArgs[i] = arg;",
                        "\t\t}",
                        "\t\treturn completeArgs;",
                        "\t}",
                        "",
                        "\tpublic static ICPPDeferredClassInstance createDeferredInstance(ICPPClassTemplate ct) {",
                        "\t\tICPPTemplateArgument[] args;",
                        "\t\tif (ct instanceof ICPPClassTemplatePartialSpecialization) {",
                        "\t\t\targs = ((ICPPClassTemplatePartialSpecialization) ct).getTemplateArguments();",
                        "\t\t} else {",
                        "\t\t\targs = templateParametersAsArguments(ct);",
                        "\t\t}",
                        "\t\treturn new CPPDeferredClassInstance(ct, args, (ICPPScope) ct.getCompositeScope());",
                        "\t}",
                        "",
                        "\tpublic static ICPPTemplateArgument[] templateParametersAsArguments(ICPPClassTemplate template) {",
                        "\t\tICPPTemplateParameter[] tpars = template.getTemplateParameters();",
                        "\t\tICPPTemplateArgument[] args;",
                        "\t\targs = new ICPPTemplateArgument[tpars.length];",
                        "\t\tfor (int i = 0; i < tpars.length; i++) {",
                        "\t\t\tfinal ICPPTemplateParameter tp = tpars[i];",
                        "\t\t\tif (tp instanceof IType) {",
                        "\t\t\t\tIType t = (IType) tp;",
                        "\t\t\t\tif (tp.isParameterPack()) {",
                        "\t\t\t\t\tt = new CPPParameterPackType(t);",
                        "\t\t\t\t}",
                        "\t\t\t\targs[i] = new CPPTemplateTypeArgument(t);",
                        "\t\t\t} else if (tp instanceof ICPPTemplateNonTypeParameter) {",
                        "\t\t\t\t// Non-type template parameter pack already has type 'ICPPParameterPackType'",
                        "\t\t\t\tfinal ICPPTemplateNonTypeParameter nttp = (ICPPTemplateNonTypeParameter) tp;",
                        "\t\t\t\targs[i] = new CPPTemplateNonTypeArgument(DependentValue.create(template, nttp), nttp.getType());",
                        "\t\t\t} else {",
                        "\t\t\t\tassert false;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\treturn args;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Extracts the IASTName of a template parameter.",
                        "\t */",
                        "\tpublic static IASTName getTemplateParameterName(ICPPASTTemplateParameter param) {",
                        "\t\tif (param instanceof ICPPASTSimpleTypeTemplateParameter)",
                        "\t\t\treturn ((ICPPASTSimpleTypeTemplateParameter) param).getName();",
                        "\t\telse if (param instanceof ICPPASTTemplatedTypeTemplateParameter)",
                        "\t\t\treturn ((ICPPASTTemplatedTypeTemplateParameter) param).getName();",
                        "\t\telse if (param instanceof ICPPASTParameterDeclaration)",
                        "\t\t\treturn ASTQueries.findInnermostDeclarator(((ICPPASTParameterDeclaration) param).getDeclarator()).getName();",
                        "\t\treturn null;",
                        "\t}",
                        "",
                        "\tpublic static ICPPTemplateDefinition getContainingTemplate(ICPPASTTemplateParameter param) {",
                        "\t\tIASTNode parent = param.getParent();",
                        "\t\tIBinding binding = null;",
                        "\t\tif (parent instanceof ICPPASTTemplateDeclaration) {",
                        "\t\t\tICPPASTTemplateDeclaration[] templates = new ICPPASTTemplateDeclaration[] {",
                        "\t\t\t\t\t(ICPPASTTemplateDeclaration) parent };",
                        "",
                        "\t\t\twhile (parent.getParent() instanceof ICPPASTTemplateDeclaration) {",
                        "\t\t\t\tparent = parent.getParent();",
                        "\t\t\t\ttemplates = ArrayUtil.append(ICPPASTTemplateDeclaration.class, templates,",
                        "\t\t\t\t\t\t(ICPPASTTemplateDeclaration) parent);",
                        "\t\t\t}",
                        "\t\t\ttemplates = ArrayUtil.trim(ICPPASTTemplateDeclaration.class, templates);",
                        "",
                        "\t\t\tICPPASTTemplateDeclaration templateDeclaration = templates[0];",
                        "\t\t\tIASTDeclaration decl = templateDeclaration.getDeclaration();",
                        "\t\t\twhile (decl instanceof ICPPASTTemplateDeclaration) {",
                        "\t\t\t\tdecl = ((ICPPASTTemplateDeclaration) decl).getDeclaration();",
                        "\t\t\t}",
                        "",
                        "\t\t\tIASTName name = null;",
                        "\t\t\tif (decl instanceof IASTSimpleDeclaration) {",
                        "\t\t\t\tIASTSimpleDeclaration simpleDecl = (IASTSimpleDeclaration) decl;",
                        "\t\t\t\tIASTDeclarator[] dtors = ((IASTSimpleDeclaration) decl).getDeclarators();",
                        "\t\t\t\tif (dtors.length == 0) {",
                        "\t\t\t\t\tIASTDeclSpecifier spec = simpleDecl.getDeclSpecifier();",
                        "\t\t\t\t\tif (spec instanceof ICPPASTCompositeTypeSpecifier) {",
                        "\t\t\t\t\t\tname = ((ICPPASTCompositeTypeSpecifier) spec).getName();",
                        "\t\t\t\t\t} else if (spec instanceof ICPPASTElaboratedTypeSpecifier) {",
                        "\t\t\t\t\t\tname = ((ICPPASTElaboratedTypeSpecifier) spec).getName();",
                        "\t\t\t\t\t}",
                        "\t\t\t\t} else {",
                        "\t\t\t\t\tIASTDeclarator dtor = dtors[0];",
                        "\t\t\t\t\tdtor = ASTQueries.findInnermostDeclarator(dtor);",
                        "\t\t\t\t\tname = dtor.getName();",
                        "\t\t\t\t}",
                        "\t\t\t} else if (decl instanceof IASTFunctionDefinition) {",
                        "\t\t\t\tIASTDeclarator dtor = ((IASTFunctionDefinition) decl).getDeclarator();",
                        "\t\t\t\tdtor = ASTQueries.findInnermostDeclarator(dtor);",
                        "\t\t\t\tname = dtor.getName();",
                        "\t\t\t} else if (decl instanceof ICPPASTAliasDeclaration) {",
                        "\t\t\t\tname = ((ICPPASTAliasDeclaration) decl).getAlias();",
                        "\t\t\t}",
                        "\t\t\tif (name == null)",
                        "\t\t\t\treturn null;",
                        "",
                        "\t\t\tif (name instanceof ICPPASTQualifiedName) {",
                        "\t\t\t\tint idx = templates.length;",
                        "\t\t\t\tint i = 0;",
                        "\t\t\t\tICPPASTNameSpecifier[] qualifier = ((ICPPASTQualifiedName) name).getQualifier();",
                        "\t\t\t\tfor (ICPPASTNameSpecifier element : qualifier) {",
                        "\t\t\t\t\tif (element instanceof ICPPASTTemplateId) {",
                        "\t\t\t\t\t\t++i;",
                        "\t\t\t\t\t\tif (i == idx) {",
                        "\t\t\t\t\t\t\tbinding = ((ICPPASTTemplateId) element).resolveBinding();",
                        "\t\t\t\t\t\t\tbreak;",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t\tif (binding == null)",
                        "\t\t\t\t\tbinding = name.getLastName().resolveBinding();",
                        "\t\t\t} else {",
                        "\t\t\t\tbinding = name.resolveBinding();",
                        "\t\t\t}",
                        "\t\t} else if (parent instanceof ICPPASTTemplatedTypeTemplateParameter) {",
                        "\t\t\tICPPASTTemplatedTypeTemplateParameter templatedParam = (ICPPASTTemplatedTypeTemplateParameter) parent;",
                        "\t\t\tbinding = templatedParam.getName().resolveBinding();",
                        "\t\t}",
                        "\t\treturn (binding instanceof ICPPTemplateDefinition) ? (ICPPTemplateDefinition) binding : null;",
                        "\t}",
                        "",
                        "\tpublic static IBinding createBinding(ICPPASTTemplateParameter tp) {",
                        "\t\tif (tp instanceof ICPPASTSimpleTypeTemplateParameter) {",
                        "\t\t\treturn new CPPTemplateTypeParameter(((ICPPASTSimpleTypeTemplateParameter) tp).getName(),",
                        "\t\t\t\t\ttp.isParameterPack());",
                        "\t\t}",
                        "\t\tif (tp instanceof ICPPASTTemplatedTypeTemplateParameter) {",
                        "\t\t\treturn new CPPTemplateTemplateParameter(((ICPPASTTemplatedTypeTemplateParameter) tp).getName(),",
                        "\t\t\t\t\ttp.isParameterPack());",
                        "\t\t}",
                        "\t\tassert tp instanceof ICPPASTParameterDeclaration;",
                        "\t\tfinal IASTDeclarator dtor = ((ICPPASTParameterDeclaration) tp).getDeclarator();",
                        "\t\treturn new CPPTemplateNonTypeParameter(ASTQueries.findInnermostDeclarator(dtor).getName());",
                        "\t}",
                        "",
                        "\tpublic static IBinding createBinding(ICPPASTTemplateId id) {",
                        "\t\tif (!isClassTemplate(id)) {",
                        "\t\t\t// Functions are instantiated as part of the resolution process.",
                        "\t\t\tIBinding result = CPPVisitor.createBinding(id);",
                        "\t\t\tIASTName templateName = id.getTemplateName();",
                        "\t\t\tif (result instanceof ICPPClassTemplate || result instanceof ICPPAliasTemplate",
                        "\t\t\t\t\t|| result instanceof ICPPVariableTemplate) {",
                        "\t\t\t\ttemplateName.setBinding(result);",
                        "\t\t\t\tid.setBinding(null);",
                        "\t\t\t} else {",
                        "\t\t\t\tif (result instanceof ICPPTemplateInstance) {",
                        "\t\t\t\t\ttemplateName.setBinding(((ICPPTemplateInstance) result).getTemplateDefinition());",
                        "\t\t\t\t} else {",
                        "\t\t\t\t\ttemplateName.setBinding(result);",
                        "\t\t\t\t}",
                        "\t\t\t\treturn result;",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\tIASTNode parentOfName = id.getParent();",
                        "\t\tboolean isLastName = true;",
                        "\t\tif (parentOfName instanceof ICPPASTQualifiedName) {",
                        "\t\t\tisLastName = ((ICPPASTQualifiedName) parentOfName).getLastName() == id;",
                        "\t\t\tparentOfName = parentOfName.getParent();",
                        "\t\t}",
                        "",
                        "\t\tboolean isDeclaration = false;",
                        "\t\tboolean isDefinition = false;",
                        "\t\tboolean isExplicitSpecialization = false;",
                        "\t\tif (isLastName && parentOfName != null) {",
                        "\t\t\tIASTNode declaration = parentOfName.getParent();",
                        "\t\t\tif (declaration instanceof IASTSimpleDeclaration) {",
                        "\t\t\t\tif (parentOfName instanceof ICPPASTElaboratedTypeSpecifier) {",
                        "\t\t\t\t\tisDeclaration = true;",
                        "\t\t\t\t} else if (parentOfName instanceof ICPPASTCompositeTypeSpecifier) {",
                        "\t\t\t\t\tisDefinition = true;",
                        "\t\t\t\t} else if (parentOfName instanceof ICPPASTDeclarator) {",
                        "\t\t\t\t\tisDeclaration = true;",
                        "\t\t\t\t}",
                        "\t\t\t\tif (isDeclaration || isDefinition) {",
                        "\t\t\t\t\tIASTNode parentOfDeclaration = declaration.getParent();",
                        "\t\t\t\t\tif (parentOfDeclaration instanceof ICPPASTExplicitTemplateInstantiation) {",
                        "\t\t\t\t\t\tisDeclaration = false;",
                        "\t\t\t\t\t} else if (parentOfDeclaration instanceof ICPPASTTemplateSpecialization) {",
                        "\t\t\t\t\t\tisExplicitSpecialization = true;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\tCPPSemantics.pushLookupPoint(id);",
                        "\t\ttry {",
                        "\t\t\tIBinding result = null;",
                        "\t\t\tIASTName templateName = id.getTemplateName();",
                        "\t\t\tIBinding template = templateName.resolvePreBinding();",
                        "",
                        "\t\t\twhile (template instanceof CPPTypedefSpecialization) {",
                        "\t\t\t\ttemplate = ((CPPTypedefSpecialization) template).getSpecializedBinding();",
                        "\t\t\t}",
                        "",
                        "\t\t\t// Alias template.",
                        "\t\t\tif (template instanceof ICPPAliasTemplate) {",
                        "\t\t\t\tICPPAliasTemplate aliasTemplate = (ICPPAliasTemplate) template;",
                        "\t\t\t\tICPPTemplateArgument[] args = createTemplateArgumentArray(id);",
                        "\t\t\t\treturn instantiateAliasTemplate(aliasTemplate, args);",
                        "\t\t\t}",
                        "",
                        "\t\t\t// Class or variable template.",
                        "\t\t\tif (template instanceof ICPPConstructor) {",
                        "\t\t\t\ttemplate = template.getOwner();",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (template instanceof ICPPUnknownMemberClass) {",
                        "\t\t\t\tIType owner = ((ICPPUnknownMemberClass) template).getOwnerType();",
                        "\t\t\t\tICPPTemplateArgument[] args = createTemplateArgumentArray(id);",
                        "\t\t\t\targs = SemanticUtil.getSimplifiedArguments(args);",
                        "\t\t\t\treturn new CPPUnknownClassInstance(owner, id.getSimpleID(), args);",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (!(template instanceof ICPPPartiallySpecializable)",
                        "\t\t\t\t\t|| template instanceof ICPPClassTemplatePartialSpecialization)",
                        "\t\t\t\treturn new ProblemBinding(id, IProblemBinding.SEMANTIC_INVALID_TYPE, templateName.toCharArray());",
                        "",
                        "\t\t\tfinal ICPPPartiallySpecializable classTemplate = (ICPPPartiallySpecializable) template;",
                        "\t\t\tICPPTemplateArgument[] args = createTemplateArgumentArray(id);",
                        "\t\t\tif (hasDependentArgument(args)) {",
                        "\t\t\t\tICPPASTTemplateDeclaration tdecl = getTemplateDeclaration(id);",
                        "\t\t\t\tif (tdecl != null) {",
                        "\t\t\t\t\tif (argsAreTrivial(classTemplate.getTemplateParameters(), args)) {",
                        "\t\t\t\t\t\tresult = classTemplate;",
                        "\t\t\t\t\t} else {",
                        "\t\t\t\t\t\targs = addDefaultArguments(classTemplate, args);",
                        "\t\t\t\t\t\tif (args == null) {",
                        "\t\t\t\t\t\t\treturn new ProblemBinding(id, IProblemBinding.SEMANTIC_INVALID_TEMPLATE_ARGUMENTS,",
                        "\t\t\t\t\t\t\t\t\ttemplateName.toCharArray());",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t\tICPPPartialSpecialization partialSpec = findPartialSpecialization(classTemplate, args);",
                        "\t\t\t\t\t\tICPPClassTemplatePartialSpecialization indexSpec = null;",
                        "\t\t\t\t\t\tif ((isDeclaration || isDefinition)",
                        "\t\t\t\t\t\t\t\t&& (partialSpec instanceof ICPPClassTemplatePartialSpecialization)) {",
                        "\t\t\t\t\t\t\tindexSpec = (ICPPClassTemplatePartialSpecialization) partialSpec;",
                        "\t\t\t\t\t\t\tpartialSpec = null;",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t\tif (partialSpec == null) {",
                        "\t\t\t\t\t\t\tif (isDeclaration || isDefinition) {",
                        "\t\t\t\t\t\t\t\tif (template instanceof ICPPClassTemplate) {",
                        "\t\t\t\t\t\t\t\t\tpartialSpec = new CPPClassTemplatePartialSpecialization(id, args);",
                        "\t\t\t\t\t\t\t\t\tif (indexSpec != null) {",
                        "\t\t\t\t\t\t\t\t\t\tSemanticUtil.recordPartialSpecialization(indexSpec,",
                        "\t\t\t\t\t\t\t\t\t\t\t\t(ICPPClassTemplatePartialSpecialization) partialSpec, id);",
                        "\t\t\t\t\t\t\t\t\t} else if (template instanceof ICPPInternalClassTemplate) {",
                        "\t\t\t\t\t\t\t\t\t\t((ICPPInternalClassTemplate) template).addPartialSpecialization(",
                        "\t\t\t\t\t\t\t\t\t\t\t\t(ICPPClassTemplatePartialSpecialization) partialSpec);",
                        "\t\t\t\t\t\t\t\t\t}",
                        "\t\t\t\t\t\t\t\t} else if (template instanceof ICPPVariableTemplate) {",
                        "\t\t\t\t\t\t\t\t\tif (template instanceof ICPPFieldTemplate) {",
                        "\t\t\t\t\t\t\t\t\t\tpartialSpec = new CPPFieldTemplatePartialSpecialization(id, args);",
                        "\t\t\t\t\t\t\t\t\t} else {",
                        "\t\t\t\t\t\t\t\t\t\tpartialSpec = new CPPVariableTemplatePartialSpecialization(id, args);",
                        "\t\t\t\t\t\t\t\t\t}",
                        "\t\t\t\t\t\t\t\t\tif (template instanceof CPPVariableTemplate)",
                        "\t\t\t\t\t\t\t\t\t\t((CPPVariableTemplate) template).addPartialSpecialization(partialSpec);",
                        "\t\t\t\t\t\t\t\t}",
                        "\t\t\t\t\t\t\t\treturn partialSpec;",
                        "\t\t\t\t\t\t\t}",
                        "\t\t\t\t\t\t\treturn new ProblemBinding(id, IProblemBinding.SEMANTIC_INVALID_TYPE,",
                        "\t\t\t\t\t\t\t\t\ttemplateName.toCharArray());",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t\tresult = partialSpec;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t\tif (result == null) {",
                        "\t\t\t\tresult = instantiate(classTemplate, args, isDefinition, isExplicitSpecialization);",
                        "\t\t\t\tif (result instanceof ICPPInternalBinding) {",
                        "\t\t\t\t\tif (isDeclaration) {",
                        "\t\t\t\t\t\tASTInternal.addDeclaration(result, id);",
                        "\t\t\t\t\t} else if (isDefinition) {",
                        "\t\t\t\t\t\tASTInternal.addDefinition(result, id);",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t\treturn CPPSemantics.postResolution(result, id);",
                        "\t\t} catch (DOMException e) {",
                        "\t\t\treturn e.getProblem();",
                        "\t\t} finally {",
                        "\t\t\tCPPSemantics.popLookupPoint();",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tprivate static IBinding createAliasTemplaceInstance(ICPPAliasTemplate aliasTemplate, ICPPTemplateArgument[] args,",
                        "\t\t\tICPPTemplateParameterMap parameterMap, IType aliasedType, IBinding owner) {",
                        "\t\tInstantiationContext context = createInstantiationContext(parameterMap, owner);",
                        "\t\tIType instantiatedType = instantiateType(aliasedType, context);",
                        "\t\treturn new CPPAliasTemplateInstance(aliasTemplate, instantiatedType, owner, parameterMap, args);",
                        "\t}",
                        "",
                        "\tstatic boolean isClassTemplate(ICPPASTTemplateId id) {",
                        "\t\tIASTNode parentOfName = id.getParent();",
                        "",
                        "\t\tif (parentOfName instanceof ICPPASTQualifiedName) {",
                        "\t\t\tif (((ICPPASTQualifiedName) parentOfName).getLastName() != id)",
                        "\t\t\t\treturn true;",
                        "\t\t\tparentOfName = parentOfName.getParent();",
                        "\t\t}",
                        "",
                        "\t\tif (parentOfName instanceof ICPPASTElaboratedTypeSpecifier",
                        "\t\t\t\t|| parentOfName instanceof ICPPASTCompositeTypeSpecifier",
                        "\t\t\t\t|| parentOfName instanceof ICPPASTNamedTypeSpecifier || parentOfName instanceof ICPPASTBaseSpecifier) {",
                        "\t\t\treturn true;",
                        "\t\t}",
                        "",
                        "\t\tif (parentOfName instanceof IASTDeclarator) {",
                        "\t\t\tIASTDeclarator rel = ASTQueries.findTypeRelevantDeclarator((IASTDeclarator) parentOfName);",
                        "\t\t\treturn !(rel instanceof IASTFunctionDeclarator);",
                        "\t\t}",
                        "\t\treturn false;",
                        "\t}",
                        "",
                        "\tpublic static ICPPTemplateInstance createInstance(IBinding owner, ICPPTemplateDefinition template,",
                        "\t\t\tICPPTemplateParameterMap tpMap, ICPPTemplateArgument[] args) {",
                        "\t\tif (owner instanceof ICPPSpecialization) {",
                        "\t\t\tICPPTemplateParameterMap map = ((ICPPSpecialization) owner).getTemplateParameterMap();",
                        "\t\t\tif (map != null) {",
                        "\t\t\t\t((CPPTemplateParameterMap) tpMap).putAll(map);",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\tICPPTemplateInstance instance = null;",
                        "\t\tif (template instanceof ICPPClassType) {",
                        "\t\t\tinstance = new CPPClassInstance((ICPPClassType) template, owner, tpMap, args);",
                        "\t\t} else if (template instanceof ICPPFunction) {",
                        "\t\t\tICPPFunction func = (ICPPFunction) template;",
                        "\t\t\tInstantiationContext context = createInstantiationContext(tpMap, owner);",
                        "\t\t\tICPPFunctionType type = (ICPPFunctionType) instantiateType(func.getType(), context);",
                        "\t\t\tIType[] exceptionSpecs = instantiateTypes(func.getExceptionSpecification(), context);",
                        "\t\t\tCPPFunctionSpecialization spec;",
                        "\t\t\tif (owner instanceof ICPPClassType && template instanceof ICPPMethod) {",
                        "\t\t\t\tif (template instanceof ICPPConstructor) {",
                        "\t\t\t\t\tspec = new CPPConstructorInstance((ICPPConstructor) template, (ICPPClassType) owner,",
                        "\t\t\t\t\t\t\tcontext.getParameterMap(), args, type, exceptionSpecs);",
                        "\t\t\t\t} else {",
                        "\t\t\t\t\tspec = new CPPMethodInstance((ICPPMethod) template, (ICPPClassType) owner,",
                        "\t\t\t\t\t\t\tcontext.getParameterMap(), args, type, exceptionSpecs);",
                        "\t\t\t\t}",
                        "\t\t\t} else {",
                        "\t\t\t\tspec = new CPPFunctionInstance((ICPPFunction) template, owner, tpMap, args, type, exceptionSpecs);",
                        "\t\t\t}",
                        "\t\t\tspec.setParameters(",
                        "\t\t\t\t\tspecializeParameters(func.getParameters(), spec, context, IntegralValue.MAX_RECURSION_DEPTH));",
                        "\t\t\tinstance = (ICPPTemplateInstance) spec;",
                        "\t\t} else if (template instanceof ICPPVariable) {",
                        "\t\t\tICPPVariable var = (ICPPVariable) template;",
                        "\t\t\tInstantiationContext context = createInstantiationContext(tpMap, owner);",
                        "\t\t\tIType type = instantiateType(var.getType(), context);",
                        "",
                        "\t\t\tIValue value;",
                        "\t\t\tIASTNode point = CPPSemantics.getCurrentLookupPoint();",
                        "\t\t\tICPPASTDeclarator decl = ASTQueries.findAncestorWithType(point, ICPPASTDeclarator.class);",
                        "\t\t\tif (point instanceof IASTName && ((IASTName) point).getRoleOfName(false) == IASTNameOwner.r_definition",
                        "\t\t\t\t\t&& decl != null && decl.getInitializer() != null) {",
                        "\t\t\t\t// Explicit specialization.",
                        "\t\t\t\tvalue = SemanticUtil.getValueOfInitializer(decl.getInitializer(), type);",
                        "\t\t\t} else {",
                        "\t\t\t\tvalue = instantiateValue(var.getInitialValue(), context, IntegralValue.MAX_RECURSION_DEPTH);",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (template instanceof ICPPField) {",
                        "\t\t\t\tinstance = new CPPFieldInstance(template, owner, tpMap, args, type, value);",
                        "\t\t\t} else {",
                        "\t\t\t\tinstance = new CPPVariableInstance(template, owner, tpMap, args, type, value);",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\treturn instance;",
                        "\t}",
                        "",
                        "\tpublic static ICPPParameter[] specializeParameters(ICPPParameter[] parameters, ICPPFunction functionSpec,",
                        "\t\t\tInstantiationContext context, int maxdepth) {",
                        "\t\tif (parameters.length == 0) {",
                        "\t\t\treturn parameters;",
                        "\t\t}",
                        "",
                        "\t\t// Because of parameter packs there can be more or less parameters in the specialization",
                        "\t\tIType[] specializedParameterTypes = functionSpec.getType().getParameterTypes();",
                        "\t\tfinal int length = specializedParameterTypes.length;",
                        "\t\tICPPParameter par = null;",
                        "\t\tICPPParameter[] result = new ICPPParameter[length];",
                        "\t\tfor (int i = 0; i < length; i++) {",
                        "\t\t\tif (i < parameters.length) {",
                        "\t\t\t\tpar = parameters[i];",
                        "\t\t\t} // else reuse last parameter (which should be a pack)",
                        "\t\t\t@SuppressWarnings(\"null\")",
                        "\t\t\tIValue defaultValue = par.getDefaultValue();",
                        "\t\t\tIValue specializedValue = instantiateValue(defaultValue, context, maxdepth);",
                        "\t\t\tresult[i] = new CPPParameterSpecialization(par, functionSpec, specializedParameterTypes[i],",
                        "\t\t\t\t\tspecializedValue, context.getParameterMap());",
                        "\t\t}",
                        "\t\treturn result;",
                        "\t}",
                        "",
                        "\t// TODO(nathanridge): Handle this as a case in createSpecialization()",
                        "\tpublic static ICPPVariable createVariableSpecialization(InstantiationContext context, ICPPVariable variable) {",
                        "\t\tfinal IType type = variable.getType();",
                        "\t\tfinal IType newType = instantiateType(type, context);",
                        "\t\tfinal IValue value = variable.getInitialValue();",
                        "\t\tfinal IValue newValue = instantiateValue(value, context, IntegralValue.MAX_RECURSION_DEPTH);",
                        "\t\tif (type == newType && value == newValue) {",
                        "\t\t\treturn variable;",
                        "\t\t}",
                        "\t\tICPPVariable newVariable = new CPPVariableSpecialization(variable, context.getContextSpecialization(),",
                        "\t\t\t\tcontext.getParameterMap(), newType, newValue);",
                        "\t\tcontext.putInstantiatedLocal(variable, newVariable);",
                        "\t\treturn newVariable;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * IMPORTANT: Do NOT call this method directly, at least when (owner instanceof ICPPClassSpecialization).",
                        "\t *            Use ICPPClassSpecialization.specializeMember(decl) instead.",
                        "\t *",
                        "\t *            This ensures that the caching mechanism for member specializations implemented by",
                        "\t *            ICPPClassSpecialization.specializeMember() is not bypassed.",
                        "\t *",
                        "\t * TODO: Implement a caching mechanism for non-class owners, too, and make specializeMember()",
                        "\t *       a method of ICPPSpecialization itself.",
                        "\t */",
                        "\tpublic static IBinding createSpecialization(ICPPSpecialization owner, IBinding decl) {",
                        "\t\tIBinding spec = null;",
                        "\t\tfinal ICPPTemplateParameterMap tpMap = owner.getTemplateParameterMap();",
                        "\t\tfinal ICPPClassSpecialization classOwner = (owner instanceof ICPPClassSpecialization)",
                        "\t\t\t\t? (ICPPClassSpecialization) owner",
                        "\t\t\t\t: null;",
                        "",
                        "\t\t// Guard against infinite recursion during template instantiation with a depth limit.",
                        "\t\tint instantiationDepth = fTemplateInstantiationDepth.get();",
                        "\t\tif (instantiationDepth > TEMPLATE_INSTANTIATION_DEPTH_LIMIT) {",
                        "\t\t\treturn RecursionResolvingBinding.createFor(decl);",
                        "\t\t}",
                        "\t\t// Increment the instantiation depth for the duration of this call.",
                        "\t\tfTemplateInstantiationDepth.set(instantiationDepth + 1);",
                        "",
                        "\t\ttry {",
                        "\t\t\tif (decl instanceof ICPPClassTemplatePartialSpecialization && classOwner != null) {",
                        "\t\t\t\ttry {",
                        "\t\t\t\t\tICPPClassTemplatePartialSpecialization pspec = (ICPPClassTemplatePartialSpecialization) decl;",
                        "\t\t\t\t\tICPPClassTemplate template = pspec.getPrimaryClassTemplate();",
                        "\t\t\t\t\tICPPTemplateArgument[] args = pspec.getTemplateArguments();",
                        "",
                        "\t\t\t\t\ttemplate = (ICPPClassTemplate) classOwner.specializeMember(template);",
                        "\t\t\t\t\tInstantiationContext context = createInstantiationContext(tpMap, owner);",
                        "\t\t\t\t\targs = instantiateArguments(args, context, false);",
                        "\t\t\t\t\tspec = new CPPClassTemplatePartialSpecializationSpecialization(pspec, tpMap, template, args);",
                        "\t\t\t\t} catch (DOMException e) {",
                        "\t\t\t\t}",
                        "\t\t\t} else if (decl instanceof ICPPClassTemplate && classOwner != null) {",
                        "\t\t\t\tICPPClassTemplate template = (ICPPClassTemplate) decl;",
                        "\t\t\t\tCPPClassTemplateSpecialization classTemplateSpec = new CPPClassTemplateSpecialization(template,",
                        "\t\t\t\t\t\tclassOwner, tpMap);",
                        "\t\t\t\tclassTemplateSpec.setTemplateParameters(specializeTemplateParameters(classTemplateSpec,",
                        "\t\t\t\t\t\t(ICPPScope) classTemplateSpec.getScope(), template.getTemplateParameters(), classOwner));",
                        "\t\t\t\tspec = classTemplateSpec;",
                        "\t\t\t} else if (decl instanceof ICPPClassType && classOwner != null) {",
                        "\t\t\t\t// TODO: Handle local classes",
                        "\t\t\t\tIBinding oldOwner = decl.getOwner();",
                        "\t\t\t\tif (oldOwner instanceof IType && classOwner.getSpecializedBinding().isSameType((IType) oldOwner)) {",
                        "\t\t\t\t\tspec = new CPPClassSpecialization((ICPPClassType) decl, owner, tpMap);",
                        "\t\t\t\t} else {",
                        "\t\t\t\t\tspec = new CPPClassSpecialization((ICPPClassType) decl, oldOwner, tpMap);",
                        "\t\t\t\t}",
                        "\t\t\t} else if (decl instanceof ICPPField && classOwner != null) {",
                        "\t\t\t\tICPPField field = (ICPPField) decl;",
                        "\t\t\t\tInstantiationContext context = createInstantiationContext(tpMap, owner);",
                        "\t\t\t\tIType type = instantiateType(field.getType(), context);",
                        "\t\t\t\tIValue value = instantiateValue(field.getInitialValue(), context, IntegralValue.MAX_RECURSION_DEPTH);",
                        "\t\t\t\tif (decl instanceof ICPPFieldTemplate) {",
                        "\t\t\t\t\tCPPFieldTemplateSpecialization fieldTempSpec = new CPPFieldTemplateSpecialization(decl, classOwner,",
                        "\t\t\t\t\t\t\ttpMap, type, value);",
                        "\t\t\t\t\tICPPTemplateParameter[] params = specializeTemplateParameters(fieldTempSpec,",
                        "\t\t\t\t\t\t\t(ICPPScope) fieldTempSpec.getScope(), ((ICPPFieldTemplate) decl).getTemplateParameters(),",
                        "\t\t\t\t\t\t\tclassOwner);",
                        "\t\t\t\t\tfieldTempSpec.setTemplateParameters(params);",
                        "\t\t\t\t\tspec = fieldTempSpec;",
                        "\t\t\t\t} else {",
                        "\t\t\t\t\tspec = new CPPFieldSpecialization(decl, classOwner, tpMap, type, value);",
                        "\t\t\t\t}",
                        "\t\t\t} else if (decl instanceof ICPPFunction) {",
                        "\t\t\t\tICPPFunction func = (ICPPFunction) decl;",
                        "\t\t\t\tInstantiationContext context = createInstantiationContext(tpMap, owner);",
                        "\t\t\t\tICPPFunctionType type = (ICPPFunctionType) instantiateType(func.getType(), context);",
                        "\t\t\t\tIType[] exceptionSpecs = instantiateTypes(func.getExceptionSpecification(), context);",
                        "",
                        "\t\t\t\tCPPFunctionSpecialization functionSpec = null;",
                        "\t\t\t\tif (decl instanceof ICPPFunctionTemplate) {",
                        "\t\t\t\t\tif (decl instanceof ICPPMethod && classOwner != null) {",
                        "\t\t\t\t\t\tCPPMethodTemplateSpecialization methodSpec;",
                        "\t\t\t\t\t\tif (decl instanceof ICPPConstructor) {",
                        "\t\t\t\t\t\t\tmethodSpec = new CPPConstructorTemplateSpecialization((ICPPConstructor) decl, classOwner,",
                        "\t\t\t\t\t\t\t\t\ttpMap, type, exceptionSpecs);",
                        "\t\t\t\t\t\t} else {",
                        "\t\t\t\t\t\t\tmethodSpec = new CPPMethodTemplateSpecialization((ICPPMethod) decl, classOwner, tpMap, type,",
                        "\t\t\t\t\t\t\t\t\texceptionSpecs);",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t\tmethodSpec.setTemplateParameters(",
                        "\t\t\t\t\t\t\t\tspecializeTemplateParameters(methodSpec, (ICPPScope) methodSpec.getScope(),",
                        "\t\t\t\t\t\t\t\t\t\t((ICPPFunctionTemplate) decl).getTemplateParameters(), classOwner));",
                        "\t\t\t\t\t\tfunctionSpec = methodSpec;",
                        "\t\t\t\t\t} else {",
                        "\t\t\t\t\t\tIBinding oldOwner = decl.getOwner();",
                        "\t\t\t\t\t\tfunctionSpec = new CPPFunctionTemplateSpecialization((ICPPFunctionTemplate) decl, oldOwner,",
                        "\t\t\t\t\t\t\t\ttpMap, type, exceptionSpecs);",
                        "\t\t\t\t\t}",
                        "\t\t\t\t} else if (decl instanceof ICPPConstructor && classOwner != null) {",
                        "\t\t\t\t\tfunctionSpec = new CPPConstructorSpecialization((ICPPConstructor) decl, classOwner, tpMap, type,",
                        "\t\t\t\t\t\t\texceptionSpecs);",
                        "\t\t\t\t} else if (decl instanceof ICPPMethod && classOwner != null) {",
                        "\t\t\t\t\tfunctionSpec = new CPPMethodSpecialization((ICPPMethod) decl, classOwner, tpMap, type,",
                        "\t\t\t\t\t\t\texceptionSpecs);",
                        "\t\t\t\t} else if (decl instanceof ICPPFunction) {",
                        "\t\t\t\t\tif (type.isSameType(func.getType())) {",
                        "\t\t\t\t\t\t// There is no need to create a CPPFunctionSpecialization object since the function is",
                        "\t\t\t\t\t\t// a friend function with the type that is not affected by the specialization.",
                        "\t\t\t\t\t\t// See http://bugs.eclipse.org/513681",
                        "\t\t\t\t\t\tspec = func;",
                        "\t\t\t\t\t} else {",
                        "\t\t\t\t\t\tIBinding oldOwner = decl.getOwner();",
                        "\t\t\t\t\t\tfunctionSpec = new CPPFunctionSpecialization(func, oldOwner, tpMap, type, exceptionSpecs);",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t\tif (functionSpec != null) {",
                        "\t\t\t\t\tfunctionSpec.setParameters(specializeParameters(func.getParameters(), functionSpec, context,",
                        "\t\t\t\t\t\t\tIntegralValue.MAX_RECURSION_DEPTH));",
                        "\t\t\t\t\tspec = functionSpec;",
                        "\t\t\t\t}",
                        "\t\t\t} else if (decl instanceof ITypedef) {",
                        "\t\t\t\tInstantiationContext context = createInstantiationContext(tpMap, owner);",
                        "\t\t\t\tIType type = instantiateType(((ITypedef) decl).getType(), context);",
                        "\t\t\t\tspec = new CPPTypedefSpecialization(decl, owner, tpMap, type);",
                        "\t\t\t} else if (decl instanceof ICPPAliasTemplate) {",
                        "\t\t\t\tICPPAliasTemplate aliasTemplate = (ICPPAliasTemplate) decl;",
                        "\t\t\t\tInstantiationContext context = createInstantiationContext(tpMap, owner);",
                        "\t\t\t\tIType type = instantiateType(aliasTemplate.getType(), context);",
                        "\t\t\t\tCPPAliasTemplateSpecialization aliasSpec = new CPPAliasTemplateSpecialization(aliasTemplate, owner,",
                        "\t\t\t\t\t\ttpMap, type);",
                        "\t\t\t\taliasSpec.setTemplateParameters(specializeTemplateParameters(aliasSpec,",
                        "\t\t\t\t\t\t(ICPPScope) aliasSpec.getScope(), aliasTemplate.getTemplateParameters(), classOwner));",
                        "\t\t\t\tspec = aliasSpec;",
                        "\t\t\t} else if (decl instanceof ICPPEnumeration && classOwner != null) {",
                        "\t\t\t\t// TODO: Handle local enumerations",
                        "\t\t\t\tspec = CPPEnumerationSpecialization.createInstance((ICPPEnumeration) decl, classOwner, tpMap);",
                        "\t\t\t} else if (decl instanceof IEnumerator && classOwner != null) {",
                        "\t\t\t\tIEnumerator enumerator = (IEnumerator) decl;",
                        "\t\t\t\tICPPEnumeration enumeration = (ICPPEnumeration) enumerator.getOwner();",
                        "\t\t\t\tIBinding enumSpec = classOwner.specializeMember(enumeration);",
                        "\t\t\t\tif (enumSpec instanceof ICPPEnumerationSpecialization) {",
                        "\t\t\t\t\tspec = ((ICPPEnumerationSpecialization) enumSpec).specializeEnumerator(enumerator);",
                        "\t\t\t\t}",
                        "\t\t\t} else if (decl instanceof ICPPUsingDeclaration) {",
                        "\t\t\t\tIBinding[] delegates = ((ICPPUsingDeclaration) decl).getDelegates();",
                        "\t\t\t\tList<IBinding> result = new ArrayList<>();",
                        "\t\t\t\tInstantiationContext context = createInstantiationContext(tpMap, owner);",
                        "\t\t\t\tfor (IBinding delegate : delegates) {",
                        "\t\t\t\t\ttry {",
                        "\t\t\t\t\t\tif (delegate instanceof ICPPUnknownBinding) {",
                        "\t\t\t\t\t\t\tdelegate = resolveUnknown((ICPPUnknownBinding) delegate, context);",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t\tif (delegate instanceof CPPFunctionSet) {",
                        "\t\t\t\t\t\t\tfor (IBinding b : ((CPPFunctionSet) delegate).getBindings()) {",
                        "\t\t\t\t\t\t\t\tresult.add(b);",
                        "\t\t\t\t\t\t\t}",
                        "\t\t\t\t\t\t} else if (delegate != null) {",
                        "\t\t\t\t\t\t\tresult.add(delegate);",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t} catch (DOMException e) {",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t\tdelegates = result.toArray(new IBinding[result.size()]);",
                        "\t\t\t\tspec = new CPPUsingDeclarationSpecialization((ICPPUsingDeclaration) decl, owner, tpMap, delegates);",
                        "\t\t\t}",
                        "\t\t} catch (DOMException e) {",
                        "\t\t\tCCorePlugin.log(e);",
                        "\t\t} finally {",
                        "\t\t\t// Restore original instantiation depth.",
                        "\t\t\tfTemplateInstantiationDepth.set(instantiationDepth);",
                        "\t\t}",
                        "\t\treturn spec;",
                        "\t}",
                        "",
                        "\tprivate static InstantiationContext createInstantiationContext(ICPPTemplateParameterMap tpMap, IBinding owner) {",
                        "\t\treturn new InstantiationContext(tpMap, getSpecializationContext(owner));",
                        "\t}",
                        "",
                        "\tpublic static ICPPClassSpecialization getSpecializationContext(IBinding owner) {",
                        "\t\tICPPClassSpecialization within = getContextClassSpecialization(owner);",
                        "\t\tif (within == null)",
                        "\t\t\treturn null;",
                        "\t\tICPPClassType orig = within.getSpecializedBinding();",
                        "\t\twhile (true) {",
                        "\t\t\tIBinding o1 = within.getOwner();",
                        "\t\t\tIBinding o2 = orig.getOwner();",
                        "\t\t\tif (!(o1 instanceof ICPPClassSpecialization && o2 instanceof ICPPClassType))",
                        "\t\t\t\treturn within;",
                        "\t\t\tICPPClassSpecialization nextWithin = (ICPPClassSpecialization) o1;",
                        "\t\t\torig = (ICPPClassType) o2;",
                        "\t\t\tif (orig.isSameType(nextWithin))",
                        "\t\t\t\treturn within;",
                        "\t\t\twithin = nextWithin;",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tpublic static IValue instantiateValue(IValue value, InstantiationContext context, int maxDepth) {",
                        "\t\tif (value == null)",
                        "\t\t\treturn null;",
                        "\t\tICPPEvaluation evaluation = value.getEvaluation();",
                        "\t\tif (evaluation == null)",
                        "\t\t\treturn value;",
                        "\t\tICPPEvaluation instantiated = evaluation.instantiate(context, maxDepth);",
                        "\t\tif (instantiated == evaluation)",
                        "\t\t\treturn value;",
                        "\t\treturn instantiated.getValue();",
                        "\t}",
                        "",
                        "\tpublic static boolean containsParameterPack(IType type) {",
                        "\t\treturn determinePackSize(type, CPPTemplateParameterMap.EMPTY) == PACK_SIZE_DEFER;",
                        "\t}",
                        "",
                        "\tstatic int determinePackSize(IType type, ICPPTemplateParameterMap tpMap) {",
                        "\t\tif (type instanceof ICPPFunctionType) {",
                        "\t\t\tfinal ICPPFunctionType ft = (ICPPFunctionType) type;",
                        "\t\t\tfinal IType rt = ft.getReturnType();",
                        "\t\t\tint r = determinePackSize(rt, tpMap);",
                        "\t\t\tif (r < 0)",
                        "\t\t\t\treturn r;",
                        "\t\t\tIType[] ps = ft.getParameterTypes();",
                        "\t\t\tfor (IType pt : ps) {",
                        "\t\t\t\tr = combinePackSize(r, determinePackSize(pt, tpMap));",
                        "\t\t\t\tif (r < 0)",
                        "\t\t\t\t\treturn r;",
                        "\t\t\t}",
                        "\t\t\treturn r;",
                        "\t\t}",
                        "",
                        "\t\tif (type instanceof TypeOfDependentExpression) {",
                        "\t\t\treturn ((TypeOfDependentExpression) type).getEvaluation().determinePackSize(tpMap);",
                        "\t\t}",
                        "",
                        "\t\tif (type instanceof ICPPUnknownBinding) {",
                        "\t\t\treturn determinePackSize((ICPPUnknownBinding) type, tpMap);",
                        "\t\t}",
                        "",
                        "\t\tif (type instanceof ICPPParameterPackType)",
                        "\t\t\treturn PACK_SIZE_NOT_FOUND;",
                        "",
                        "\t\tint r = PACK_SIZE_NOT_FOUND;",
                        "\t\tif (type instanceof IArrayType) {",
                        "\t\t\tIArrayType at = (IArrayType) type;",
                        "\t\t\tIValue asize = at.getSize();",
                        "\t\t\tr = determinePackSize(asize, tpMap);",
                        "\t\t\tif (r < 0)",
                        "\t\t\t\treturn r;",
                        "\t\t}",
                        "",
                        "\t\tif (type instanceof ITypeContainer) {",
                        "\t\t\tfinal ITypeContainer typeContainer = (ITypeContainer) type;",
                        "\t\t\tr = combinePackSize(r, determinePackSize(typeContainer.getType(), tpMap));",
                        "\t\t}",
                        "\t\treturn r;",
                        "\t}",
                        "",
                        "\tstatic int determinePackSize(ICPPUnknownBinding binding, ICPPTemplateParameterMap tpMap) {",
                        "\t\tif (binding instanceof ICPPTemplateParameter) {",
                        "\t\t\tICPPTemplateParameter tpar = (ICPPTemplateParameter) binding;",
                        "\t\t\tif (tpar.isParameterPack()) {",
                        "\t\t\t\tICPPTemplateArgument[] args = tpMap.getPackExpansion(tpar);",
                        "\t\t\t\tif (args != null) {",
                        "\t\t\t\t\treturn args.length;",
                        "\t\t\t\t}",
                        "\t\t\t\treturn PACK_SIZE_DEFER;",
                        "\t\t\t}",
                        "\t\t\treturn PACK_SIZE_NOT_FOUND;",
                        "\t\t}",
                        "\t\tint r = PACK_SIZE_NOT_FOUND;",
                        "\t\tif (binding instanceof ICPPDeferredClassInstance) {",
                        "\t\t\tICPPDeferredClassInstance dcl = (ICPPDeferredClassInstance) binding;",
                        "\t\t\tif (dcl.getClassTemplate() instanceof ICPPTemplateTemplateParameter) {",
                        "\t\t\t\tr = combinePackSize(r, determinePackSize((ICPPUnknownBinding) dcl.getClassTemplate(), tpMap));",
                        "\t\t\t}",
                        "\t\t\tICPPTemplateArgument[] args = dcl.getTemplateArguments();",
                        "\t\t\tfor (ICPPTemplateArgument arg : args) {",
                        "\t\t\t\tr = combinePackSize(r, determinePackSize(arg, tpMap));",
                        "\t\t\t\tif (r < 0)",
                        "\t\t\t\t\treturn r;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\tIBinding ownerBinding = binding.getOwner();",
                        "\t\tif (ownerBinding instanceof IType)",
                        "\t\t\tr = combinePackSize(r, determinePackSize((IType) ownerBinding, tpMap));",
                        "",
                        "\t\treturn r;",
                        "\t}",
                        "",
                        "\tstatic int determinePackSize(IValue value, ICPPTemplateParameterMap tpMap) {",
                        "\t\tICPPEvaluation eval = value.getEvaluation();",
                        "\t\tif (eval == null)",
                        "\t\t\treturn PACK_SIZE_NOT_FOUND;",
                        "",
                        "\t\treturn ((CPPEvaluation) eval).determinePackSize(tpMap);",
                        "\t}",
                        "",
                        "\tstatic int determinePackSize(ICPPTemplateArgument arg, ICPPTemplateParameterMap tpMap) {",
                        "\t\tif (arg.isTypeValue())",
                        "\t\t\treturn determinePackSize(arg.getTypeValue(), tpMap);",
                        "\t\treturn determinePackSize(arg.getNonTypeValue(), tpMap);",
                        "\t}",
                        "",
                        "\tstatic int combinePackSize(int ps1, int ps2) {",
                        "\t\tif (ps1 < 0 || ps2 == PACK_SIZE_NOT_FOUND)",
                        "\t\t\treturn ps1;",
                        "\t\tif (ps2 < 0 || ps1 == PACK_SIZE_NOT_FOUND)",
                        "\t\t\treturn ps2;",
                        "\t\tif (ps1 != ps2)",
                        "\t\t\treturn PACK_SIZE_FAIL;",
                        "\t\treturn ps1;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Instantiates types contained in an array.",
                        "\t *",
                        "\t * @param types an array of types",
                        "\t * @param context the template instantiation context",
                        "\t * @return an array containing instantiated types.",
                        "\t */",
                        "\tpublic static IType[] instantiateTypes(IType[] types, InstantiationContext context) {",
                        "\t\tif (types == null)",
                        "\t\t\treturn null;",
                        "",
                        "\t\t// Don't create a new array until it's really needed.",
                        "\t\tIType[] result = types;",
                        "\t\tint j = 0;",
                        "\t\tfor (int i = 0; i < types.length; i++) {",
                        "\t\t\tIType origType = types[i];",
                        "\t\t\tIType newType;",
                        "\t\t\tif (origType instanceof ICPPParameterPackType) {",
                        "\t\t\t\tIType innerType = ((ICPPParameterPackType) origType).getType();",
                        "\t\t\t\tint packSize = determinePackSize(innerType, context.getParameterMap());",
                        "\t\t\t\tif (packSize == PACK_SIZE_FAIL || packSize == PACK_SIZE_NOT_FOUND) {",
                        "\t\t\t\t\tnewType = new ProblemBinding(CPPSemantics.getCurrentLookupPoint(),",
                        "\t\t\t\t\t\t\tIProblemBinding.SEMANTIC_INVALID_TYPE,",
                        "\t\t\t\t\t\t\ttypes[i] instanceof IBinding ? ((IBinding) types[i]).getNameCharArray() : null);",
                        "\t\t\t\t} else if (packSize == PACK_SIZE_DEFER) {",
                        "\t\t\t\t\tnewType = origType;",
                        "\t\t\t\t} else {",
                        "\t\t\t\t\tIType[] newResult = new IType[result.length + packSize - 1];",
                        "\t\t\t\t\tSystem.arraycopy(result, 0, newResult, 0, j);",
                        "\t\t\t\t\tresult = newResult;",
                        "\t\t\t\t\tcontext.setExpandPack(true);",
                        "\t\t\t\t\tint oldPackOffset = context.getPackOffset();",
                        "\t\t\t\t\tfor (int k = 0; k < packSize; k++) {",
                        "\t\t\t\t\t\tcontext.setPackOffset(k);",
                        "\t\t\t\t\t\tIType instantiated = instantiateType(innerType, context);",
                        "\t\t\t\t\t\tif (context.isPackExpanded()) {",
                        "\t\t\t\t\t\t\tif (instantiated != null) {",
                        "\t\t\t\t\t\t\t\tinstantiated = new CPPParameterPackType(instantiated);",
                        "\t\t\t\t\t\t\t}",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t\tresult[j++] = instantiated;",
                        "",
                        "\t\t\t\t\t}",
                        "\t\t\t\t\tcontext.setPackOffset(oldPackOffset);",
                        "\t\t\t\t\tcontext.setExpandPack(false);",
                        "\t\t\t\t\tcontinue;",
                        "\t\t\t\t}",
                        "\t\t\t} else {",
                        "\t\t\t\tnewType = instantiateType(origType, context);",
                        "\t\t\t}",
                        "\t\t\tif (result != types) {",
                        "\t\t\t\tresult[j++] = newType;",
                        "\t\t\t} else {",
                        "\t\t\t\tif (newType != origType) {",
                        "\t\t\t\t\tresult = new IType[types.length];",
                        "\t\t\t\t\tSystem.arraycopy(types, 0, result, 0, i);",
                        "\t\t\t\t\tresult[j] = newType;",
                        "\t\t\t\t}",
                        "\t\t\t\tj++;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\treturn result;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Instantiates arguments contained in an array. Instantiated arguments are checked for",
                        "\t * validity. If the {@code strict} parameter is {@code true}, the method returns {@code null} if",
                        "\t * any of the instantiated arguments are invalid. If the {@code strict} parameter is",
                        "\t * {@code false}, any invalid instantiated arguments are replaced by the corresponding original",
                        "\t * arguments.",
                        "\t */",
                        "\tpublic static ICPPTemplateArgument[] instantiateArguments(ICPPTemplateArgument[] args, InstantiationContext context,",
                        "\t\t\tboolean strict) throws DOMException {",
                        "\t\t// Don't create a new array until it's really needed.",
                        "\t\tICPPTemplateArgument[] result = args;",
                        "\t\tint resultShift = 0;",
                        "\t\tfor (int i = 0; i < args.length; i++) {",
                        "\t\t\tICPPTemplateArgument origArg = args[i];",
                        "\t\t\tICPPTemplateArgument newArg;",
                        "\t\t\tif (origArg.isPackExpansion()) {",
                        "\t\t\t\tICPPTemplateArgument pattern = origArg.getExpansionPattern();",
                        "\t\t\t\tint packSize = determinePackSize(pattern, context.getParameterMap());",
                        "\t\t\t\tif (packSize == PACK_SIZE_FAIL || packSize == PACK_SIZE_NOT_FOUND) {",
                        "\t\t\t\t\tthrow new DOMException(new ProblemBinding(CPPSemantics.getCurrentLookupPoint(),",
                        "\t\t\t\t\t\t\tIProblemBinding.SEMANTIC_INVALID_TEMPLATE_ARGUMENTS, null));",
                        "\t\t\t\t} else if (packSize == PACK_SIZE_DEFER) {",
                        "\t\t\t\t\tnewArg = origArg;",
                        "\t\t\t\t} else {",
                        "\t\t\t\t\tint shift = packSize - 1;",
                        "\t\t\t\t\tICPPTemplateArgument[] newResult = new ICPPTemplateArgument[args.length + resultShift + shift];",
                        "\t\t\t\t\tSystem.arraycopy(result, 0, newResult, 0, i + resultShift);",
                        "\t\t\t\t\tcontext.setExpandPack(true);",
                        "\t\t\t\t\tint oldPackOffset = context.getPackOffset();",
                        "\t\t\t\t\tfor (int j = 0; j < packSize; j++) {",
                        "\t\t\t\t\t\tcontext.setPackOffset(j);",
                        "\t\t\t\t\t\tnewArg = instantiateArgument(pattern, context);",
                        "\t\t\t\t\t\tif (!isValidArgument(newArg)) {",
                        "\t\t\t\t\t\t\tif (strict)",
                        "\t\t\t\t\t\t\t\treturn null;",
                        "\t\t\t\t\t\t\tresult[i + resultShift] = origArg;",
                        "\t\t\t\t\t\t\tnewResult = result;",
                        "\t\t\t\t\t\t\tshift = 0;",
                        "\t\t\t\t\t\t\tbreak;",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t\tif (context.isPackExpanded()) {",
                        "\t\t\t\t\t\t\tIType type = newArg.getTypeValue();",
                        "\t\t\t\t\t\t\tif (type != null) {",
                        "\t\t\t\t\t\t\t\ttype = new CPPParameterPackType(type);",
                        "\t\t\t\t\t\t\t\tnewArg = new CPPTemplateTypeArgument(type);",
                        "\t\t\t\t\t\t\t}",
                        "\t\t\t\t\t\t\tcontext.setPackExpanded(false);",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t\tnewResult[i + resultShift + j] = newArg;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t\tcontext.setPackOffset(oldPackOffset);",
                        "\t\t\t\t\tcontext.setExpandPack(false);",
                        "\t\t\t\t\tresult = newResult;",
                        "\t\t\t\t\tresultShift += shift;",
                        "\t\t\t\t\tcontinue;",
                        "\t\t\t\t}",
                        "\t\t\t} else {",
                        "\t\t\t\tnewArg = instantiateArgument(origArg, context);",
                        "\t\t\t\tif (!isValidArgument(newArg)) {",
                        "\t\t\t\t\tif (strict)",
                        "\t\t\t\t\t\treturn null;",
                        "\t\t\t\t\tnewArg = origArg;",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (result != args) {",
                        "\t\t\t\tresult[i + resultShift] = newArg;",
                        "\t\t\t} else if (newArg != origArg) {",
                        "\t\t\t\tassert resultShift == 0;",
                        "\t\t\t\tresult = new ICPPTemplateArgument[args.length];",
                        "\t\t\t\tif (i > 0) {",
                        "\t\t\t\t\tSystem.arraycopy(args, 0, result, 0, i);",
                        "\t\t\t\t}",
                        "\t\t\t\tresult[i] = newArg;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\treturn result;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Instantiates a template argument.",
                        "\t */",
                        "\tstatic ICPPTemplateArgument instantiateArgument(ICPPTemplateArgument arg, InstantiationContext context) {",
                        "\t\tif (arg == null)",
                        "\t\t\treturn null;",
                        "\t\tif (arg.isNonTypeValue()) {",
                        "\t\t\tfinal ICPPEvaluation eval = arg.getNonTypeEvaluation();",
                        "\t\t\tfinal ICPPEvaluation newEval = eval.instantiate(context, IntegralValue.MAX_RECURSION_DEPTH);",
                        "\t\t\tif (eval == newEval)",
                        "\t\t\t\treturn arg;",
                        "\t\t\treturn new CPPTemplateNonTypeArgument(newEval);",
                        "\t\t}",
                        "",
                        "\t\t// Which to instantiate, getOriginalTypeValue() or getTypeValue()?",
                        "\t\t//",
                        "\t\t// Using getOriginalTypeValue() is better for typedef preservation,",
                        "\t\t// and in the case of alias template instances, also necessary for",
                        "\t\t// correctness (since an alias template instance could have dependent",
                        "\t\t// arguments that don't appear in the resulting type, and these",
                        "\t\t// arguments could SFINAE out during instantiation; the popular",
                        "\t\t// \"void_t\" technique relies on this).",
                        "\t\t//",
                        "\t\t// However, caching of template instances is based on the normalized",
                        "\t\t// representation of arguments, which uses getTypeValue(). This,",
                        "\t\t// together with certain deficiencies in ASTTypeUtil (namely, that",
                        "\t\t// template parameters owned by different templates end up with the",
                        "\t\t// same string representation), leads to tricky bugs if we try to",
                        "\t\t// use getOriginalTypeValue() here all the time (observe, e.g., how",
                        "\t\t// IndexCPPTemplateResolutionTest.testRegression_516338 fails if we",
                        "\t\t// unconditionally use getOriginalTypeValue() here).",
                        "\t\t//",
                        "\t\t// As a compromise, we use getOriginalTypeValue() in the case where",
                        "\t\t// it's important for correctness (alias template instances), and",
                        "\t\t// getTypeValue() otherwise.",
                        "\t\tIType type;",
                        "\t\tfinal IType origType = arg.getOriginalTypeValue();",
                        "\t\tif (origType instanceof ICPPAliasTemplateInstance) {",
                        "\t\t\ttype = origType;",
                        "\t\t} else {",
                        "\t\t\ttype = arg.getTypeValue();",
                        "\t\t}",
                        "",
                        "\t\tfinal IType inst = instantiateType(type, context);",
                        "\t\tif (type == inst)",
                        "\t\t\treturn arg;",
                        "\t\treturn new CPPTemplateTypeArgument(inst);",
                        "\t}",
                        "",
                        "\tprivate static CPPTemplateParameterMap instantiateArgumentMap(ICPPTemplateParameterMap orig,",
                        "\t\t\tInstantiationContext context) {",
                        "\t\tfinal Integer[] positions = orig.getAllParameterPositions();",
                        "\t\tCPPTemplateParameterMap newMap = new CPPTemplateParameterMap(positions.length);",
                        "\t\tfor (Integer key : positions) {",
                        "\t\t\tICPPTemplateArgument arg = orig.getArgument(key);",
                        "\t\t\tif (arg != null) {",
                        "\t\t\t\tICPPTemplateArgument newArg = instantiateArgument(arg, context);",
                        "\t\t\t\tif (!isValidArgument(newArg))",
                        "\t\t\t\t\tnewArg = arg;",
                        "\t\t\t\tnewMap.put(key, newArg);",
                        "\t\t\t} else {",
                        "\t\t\t\tICPPTemplateArgument[] args = orig.getPackExpansion(key);",
                        "\t\t\t\tif (args != null) {",
                        "\t\t\t\t\ttry {",
                        "\t\t\t\t\t\tnewMap.put(key, instantiateArguments(args, context, false));",
                        "\t\t\t\t\t} catch (DOMException e) {",
                        "\t\t\t\t\t\tnewMap.put(key, args);",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\treturn newMap;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Instantiates the given type with the provided map and pack\u041effset.",
                        "\t * The context is used to replace templates with their specialization, where appropriate.",
                        "\t */",
                        "\tpublic static IType instantiateType(final IType type, InstantiationContext context) {",
                        "\t\tif (context.getParameterMap() == null)",
                        "\t\t\treturn type;",
                        "",
                        "\t\tTypeInstantiationRequest instantiationRequest = new TypeInstantiationRequest(type, context);",
                        "\t\tif (!instantiationsInProgress.get().add(instantiationRequest)) {",
                        "\t\t\treturn type instanceof ICPPFunctionType ? ProblemFunctionType.RECURSION_IN_LOOKUP",
                        "\t\t\t\t\t: ProblemType.RECURSION_IN_LOOKUP;",
                        "\t\t}",
                        "",
                        "\t\ttry {",
                        "\t\t\tif (type instanceof ICPPFunctionType) {",
                        "\t\t\t\tfinal ICPPFunctionType ft = (ICPPFunctionType) type;",
                        "\t\t\t\tIType[] ps = ft.getParameterTypes();",
                        "\t\t\t\tIType[] params = instantiateTypes(ps, context);",
                        "\t\t\t\tfinal IType r = ft.getReturnType();",
                        "\t\t\t\tIType ret = instantiateType(r, context);",
                        "\t\t\t\tif (ret == r && params == ps) {",
                        "\t\t\t\t\treturn type;",
                        "\t\t\t\t}",
                        "\t\t\t\t// The parameter types need to be adjusted.",
                        "\t\t\t\tfor (int i = 0; i < params.length; i++) {",
                        "\t\t\t\t\tIType p = params[i];",
                        "\t\t\t\t\tif (!isDependentType(p)) {",
                        "\t\t\t\t\t\tparams[i] = CPPVisitor.adjustParameterType(p, true);",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t\treturn new CPPFunctionType(ret, params, ft.isConst(), ft.isVolatile(), ft.hasRefQualifier(),",
                        "\t\t\t\t\t\tft.isRValueReference(), ft.takesVarArgs());",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (type instanceof ICPPTemplateParameter) {",
                        "\t\t\t\treturn resolveTemplateTypeParameter((ICPPTemplateParameter) type, context);",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (type instanceof ICPPUnknownBinding) {",
                        "\t\t\t\tif (type instanceof TypeOfDependentExpression) {",
                        "\t\t\t\t\tTypeOfDependentExpression dependentType = (TypeOfDependentExpression) type;",
                        "\t\t\t\t\tICPPEvaluation eval = dependentType.getEvaluation();",
                        "\t\t\t\t\tICPPEvaluation instantiated = eval.instantiate(context, IntegralValue.MAX_RECURSION_DEPTH);",
                        "\t\t\t\t\tif (instantiated != eval) {",
                        "\t\t\t\t\t\tif (dependentType.isForDecltype()) {",
                        "\t\t\t\t\t\t\treturn CPPSemantics.getDeclTypeForEvaluation(instantiated);",
                        "\t\t\t\t\t\t} else {",
                        "\t\t\t\t\t\t\treturn instantiated.getType();",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t}",
                        "\t\t\t\t} else if (type instanceof TypeOfUnknownMember) {",
                        "\t\t\t\t\tIBinding binding = resolveUnknown(((TypeOfUnknownMember) type).getUnknownMember(), context);",
                        "\t\t\t\t\tif (binding instanceof IType) {",
                        "\t\t\t\t\t\treturn (IType) binding;",
                        "\t\t\t\t\t} else if (binding instanceof IVariable) {",
                        "\t\t\t\t\t\treturn ((IVariable) binding).getType();",
                        "\t\t\t\t\t} else if (binding instanceof IFunction) {",
                        "\t\t\t\t\t\treturn ((IFunction) binding).getType();",
                        "\t\t\t\t\t}",
                        "\t\t\t\t\treturn type;",
                        "\t\t\t\t} else {",
                        "\t\t\t\t\tIBinding binding = resolveUnknown((ICPPUnknownBinding) type, context);",
                        "\t\t\t\t\tif (binding instanceof IType)",
                        "\t\t\t\t\t\treturn (IType) binding;",
                        "",
                        "\t\t\t\t\treturn type;",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (context.getContextTypeSpecialization() != null && type instanceof IBinding) {",
                        "\t\t\t\tIType unwound = getNestedType(type, TDEF);",
                        "\t\t\t\tICPPClassSpecialization withinClass = context.getContextClassSpecialization();",
                        "\t\t\t\tif (unwound instanceof ICPPClassType && unwound.isSameType(withinClass.getSpecializedBinding())) {",
                        "\t\t\t\t\t// Convert (partial) class-templates (specializations) to the more specialized",
                        "\t\t\t\t\t// version.",
                        "\t\t\t\t\tif (withinClass instanceof ICPPClassTemplate || !(unwound instanceof ICPPClassTemplate))",
                        "\t\t\t\t\t\treturn withinClass;",
                        "\t\t\t\t}",
                        "\t\t\t\tIBinding typeAsBinding = (IBinding) type;",
                        "\t\t\t\tIBinding owner = typeAsBinding.getOwner();",
                        "\t\t\t\tif (owner instanceof IType) {",
                        "\t\t\t\t\tfinal IType ownerAsType = getNestedType((IType) owner, TDEF);",
                        "\t\t\t\t\tObject newOwner = owner;",
                        "\t\t\t\t\tif (ownerAsType instanceof ICPPClassType",
                        "\t\t\t\t\t\t\t&& ownerAsType.isSameType(withinClass.getSpecializedBinding())) {",
                        "\t\t\t\t\t\t// Convert (partial) class-templates (specializations) that are used as",
                        "\t\t\t\t\t\t// owner of another binding, to the more specialized version.",
                        "\t\t\t\t\t\tnewOwner = withinClass;",
                        "\t\t\t\t\t} else {",
                        "\t\t\t\t\t\tnewOwner = instantiateType(ownerAsType, context);",
                        "\t\t\t\t\t}",
                        "",
                        "\t\t\t\t\tif (newOwner != owner && newOwner instanceof ICPPClassSpecialization) {",
                        "\t\t\t\t\t\treturn (IType) ((ICPPClassSpecialization) newOwner).specializeMember(typeAsBinding);",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "",
                        "\t\t\t// An alias template instance may have dependent arguments that don't contribute",
                        "\t\t\t// to the target type but can SFINAE out during instantiation, so it's not",
                        "\t\t\t// sufficient to handle it in the ITypeContainer case.",
                        "\t\t\tif (type instanceof ICPPAliasTemplateInstance) {",
                        "\t\t\t\t// Cache instantiations of alias templates. This is necessary because below we can",
                        "\t\t\t\t// potentially instantiate types that appear in the arguments of an alias template",
                        "\t\t\t\t// instance up to three times (once in instantiateArguments(), once in",
                        "\t\t\t\t// instantiateArgumentMap(), and if the argument appears in the aliased type, then",
                        "\t\t\t\t// a third time in instantiateType()), leading to exponential runtime in cases of",
                        "\t\t\t\t// nested alias template instances (which can be common in metaprogramming code",
                        "\t\t\t\t// implemented using alias templates).",
                        "\t\t\t\tIType result = getCachedInstantiation(instantiationRequest);",
                        "\t\t\t\tif (result != null) {",
                        "\t\t\t\t\treturn result;",
                        "\t\t\t\t}",
                        "\t\t\t\tICPPAliasTemplateInstance instance = (ICPPAliasTemplateInstance) type;",
                        "\t\t\t\tICPPAliasTemplate template = instance.getTemplateDefinition();",
                        "\t\t\t\tICPPTemplateArgument[] args = instance.getTemplateArguments();",
                        "\t\t\t\tICPPTemplateArgument[] newArgs = instantiateArguments(args, context, true);",
                        "\t\t\t\tif (newArgs == null) {",
                        "\t\t\t\t\tresult = (IType) createProblem(template, IProblemBinding.SEMANTIC_INVALID_TEMPLATE_ARGUMENTS);",
                        "\t\t\t\t} else if (args != newArgs) {",
                        "\t\t\t\t\tIType target = instantiateType(instance.getType(), context);",
                        "\t\t\t\t\tCPPTemplateParameterMap map = createParameterMap(template, newArgs);",
                        "\t\t\t\t\tif (map == null) {",
                        "\t\t\t\t\t\tresult = (IType) createProblem(template, IProblemBinding.SEMANTIC_INVALID_TEMPLATE_ARGUMENTS);",
                        "\t\t\t\t\t} else {",
                        "\t\t\t\t\t\tresult = new CPPAliasTemplateInstance(template, target, instance.getOwner(), map, newArgs);",
                        "\t\t\t\t\t}",
                        "\t\t\t\t} else {",
                        "\t\t\t\t\tresult = type;",
                        "\t\t\t\t}",
                        "\t\t\t\tputCachedInstantiation(instantiationRequest, result);",
                        "\t\t\t\treturn result;",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (type instanceof ITypeContainer) {",
                        "\t\t\t\tfinal ITypeContainer typeContainer = (ITypeContainer) type;",
                        "\t\t\t\tIType nestedType = typeContainer.getType();",
                        "\t\t\t\tIType newNestedType = instantiateType(nestedType, context);",
                        "\t\t\t\tif (typeContainer instanceof ICPPPointerToMemberType) {",
                        "\t\t\t\t\tICPPPointerToMemberType ptm = (ICPPPointerToMemberType) typeContainer;",
                        "\t\t\t\t\tIType memberOfClass = ptm.getMemberOfClass();",
                        "\t\t\t\t\tIType newMemberOfClass = instantiateType(memberOfClass, context);",
                        "\t\t\t\t\tIType classType = SemanticUtil.getNestedType(newMemberOfClass, CVTYPE | TDEF);",
                        "\t\t\t\t\tif (!(classType instanceof ICPPClassType || classType instanceof UniqueType",
                        "\t\t\t\t\t\t\t|| classType instanceof ICPPUnknownBinding)) {",
                        "\t\t\t\t\t\treturn new ProblemType(ISemanticProblem.BINDING_INVALID_TYPE);",
                        "\t\t\t\t\t}",
                        "\t\t\t\t\tif (newNestedType != nestedType || newMemberOfClass != memberOfClass) {",
                        "\t\t\t\t\t\treturn new CPPPointerToMemberType(newNestedType, newMemberOfClass, ptm.isConst(),",
                        "\t\t\t\t\t\t\t\tptm.isVolatile(), ptm.isRestrict());",
                        "\t\t\t\t\t}",
                        "\t\t\t\t\treturn typeContainer;",
                        "\t\t\t\t}",
                        "\t\t\t\tif (typeContainer instanceof IArrayType) {",
                        "\t\t\t\t\tIArrayType at = (IArrayType) typeContainer;",
                        "\t\t\t\t\tIValue asize = at.getSize();",
                        "\t\t\t\t\tif (asize != null) {",
                        "\t\t\t\t\t\tIValue newSize = instantiateValue(asize, context, IntegralValue.MAX_RECURSION_DEPTH);",
                        "\t\t\t\t\t\tif (newSize != asize) {",
                        "\t\t\t\t\t\t\treturn new CPPArrayType(newNestedType, newSize);",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t\tif (newNestedType != nestedType) {",
                        "\t\t\t\t\treturn SemanticUtil.replaceNestedType(typeContainer, newNestedType);",
                        "\t\t\t\t}",
                        "\t\t\t\treturn typeContainer;",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (type instanceof ICPPUnaryTypeTransformation) {",
                        "\t\t\t\tICPPUnaryTypeTransformation typeTransformation = (ICPPUnaryTypeTransformation) type;",
                        "\t\t\t\tIType operand = instantiateType(typeTransformation.getOperand(), context);",
                        "\t\t\t\tswitch (typeTransformation.getOperator()) {",
                        "\t\t\t\tcase underlying_type:",
                        "\t\t\t\t\treturn TypeTraits.underlyingType(operand);",
                        "\t\t\t\tdefault:",
                        "\t\t\t\t\treturn null; // shouldn't happen",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (type instanceof CPPClosureType) {",
                        "\t\t\t\treturn ((CPPClosureType) type).instantiate(context);",
                        "\t\t\t}",
                        "",
                        "\t\t\treturn type;",
                        "\t\t} catch (DOMException e) {",
                        "\t\t\treturn e.getProblem();",
                        "\t\t} finally {",
                        "\t\t\tinstantiationsInProgress.get().remove(instantiationRequest);",
                        "\t\t}",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Specialize a template parameter of a nested template by substituting values for the template",
                        "\t * parameters of enclosing templates into the template parameter's default value and, in the case",
                        "\t * of a non-type template parameter, type.",
                        "\t *",
                        "\t * @param owner the specialization of the nested template. This will be the owner of the",
                        "\t *              specialized template parameter.",
                        "\t * @param scope the scope of the nested template specialization",
                        "\t * @param specialized the template parameter to be specialized",
                        "\t * @param within the specialization of the enclosing class",
                        "\t * @return the specialized template parameter",
                        "\t */",
                        "\tpublic static ICPPTemplateParameter specializeTemplateParameter(ICPPSpecialization owner, ICPPScope scope,",
                        "\t\t\tICPPTemplateParameter specialized, ICPPClassSpecialization within) {",
                        "\t\tif (specialized == null)",
                        "\t\t\treturn null;",
                        "\t\tICPPTemplateParameterMap tpMap = owner.getTemplateParameterMap();",
                        "\t\tInstantiationContext context = new InstantiationContext(tpMap, 0, within);",
                        "\t\tICPPTemplateArgument defaultValue = instantiateArgument(specialized.getDefaultValue(), context);",
                        "\t\tif (specialized instanceof ICPPTemplateNonTypeParameter) {",
                        "\t\t\tICPPTemplateNonTypeParameter spec = (ICPPTemplateNonTypeParameter) specialized;",
                        "\t\t\tIType type = instantiateType(spec.getType(), context);",
                        "\t\t\treturn new CPPTemplateNonTypeParameterSpecialization(owner, scope, spec, defaultValue, type);",
                        "\t\t} else if (specialized instanceof ICPPTemplateTypeParameter) {",
                        "\t\t\treturn new CPPTemplateTypeParameterSpecialization(owner, scope, (ICPPTemplateTypeParameter) specialized,",
                        "\t\t\t\t\tdefaultValue);",
                        "\t\t} else if (specialized instanceof ICPPTemplateTemplateParameter) {",
                        "\t\t\treturn new CPPTemplateTemplateParameterSpecialization(owner, scope,",
                        "\t\t\t\t\t(ICPPTemplateTemplateParameter) specialized, defaultValue);",
                        "\t\t}",
                        "\t\treturn null;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Convenience method for specializing all template parameters in an array.",
                        "\t * See specializeTemplateParameter().",
                        "\t */",
                        "\tpublic static ICPPTemplateParameter[] specializeTemplateParameters(ICPPSpecialization owner, ICPPScope scope,",
                        "\t\t\tICPPTemplateParameter[] specialized, ICPPClassSpecialization within) {",
                        "\t\tICPPTemplateParameter[] result = new ICPPTemplateParameter[specialized.length];",
                        "\t\tfor (int i = 0; i < specialized.length; ++i)",
                        "\t\t\tresult[i] = specializeTemplateParameter(owner, scope, specialized[i], within);",
                        "\t\treturn result;",
                        "\t}",
                        "",
                        "\tpublic static IBinding instantiateBinding(IBinding binding, InstantiationContext context, int maxDepth)",
                        "\t\t\tthrows DOMException {",
                        "\t\tif (binding instanceof ICPPClassTemplate) {",
                        "\t\t\tbinding = createDeferredInstance((ICPPClassTemplate) binding);",
                        "\t\t}",
                        "",
                        "\t\tif (binding instanceof ICPPUnknownBinding) {",
                        "\t\t\treturn resolveUnknown((ICPPUnknownBinding) binding, context);",
                        "\t\t} else if (binding instanceof ICPPMethod || binding instanceof ICPPField || binding instanceof ICPPEnumeration",
                        "\t\t\t\t|| binding instanceof ICPPClassType) {",
                        "\t\t\tIBinding owner = binding.getOwner();",
                        "\t\t\tif (!(owner instanceof ICPPSpecialization)) {",
                        "\t\t\t\towner = instantiateBinding(owner, context, maxDepth);",
                        "\t\t\t}",
                        "\t\t\tif (owner instanceof ICPPClassSpecialization) {",
                        "\t\t\t\treturn ((ICPPClassSpecialization) owner).specializeMember(binding);",
                        "\t\t\t}",
                        "\t\t} else if (binding instanceof IEnumerator) {",
                        "\t\t\tIBinding owner = binding.getOwner();",
                        "\t\t\tICPPTypeSpecialization within = context.getContextTypeSpecialization();",
                        "\t\t\tif (within instanceof ICPPEnumerationSpecialization && within.getSpecializedBinding().equals(owner)) {",
                        "\t\t\t\towner = within;",
                        "\t\t\t} else if (!(owner instanceof ICPPSpecialization)) {",
                        "\t\t\t\towner = instantiateBinding(owner, context, maxDepth);",
                        "\t\t\t}",
                        "\t\t\tif (owner instanceof ICPPEnumerationSpecialization) {",
                        "\t\t\t\treturn ((ICPPEnumerationSpecialization) owner).specializeEnumerator((IEnumerator) binding);",
                        "\t\t\t}",
                        "\t\t} else if (binding instanceof ICPPFunctionInstance) {",
                        "\t\t\t// TODO(nathanridge):",
                        "\t\t\t//   Maybe we should introduce an ICPPDeferredFunctionInstance and have things that can",
                        "\t\t\t//   return a dependent ICPPFunctionInstance (like instantiateForAddressOfFunction)",
                        "\t\t\t//   return that when appropriate?",
                        "\t\t\tICPPFunctionInstance origInstance = (ICPPFunctionInstance) binding;",
                        "\t\t\tICPPTemplateArgument[] origArgs = origInstance.getTemplateArguments();",
                        "\t\t\tICPPTemplateArgument[] newArgs = instantiateArguments(origArgs, context, false);",
                        "\t\t\tif (origArgs != newArgs) {",
                        "\t\t\t\tCPPTemplateParameterMap newMap = instantiateArgumentMap(origInstance.getTemplateParameterMap(),",
                        "\t\t\t\t\t\tcontext);",
                        "\t\t\t\tIType newType = instantiateType(origInstance.getType(), context);",
                        "\t\t\t\tIType[] newExceptionSpecs = instantiateTypes(origInstance.getExceptionSpecification(), context);",
                        "\t\t\t\tCPPFunctionInstance result = new CPPFunctionInstance(",
                        "\t\t\t\t\t\t(ICPPFunction) origInstance.getTemplateDefinition(), origInstance.getOwner(), newMap, newArgs,",
                        "\t\t\t\t\t\t(ICPPFunctionType) newType, newExceptionSpecs);",
                        "\t\t\t\tresult.setParameters(specializeParameters(origInstance.getParameters(), result, context, maxDepth));",
                        "\t\t\t\treturn result;",
                        "\t\t\t}",
                        "\t\t} else if (binding instanceof ICPPVariableInstance) {",
                        "\t\t\t// TODO(nathanridge):",
                        "\t\t\t//   Similar to the ICPPFunctionInstance case above, perhaps we should have an",
                        "\t\t\t//   ICPPDeferredVariableInstance.",
                        "\t\t\tICPPVariableInstance origInstance = (ICPPVariableInstance) binding;",
                        "\t\t\tICPPTemplateArgument[] origArgs = origInstance.getTemplateArguments();",
                        "\t\t\tICPPTemplateArgument[] newArgs = instantiateArguments(origArgs, context, false);",
                        "\t\t\tif (origArgs != newArgs) {",
                        "\t\t\t\tCPPTemplateParameterMap newMap = instantiateArgumentMap(origInstance.getTemplateParameterMap(),",
                        "\t\t\t\t\t\tcontext);",
                        "\t\t\t\tIType newType = instantiateType(origInstance.getType(), context);",
                        "\t\t\t\tIValue newValue = instantiateValue(origInstance.getInitialValue(), context,",
                        "\t\t\t\t\t\tIntegralValue.MAX_RECURSION_DEPTH);",
                        "\t\t\t\treturn new CPPVariableInstance(origInstance.getTemplateDefinition(), origInstance.getOwner(), newMap,",
                        "\t\t\t\t\t\tnewArgs, newType, newValue);",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\treturn binding;",
                        "\t}",
                        "",
                        "\tpublic static IType resolveTemplateTypeParameter(final ICPPTemplateParameter tpar, InstantiationContext context) {",
                        "\t\tICPPTemplateArgument arg = null;",
                        "\t\tif (tpar.isParameterPack()) {",
                        "\t\t\tif (context.hasPackOffset()) {",
                        "\t\t\t\tICPPTemplateArgument[] args = context.getPackExpansion(tpar);",
                        "\t\t\t\tif (args != null) {",
                        "\t\t\t\t\tif (context.getPackOffset() >= args.length) {",
                        "\t\t\t\t\t\treturn new ProblemBinding(CPPSemantics.getCurrentLookupPoint(),",
                        "\t\t\t\t\t\t\t\tIProblemBinding.SEMANTIC_INVALID_TYPE, tpar.getNameCharArray());",
                        "\t\t\t\t\t}",
                        "\t\t\t\t\targ = args[context.getPackOffset()];",
                        "\t\t\t\t}",
                        "\t\t\t\tif (context.shouldExpandPack()) {",
                        "\t\t\t\t\tif (arg != null) {",
                        "\t\t\t\t\t\tIType type = arg.getTypeValue();",
                        "\t\t\t\t\t\tif (type instanceof ICPPParameterPackType) {",
                        "\t\t\t\t\t\t\targ = new CPPTemplateTypeArgument(((ICPPParameterPackType) type).getType());",
                        "\t\t\t\t\t\t\tcontext.setPackExpanded(true);",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t} else {",
                        "\t\t\targ = context.getArgument(tpar);",
                        "\t\t}",
                        "",
                        "\t\tif (arg != null) {",
                        "\t\t\tIType t = arg.getOriginalTypeValue();",
                        "\t\t\tif (t != null)",
                        "\t\t\t\treturn t;",
                        "\t\t}",
                        "\t\treturn (IType) tpar;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Checks whether a given name corresponds to a template declaration and returns the AST node",
                        "\t * for it. This works for the name of a template-definition and also for a name needed to",
                        "\t * qualify a member definition:",
                        "\t * <pre>",
                        "\t * template &lt;typename T&gt; void MyTemplate&ltT&gt;::member() {}",
                        "\t * </pre>",
                        "\t * @param name a name for which the corresponding template declaration is searched for.",
                        "\t * @return the template declaration or {@code null} if {@code name} does not correspond",
                        "\t *     to a template declaration.",
                        "\t */",
                        "\tpublic static ICPPASTTemplateDeclaration getTemplateDeclaration(IASTName name) {",
                        "\t\tif (name == null)",
                        "\t\t\treturn null;",
                        "",
                        "\t\t// first look for a related sequence of template declarations",
                        "\t\tICPPASTInternalTemplateDeclaration tdecl = getInnerTemplateDeclaration(name);",
                        "\t\tif (tdecl == null)",
                        "\t\t\treturn null;",
                        "",
                        "\t\tname = name.getLastName();",
                        "\t\tIASTNode parent = name.getParent();",
                        "\t\tif (!(parent instanceof ICPPASTQualifiedName)) {",
                        "\t\t\tif (parent instanceof ICPPASTTemplateId) {",
                        "\t\t\t\treturn null;",
                        "\t\t\t}",
                        "\t\t\t// One name: use innermost template declaration",
                        "\t\t\treturn tdecl;",
                        "\t\t}",
                        "",
                        "\t\t// last name can be associated even if it is not a template-id",
                        "\t\tfinal ICPPASTQualifiedName qname = (ICPPASTQualifiedName) parent;",
                        "\t\tfinal IASTName lastName = qname.getLastName();",
                        "\t\tfinal boolean lastIsTemplate = tdecl.isAssociatedWithLastName();",
                        "\t\tif (name == lastName) {",
                        "\t\t\tif (lastIsTemplate) {",
                        "\t\t\t\treturn tdecl;",
                        "\t\t\t}",
                        "\t\t\treturn null;",
                        "\t\t}",
                        "",
                        "\t\t// Not the last name, search for the matching template declaration",
                        "\t\tif (!(name instanceof ICPPASTTemplateId))",
                        "\t\t\treturn null;",
                        "",
                        "\t\tif (lastIsTemplate) {",
                        "\t\t\t// skip one",
                        "\t\t\ttdecl = getDirectlyEnclosingTemplateDeclaration(tdecl);",
                        "\t\t}",
                        "\t\tfinal ICPPASTNameSpecifier[] qualifier = qname.getQualifier();",
                        "\t\tfor (int i = qualifier.length - 1; tdecl != null && i >= 0; i--) {",
                        "\t\t\tfinal ICPPASTNameSpecifier n = qualifier[i];",
                        "\t\t\tif (n == name) {",
                        "\t\t\t\treturn tdecl;",
                        "\t\t\t}",
                        "\t\t\tif (n instanceof ICPPASTTemplateId) {",
                        "\t\t\t\ttdecl = getDirectlyEnclosingTemplateDeclaration(tdecl);",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\t// not enough template declarations",
                        "\t\treturn null;",
                        "\t}",
                        "",
                        "\tpublic static void associateTemplateDeclarations(ICPPASTInternalTemplateDeclaration tdecl) {",
                        "\t\t// Find innermost template declaration",
                        "\t\tIASTDeclaration decl = tdecl.getDeclaration();",
                        "\t\twhile (decl instanceof ICPPASTInternalTemplateDeclaration) {",
                        "\t\t\ttdecl = (ICPPASTInternalTemplateDeclaration) decl;",
                        "\t\t\tdecl = tdecl.getDeclaration();",
                        "\t\t}",
                        "\t\tfinal ICPPASTInternalTemplateDeclaration innerMostTDecl = tdecl;",
                        "",
                        "\t\t// Find name declared within the template declaration",
                        "\t\tfinal IASTName declName = getNameForDeclarationInTemplateDeclaration(decl);",
                        "",
                        "\t\t// Count non-empty template declarations",
                        "\t\tint instDeclCount = 0;",
                        "\t\tint tdeclCount = 0;",
                        "\t\tIASTNode node = tdecl;",
                        "\t\twhile (node instanceof ICPPASTInternalTemplateDeclaration) {",
                        "\t\t\ttdecl = (ICPPASTInternalTemplateDeclaration) node;",
                        "\t\t\tnode = node.getParent();",
                        "\t\t\tif (tdecl.getTemplateParameters().length == 0) {",
                        "\t\t\t\tinstDeclCount++;",
                        "\t\t\t} else {",
                        "\t\t\t\tinstDeclCount = 0;",
                        "\t\t\t}",
                        "\t\t\ttdeclCount++;",
                        "\t\t}",
                        "\t\tfinal ICPPASTInternalTemplateDeclaration outerMostTDecl = tdecl;",
                        "\t\tfinal int paramTDeclCount = tdeclCount - instDeclCount;",
                        "",
                        "\t\t// Determine association of names with template declarations",
                        "\t\tboolean lastIsTemplate = true;",
                        "\t\tint nestingLevel;",
                        "\t\tif (declName instanceof ICPPASTQualifiedName) {",
                        "\t\t\tICPPASTQualifiedName qname = (ICPPASTQualifiedName) declName;",
                        "",
                        "\t\t\t// Count dependent-ids",
                        "\t\t\tCharArraySet tparnames = collectTemplateParameterNames(outerMostTDecl);",
                        "\t\t\tint depIDCount = 0;",
                        "\t\t\tIBinding owner = null;",
                        "\t\t\tfinal ICPPASTNameSpecifier[] qualifier = qname.getQualifier();",
                        "\t\t\tfor (int i = 0; i < qualifier.length; i++) {",
                        "\t\t\t\tICPPASTNameSpecifier n = qualifier[i];",
                        "\t\t\t\tif (n instanceof ICPPASTTemplateId) {",
                        "\t\t\t\t\tif (depIDCount > 0 || usesTemplateParameter((ICPPASTTemplateId) n, tparnames)) {",
                        "\t\t\t\t\t\tdepIDCount++;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t\tif (depIDCount == 0) {",
                        "\t\t\t\t\towner = n.resolveBinding();",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (qname.getLastName() instanceof ICPPASTTemplateId || paramTDeclCount > depIDCount // not enough template ids",
                        "\t\t\t\t\t|| qualifier.length < 1 // ::name",
                        "\t\t\t) {",
                        "\t\t\t\tlastIsTemplate = true;",
                        "\t\t\t\tdepIDCount++;",
                        "\t\t\t} else {",
                        "\t\t\t\tlastIsTemplate = false;",
                        "\t\t\t}",
                        "",
                        "\t\t\tnestingLevel = 0;",
                        "\t\t\tif (owner != null) {",
                        "\t\t\t\tint consumesTDecl = 0;",
                        "\t\t\t\tIBinding b = owner;",
                        "\t\t\t\tif (b instanceof IType) {",
                        "\t\t\t\t\tIType t = SemanticUtil.getNestedType((IType) b, TDEF);",
                        "\t\t\t\t\tif (t instanceof IBinding)",
                        "\t\t\t\t\t\tb = (IBinding) t;",
                        "\t\t\t\t}",
                        "\t\t\t\twhile (b != null) {",
                        "\t\t\t\t\tif (b instanceof ICPPTemplateInstance) {",
                        "\t\t\t\t\t\tnestingLevel++;",
                        "\t\t\t\t\t\tif (!((ICPPTemplateInstance) b).isExplicitSpecialization())",
                        "\t\t\t\t\t\t\tconsumesTDecl++;",
                        "\t\t\t\t\t} else if (b instanceof ICPPClassTemplate || b instanceof ICPPClassTemplatePartialSpecialization) {",
                        "\t\t\t\t\t\tnestingLevel++;",
                        "\t\t\t\t\t\tconsumesTDecl++;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t\tb = b.getOwner();",
                        "\t\t\t\t}",
                        "\t\t\t\tif (depIDCount > 0) {",
                        "\t\t\t\t\tnestingLevel += depIDCount;",
                        "\t\t\t\t} else if (consumesTDecl < tdeclCount && !lastIsTemplate) {",
                        "\t\t\t\t\tnestingLevel++;",
                        "\t\t\t\t\tlastIsTemplate = true;",
                        "\t\t\t\t}",
                        "\t\t\t} else {",
                        "\t\t\t\tnestingLevel += depIDCount;",
                        "\t\t\t\tnode = outerMostTDecl.getParent();",
                        "\t\t\t\twhile (node != null) {",
                        "\t\t\t\t\tif (node instanceof ICPPASTInternalTemplateDeclaration) {",
                        "\t\t\t\t\t\tnestingLevel += ((ICPPASTInternalTemplateDeclaration) node).getNestingLevel() + 1;",
                        "\t\t\t\t\t\tbreak;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t\tnode = node.getParent();",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t} else {",
                        "\t\t\tnestingLevel = 1;",
                        "\t\t\tlastIsTemplate = true;",
                        "\t\t\tif (!isFriendFunctionDeclaration(innerMostTDecl.getDeclaration())) {",
                        "\t\t\t\tnode = outerMostTDecl.getParent();",
                        "\t\t\t\twhile (node != null) {",
                        "\t\t\t\t\tif (node instanceof ICPPASTInternalTemplateDeclaration) {",
                        "\t\t\t\t\t\tnestingLevel += ((ICPPASTInternalTemplateDeclaration) node).getNestingLevel() + 1;",
                        "\t\t\t\t\t\tbreak;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t\tnode = node.getParent();",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\tnode = innerMostTDecl;",
                        "\t\twhile (node instanceof ICPPASTInternalTemplateDeclaration) {",
                        "\t\t\tif (--nestingLevel < 0)",
                        "\t\t\t\tnestingLevel = 0;",
                        "\t\t\ttdecl = (ICPPASTInternalTemplateDeclaration) node;",
                        "\t\t\ttdecl.setNestingLevel((short) nestingLevel);",
                        "\t\t\ttdecl.setAssociatedWithLastName(false);",
                        "\t\t\tnode = tdecl.getParent();",
                        "\t\t}",
                        "\t\tinnerMostTDecl.setAssociatedWithLastName(lastIsTemplate);",
                        "\t}",
                        "",
                        "\tprivate static boolean isFriendFunctionDeclaration(IASTDeclaration declaration) {",
                        "\t\twhile (declaration instanceof ICPPASTTemplateDeclaration) {",
                        "\t\t\tdeclaration = ((ICPPASTTemplateDeclaration) declaration).getDeclaration();",
                        "\t\t}",
                        "\t\tif (declaration instanceof IASTSimpleDeclaration) {",
                        "\t\t\tIASTSimpleDeclaration sdecl = (IASTSimpleDeclaration) declaration;",
                        "\t\t\tICPPASTDeclSpecifier declspec = (ICPPASTDeclSpecifier) sdecl.getDeclSpecifier();",
                        "\t\t\tif (declspec.isFriend()) {",
                        "\t\t\t\tIASTDeclarator[] dtors = sdecl.getDeclarators();",
                        "\t\t\t\tif (dtors.length == 1",
                        "\t\t\t\t\t\t&& ASTQueries.findTypeRelevantDeclarator(dtors[0]) instanceof IASTFunctionDeclarator) {",
                        "\t\t\t\t\treturn true;",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\treturn false;",
                        "\t}",
                        "",
                        "\tprivate static CharArraySet collectTemplateParameterNames(ICPPASTTemplateDeclaration tdecl) {",
                        "\t\tCharArraySet set = new CharArraySet(4);",
                        "\t\twhile (true) {",
                        "\t\t\tICPPASTTemplateParameter[] pars = tdecl.getTemplateParameters();",
                        "\t\t\tfor (ICPPASTTemplateParameter par : pars) {",
                        "\t\t\t\tIASTName name = getTemplateParameterName(par);",
                        "\t\t\t\tif (name != null)",
                        "\t\t\t\t\tset.put(name.getLookupKey());",
                        "\t\t\t}",
                        "\t\t\tfinal IASTNode next = tdecl.getDeclaration();",
                        "\t\t\tif (next instanceof ICPPASTTemplateDeclaration) {",
                        "\t\t\t\ttdecl = (ICPPASTTemplateDeclaration) next;",
                        "\t\t\t} else {",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\treturn set;",
                        "\t}",
                        "",
                        "\tprivate static boolean usesTemplateParameter(final ICPPASTTemplateId id, final CharArraySet names) {",
                        "\t\tfinal boolean[] result = { false };",
                        "\t\tASTVisitor v = new ASTVisitor(false) {",
                        "\t\t\t{",
                        "\t\t\t\tshouldVisitNames = true;",
                        "\t\t\t\tshouldVisitAmbiguousNodes = true;",
                        "\t\t\t}",
                        "",
                        "\t\t\t@Override",
                        "\t\t\tpublic int visit(IASTName name) {",
                        "\t\t\t\tif (name instanceof ICPPASTTemplateId)",
                        "\t\t\t\t\treturn PROCESS_CONTINUE;",
                        "\t\t\t\tif (name instanceof ICPPASTQualifiedName) {",
                        "\t\t\t\t\tICPPASTQualifiedName qname = (ICPPASTQualifiedName) name;",
                        "\t\t\t\t\tif (qname.isFullyQualified())",
                        "\t\t\t\t\t\treturn PROCESS_SKIP;",
                        "\t\t\t\t\treturn PROCESS_CONTINUE;",
                        "\t\t\t\t}",
                        "",
                        "\t\t\t\tif (names.containsKey(name.getLookupKey())) {",
                        "\t\t\t\t\tIASTNode parent = name.getParent();",
                        "\t\t\t\t\tif (parent instanceof ICPPASTQualifiedName) {",
                        "\t\t\t\t\t\tICPPASTNameSpecifier[] qualifier = ((ICPPASTQualifiedName) parent).getQualifier();",
                        "\t\t\t\t\t\tif (qualifier.length > 0 && qualifier[0] != name) {",
                        "\t\t\t\t\t\t\treturn PROCESS_CONTINUE;",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t\tresult[0] = true;",
                        "\t\t\t\t\t\treturn PROCESS_ABORT;",
                        "\t\t\t\t\t} else if (parent instanceof IASTIdExpression || parent instanceof ICPPASTNamedTypeSpecifier) {",
                        "\t\t\t\t\t\tresult[0] = true;",
                        "\t\t\t\t\t\treturn PROCESS_ABORT;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t\treturn PROCESS_CONTINUE;",
                        "\t\t\t}",
                        "",
                        "\t\t\t@Override",
                        "\t\t\tpublic int visit(ASTAmbiguousNode node) {",
                        "\t\t\t\tIASTNode[] alternatives = node.getNodes();",
                        "\t\t\t\tfor (IASTNode alt : alternatives) {",
                        "\t\t\t\t\tif (!alt.accept(this))",
                        "\t\t\t\t\t\treturn PROCESS_ABORT;",
                        "\t\t\t\t}",
                        "\t\t\t\treturn PROCESS_CONTINUE;",
                        "\t\t\t}",
                        "\t\t};",
                        "\t\tid.accept(v);",
                        "\t\treturn result[0];",
                        "\t}",
                        "",
                        "\tprivate static IASTName getNameForDeclarationInTemplateDeclaration(IASTDeclaration decl) {",
                        "\t\tIASTName name = null;",
                        "\t\tif (decl instanceof IASTSimpleDeclaration) {",
                        "\t\t\tIASTSimpleDeclaration sdecl = (IASTSimpleDeclaration) decl;",
                        "\t\t\tIASTDeclarator[] dtors = sdecl.getDeclarators();",
                        "\t\t\tif (dtors != null && dtors.length > 0) {",
                        "\t\t\t\tname = ASTQueries.findInnermostDeclarator(dtors[0]).getName();",
                        "\t\t\t} else {",
                        "\t\t\t\tIASTDeclSpecifier declspec = sdecl.getDeclSpecifier();",
                        "\t\t\t\tif (declspec instanceof IASTCompositeTypeSpecifier) {",
                        "\t\t\t\t\tname = ((IASTCompositeTypeSpecifier) declspec).getName();",
                        "\t\t\t\t} else if (declspec instanceof IASTElaboratedTypeSpecifier) {",
                        "\t\t\t\t\tname = ((IASTElaboratedTypeSpecifier) declspec).getName();",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t} else if (decl instanceof IASTFunctionDefinition) {",
                        "\t\t\tIASTFunctionDefinition fdef = (IASTFunctionDefinition) decl;",
                        "\t\t\tname = ASTQueries.findInnermostDeclarator(fdef.getDeclarator()).getName();",
                        "\t\t}",
                        "\t\treturn name;",
                        "\t}",
                        "",
                        "\tprivate static ICPPASTInternalTemplateDeclaration getInnerTemplateDeclaration(final IASTName name) {",
                        "\t\tIASTNode parent = name.getParent();",
                        "\t\twhile (parent instanceof IASTName) {",
                        "\t\t\tparent = parent.getParent();",
                        "\t\t}",
                        "\t\tif (parent instanceof IASTDeclSpecifier) {",
                        "\t\t\tif (!(parent instanceof IASTCompositeTypeSpecifier) && !(parent instanceof IASTElaboratedTypeSpecifier)) {",
                        "\t\t\t\treturn null;",
                        "\t\t\t}",
                        "\t\t\tparent = parent.getParent();",
                        "\t\t} else {",
                        "\t\t\twhile (parent instanceof IASTDeclarator) {",
                        "\t\t\t\tparent = parent.getParent();",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\tif (!(parent instanceof IASTDeclaration))",
                        "\t\t\treturn null;",
                        "",
                        "\t\tparent = parent.getParent();",
                        "\t\tif (parent instanceof ICPPASTInternalTemplateDeclaration)",
                        "\t\t\treturn (ICPPASTInternalTemplateDeclaration) parent;",
                        "",
                        "\t\treturn null;",
                        "\t}",
                        "",
                        "\tprivate static ICPPASTInternalTemplateDeclaration getDirectlyEnclosingTemplateDeclaration(",
                        "\t\t\tICPPASTInternalTemplateDeclaration tdecl) {",
                        "\t\tfinal IASTNode parent = tdecl.getParent();",
                        "\t\tif (parent instanceof ICPPASTInternalTemplateDeclaration)",
                        "\t\t\treturn (ICPPASTInternalTemplateDeclaration) parent;",
                        "",
                        "\t\treturn null;",
                        "\t}",
                        "",
                        "\tpublic static IASTName getTemplateName(ICPPASTTemplateDeclaration templateDecl) {",
                        "\t\tif (templateDecl == null)",
                        "\t\t\treturn null;",
                        "",
                        "\t\tICPPASTTemplateDeclaration decl = templateDecl;",
                        "\t\twhile (decl.getParent() instanceof ICPPASTTemplateDeclaration)",
                        "\t\t\tdecl = (ICPPASTTemplateDeclaration) decl.getParent();",
                        "",
                        "\t\tIASTDeclaration nestedDecl = templateDecl.getDeclaration();",
                        "\t\twhile (nestedDecl instanceof ICPPASTTemplateDeclaration) {",
                        "\t\t\tnestedDecl = ((ICPPASTTemplateDeclaration) nestedDecl).getDeclaration();",
                        "\t\t}",
                        "",
                        "\t\tIASTName name = null;",
                        "\t\tif (nestedDecl instanceof IASTSimpleDeclaration) {",
                        "\t\t\tIASTSimpleDeclaration simple = (IASTSimpleDeclaration) nestedDecl;",
                        "\t\t\tif (simple.getDeclarators().length == 1) {",
                        "\t\t\t\tIASTDeclarator dtor = simple.getDeclarators()[0];",
                        "\t\t\t\twhile (dtor.getNestedDeclarator() != null)",
                        "\t\t\t\t\tdtor = dtor.getNestedDeclarator();",
                        "\t\t\t\tname = dtor.getName();",
                        "\t\t\t} else if (simple.getDeclarators().length == 0) {",
                        "\t\t\t\tIASTDeclSpecifier spec = simple.getDeclSpecifier();",
                        "\t\t\t\tif (spec instanceof ICPPASTCompositeTypeSpecifier) {",
                        "\t\t\t\t\tname = ((ICPPASTCompositeTypeSpecifier) spec).getName();",
                        "\t\t\t\t} else if (spec instanceof ICPPASTElaboratedTypeSpecifier) {",
                        "\t\t\t\t\tname = ((ICPPASTElaboratedTypeSpecifier) spec).getName();",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t} else if (nestedDecl instanceof IASTFunctionDefinition) {",
                        "\t\t\tIASTDeclarator declarator = ((IASTFunctionDefinition) nestedDecl).getDeclarator();",
                        "\t\t\tdeclarator = ASTQueries.findInnermostDeclarator(declarator);",
                        "\t\t\tname = declarator.getName();",
                        "\t\t} else if (nestedDecl instanceof ICPPASTAliasDeclaration) {",
                        "\t\t\tname = ((ICPPASTAliasDeclaration) nestedDecl).getAlias();",
                        "\t\t}",
                        "\t\tif (name != null) {",
                        "\t\t\tif (name instanceof ICPPASTQualifiedName) {",
                        "\t\t\t\tICPPASTNameSpecifier[] qualifier = ((ICPPASTQualifiedName) name).getQualifier();",
                        "\t\t\t\tIASTDeclaration currDecl = decl;",
                        "\t\t\t\tfor (ICPPASTNameSpecifier segment : qualifier) {",
                        "\t\t\t\t\tif (segment instanceof ICPPASTTemplateId) {",
                        "\t\t\t\t\t\tif (currDecl == templateDecl) {",
                        "\t\t\t\t\t\t\treturn (IASTName) segment;",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t\tif (!(currDecl instanceof ICPPASTTemplateDeclaration)) {",
                        "\t\t\t\t\t\t\treturn null;",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t\tcurrDecl = ((ICPPASTTemplateDeclaration) currDecl).getDeclaration();",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t\tif (currDecl == templateDecl) {",
                        "\t\t\t\t\treturn name.getLastName();",
                        "\t\t\t\t}",
                        "\t\t\t} else {",
                        "\t\t\t\treturn name;",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\treturn null;",
                        "\t}",
                        "",
                        "\tpublic static boolean areSameArguments(ICPPTemplateArgument[] args, ICPPTemplateArgument[] specArgs) {",
                        "\t\tif (args.length != specArgs.length) {",
                        "\t\t\treturn false;",
                        "\t\t}",
                        "\t\tfor (int i = 0; i < args.length; i++) {",
                        "\t\t\tif (!specArgs[i].isSameValue(args[i]))",
                        "\t\t\t\treturn false;",
                        "\t\t}",
                        "\t\treturn true;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * @param id the template id containing the template arguments",
                        "\t * @return an array of template arguments, currently modeled as IType objects.",
                        "\t *\t The empty ICPPTemplateArgument array is returned if id is {@code null}",
                        "\t */",
                        "\tpublic static ICPPTemplateArgument[] createTemplateArgumentArray(ICPPASTTemplateId id) throws DOMException {",
                        "\t\tICPPTemplateArgument[] result = ICPPTemplateArgument.EMPTY_ARGUMENTS;",
                        "\t\tif (id != null) {",
                        "\t\t\tIASTNode[] args = id.getTemplateArguments();",
                        "\t\t\tresult = new ICPPTemplateArgument[args.length];",
                        "\t\t\tfor (int i = 0; i < args.length; i++) {",
                        "\t\t\t\tIASTNode arg = args[i];",
                        "\t\t\t\tif (arg instanceof IASTTypeId) {",
                        "\t\t\t\t\tresult[i] = new CPPTemplateTypeArgument(CPPVisitor.createType((IASTTypeId) arg));",
                        "\t\t\t\t} else if (arg instanceof ICPPASTExpression) {",
                        "\t\t\t\t\tICPPASTExpression expr = (ICPPASTExpression) arg;",
                        "\t\t\t\t\tCPPSemantics.pushLookupPoint(expr);",
                        "\t\t\t\t\ttry {",
                        "\t\t\t\t\t\tresult[i] = new CPPTemplateNonTypeArgument(expr.getEvaluation());",
                        "\t\t\t\t\t} finally {",
                        "\t\t\t\t\t\tCPPSemantics.popLookupPoint();",
                        "\t\t\t\t\t}",
                        "\t\t\t\t} else if (arg instanceof ICPPASTAmbiguousTemplateArgument) {",
                        "\t\t\t\t\tIProblemBinding problem = new ProblemBinding(id,",
                        "\t\t\t\t\t\t\tIProblemBinding.SEMANTIC_INVALID_TEMPLATE_ARGUMENTS);",
                        "\t\t\t\t\tthrow new DOMException(problem);",
                        "\t\t\t\t} else {",
                        "\t\t\t\t\tthrow new IllegalArgumentException(\"Unexpected type: \" + arg.getClass().getName()); //$NON-NLS-1$",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\treturn result;",
                        "\t}",
                        "",
                        "\tstatic ICPPFunction[] instantiateForFunctionCall(ICPPFunction[] fns, ICPPTemplateArgument[] tmplArgs,",
                        "\t\t\tList<IType> fnArgs, List<ValueCategory> argCats, boolean withImpliedObjectArg) {",
                        "\t\t// Extract template arguments.",
                        "\t\tboolean requireTemplate = tmplArgs != null;",
                        "\t\tboolean haveTemplate = false;",
                        "",
                        "\t\tfor (final ICPPFunction func : fns) {",
                        "\t\t\tif (func instanceof ICPPConstructor || (func instanceof ICPPMethod && ((ICPPMethod) func).isDestructor()))",
                        "\t\t\t\trequireTemplate = false;",
                        "",
                        "\t\t\tif (func instanceof ICPPFunctionTemplate) {",
                        "\t\t\t\tif (containsDependentType(fnArgs))",
                        "\t\t\t\t\treturn new ICPPFunction[] { CPPDeferredFunction.createForCandidates(fns) };",
                        "",
                        "\t\t\t\tif (requireTemplate && hasDependentArgument(tmplArgs))",
                        "\t\t\t\t\treturn new ICPPFunction[] { CPPDeferredFunction.createForCandidates(fns) };",
                        "",
                        "\t\t\t\thaveTemplate = true;",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\tif (!haveTemplate && !requireTemplate)",
                        "\t\t\treturn fns;",
                        "",
                        "\t\tfinal List<ICPPFunction> result = new ArrayList<>(fns.length);",
                        "\t\tfor (ICPPFunction fn : fns) {",
                        "\t\t\tif (fn != null) {",
                        "\t\t\t\tif (fn instanceof ICPPFunctionTemplate) {",
                        "\t\t\t\t\tICPPFunctionTemplate fnTmpl = (ICPPFunctionTemplate) fn;",
                        "\t\t\t\t\tICPPFunction inst = instantiateForFunctionCall(fnTmpl, tmplArgs, fnArgs, argCats,",
                        "\t\t\t\t\t\t\twithImpliedObjectArg);",
                        "\t\t\t\t\tif (inst != null)",
                        "\t\t\t\t\t\tresult.add(inst);",
                        "\t\t\t\t} else if (!requireTemplate || fn instanceof ICPPUnknownBinding) {",
                        "\t\t\t\t\tresult.add(fn);",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\treturn result.toArray(new ICPPFunction[result.size()]);",
                        "\t}",
                        "",
                        "\tprivate static ICPPFunction instantiateForFunctionCall(ICPPFunctionTemplate template,",
                        "\t\t\tICPPTemplateArgument[] tmplArgs, List<IType> fnArgs, List<ValueCategory> argCats,",
                        "\t\t\tboolean withImpliedObjectArg) {",
                        "\t\tif (withImpliedObjectArg && template instanceof ICPPMethod) {",
                        "\t\t\tfnArgs = fnArgs.subList(1, fnArgs.size());",
                        "\t\t\targCats = argCats.subList(1, argCats.size());",
                        "\t\t}",
                        "",
                        "\t\tCPPTemplateParameterMap map = new CPPTemplateParameterMap(fnArgs.size());",
                        "\t\ttry {",
                        "\t\t\tICPPTemplateArgument[] args = TemplateArgumentDeduction.deduceForFunctionCall(template, tmplArgs, fnArgs,",
                        "\t\t\t\t\targCats, map);",
                        "\t\t\tif (args != null) {",
                        "\t\t\t\tIBinding instance = instantiateFunctionTemplate(template, args, map);",
                        "\t\t\t\tif (instance instanceof ICPPFunction) {",
                        "\t\t\t\t\tfinal ICPPFunction f = (ICPPFunction) instance;",
                        "\t\t\t\t\tif (isValidFunctionType(f.getType())) {",
                        "\t\t\t\t\t\t// The number of arguments have been checked against the function",
                        "\t\t\t\t\t\t// template's required argument count at an earlier stage. However,",
                        "\t\t\t\t\t\t// the process of instantiation can increase the required argument",
                        "\t\t\t\t\t\t// count by expanding parameter packs. If arguments are provided",
                        "\t\t\t\t\t\t// for a parameter pack explicitly, it's possible for deduction to",
                        "\t\t\t\t\t\t// succeed without having enough function arguments to match a",
                        "\t\t\t\t\t\t// corresponding function parameter pack - so we check again.",
                        "\t\t\t\t\t\tif (fnArgs.size() >= f.getRequiredArgumentCount())",
                        "\t\t\t\t\t\t\treturn f;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t} catch (DOMException e) {",
                        "\t\t}",
                        "\t\treturn null;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Checks if the given function type is problem-free and that the return type is not a function set.",
                        "\t */",
                        "\tpublic static boolean isValidFunctionType(IFunctionType type) {",
                        "\t\tif (!SemanticUtil.isValidType(type))",
                        "\t\t\treturn false;",
                        "",
                        "\t\tIType t = type.getReturnType();",
                        "\t\tt = SemanticUtil.getNestedType(t, ALLCVQ | TDEF | REF);",
                        "\t\tif (t instanceof IPointerType)",
                        "\t\t\tt = ((IPointerType) t).getType();",
                        "\t\tif (t instanceof FunctionSetType)",
                        "\t\t\treturn false;",
                        "\t\treturn true;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * 14.8.2.3 Deducing conversion function template arguments",
                        "\t * @param point",
                        "\t */",
                        "\tstatic ICPPFunction[] instantiateConversionTemplates(ICPPFunction[] functions, IType conversionType) {",
                        "\t\tboolean checkedForDependentType = false;",
                        "\t\tICPPFunction[] result = functions;",
                        "\t\tint i = 0;",
                        "\t\tboolean done = false;",
                        "\t\tfor (ICPPFunction f : functions) {",
                        "\t\t\tICPPFunction inst = f;",
                        "\t\t\tif (f instanceof ICPPFunctionTemplate) {",
                        "\t\t\t\tICPPFunctionTemplate template = (ICPPFunctionTemplate) f;",
                        "\t\t\t\tinst = null;",
                        "",
                        "\t\t\t\t// Extract template arguments and parameter types.",
                        "\t\t\t\tif (!checkedForDependentType) {",
                        "\t\t\t\t\tif (isDependentType(conversionType)) {",
                        "\t\t\t\t\t\tinst = CPPDeferredFunction.createForCandidates(functions);",
                        "\t\t\t\t\t\tdone = true;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t\tcheckedForDependentType = true;",
                        "\t\t\t\t}",
                        "\t\t\t\tCPPTemplateParameterMap map = new CPPTemplateParameterMap(1);",
                        "\t\t\t\ttry {",
                        "\t\t\t\t\tICPPTemplateArgument[] args = TemplateArgumentDeduction.deduceForConversion(template,",
                        "\t\t\t\t\t\t\tconversionType, map);",
                        "\t\t\t\t\tif (args != null) {",
                        "\t\t\t\t\t\tIBinding instance = instantiateFunctionTemplate(template, args, map);",
                        "\t\t\t\t\t\tif (instance instanceof ICPPFunction) {",
                        "\t\t\t\t\t\t\tinst = (ICPPFunction) instance;",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t}",
                        "\t\t\t\t} catch (DOMException e) {",
                        "\t\t\t\t\t// try next candidate",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t\tif (result != functions || f != inst) {",
                        "\t\t\t\tif (result == functions) {",
                        "\t\t\t\t\tresult = new ICPPFunction[functions.length];",
                        "\t\t\t\t\tSystem.arraycopy(functions, 0, result, 0, i);",
                        "\t\t\t\t}",
                        "\t\t\t\tresult[i++] = inst;",
                        "\t\t\t}",
                        "\t\t\tif (done)",
                        "\t\t\t\tbreak;",
                        "\t\t}",
                        "\t\treturn result;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * 14.8.2.6 Deducing template arguments from a function declaration",
                        "\t * @param point",
                        "\t * @return",
                        "\t */",
                        "\tstatic ICPPFunction instantiateForFunctionDeclaration(ICPPFunctionTemplate template, ICPPTemplateArgument[] args,",
                        "\t\t\tICPPFunctionType functionType) {",
                        "\t\tCPPTemplateParameterMap map = new CPPTemplateParameterMap(1);",
                        "\t\ttry {",
                        "\t\t\targs = TemplateArgumentDeduction.deduceForDeclaration(template, args, functionType, map);",
                        "\t\t\tif (args != null) {",
                        "\t\t\t\tIBinding instance = instantiateFunctionTemplate(template, args, map);",
                        "\t\t\t\tif (instance instanceof ICPPFunction) {",
                        "\t\t\t\t\treturn (ICPPFunction) instance;",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t} catch (DOMException e) {",
                        "\t\t\t// try next candidate",
                        "\t\t}",
                        "\t\treturn null;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * 14.8.2.2 Deducing template arguments taking the address of a function template [temp.deduct.funcaddr]",
                        "\t */",
                        "\tstatic ICPPFunction instantiateForAddressOfFunction(ICPPFunctionTemplate template, IFunctionType target,",
                        "\t\t\tICPPTemplateArgument[] args) {",
                        "\t\ttry {",
                        "\t\t\tif (target != null && isDependentType(target)) {",
                        "\t\t\t\treturn CPPDeferredFunction.createForCandidates(template);",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (template instanceof ICPPConstructor || args == null)",
                        "\t\t\t\targs = ICPPTemplateArgument.EMPTY_ARGUMENTS;",
                        "",
                        "\t\t\tCPPTemplateParameterMap map = new CPPTemplateParameterMap(4);",
                        "\t\t\targs = TemplateArgumentDeduction.deduceForAddressOf(template, args, target, map);",
                        "\t\t\tif (args != null) {",
                        "\t\t\t\tIBinding instance = instantiateFunctionTemplate(template, args, map);",
                        "\t\t\t\tif (instance instanceof ICPPFunction) {",
                        "\t\t\t\t\treturn (ICPPFunction) instance;",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t} catch (DOMException e) {",
                        "\t\t}",
                        "\t\treturn null;",
                        "\t}",
                        "",
                        "\t// 14.5.6.2 Partial ordering of function templates"
                    ]
                },
                {
                    "a": [
                        "\tstatic int orderFunctionTemplates(ICPPFunctionTemplate f1, ICPPFunctionTemplate f2, TypeSelection mode)",
                        "\t\t\tthrows DOMException {"
                    ],
                    "b": [
                        "\tstatic int orderFunctionTemplates(ICPPFunctionTemplate f1, ICPPFunctionTemplate f2, TypeSelection mode,",
                        "\t\t\tint nExplicitArgs) throws DOMException {"
                    ]
                },
                {
                    "ab": [
                        "\t\tif (f1 == f2)",
                        "\t\t\treturn 0;",
                        "\t\tif (f1 == null)",
                        "\t\t\treturn -1;",
                        "\t\tif (f2 == null)",
                        "\t\t\treturn 1;",
                        ""
                    ]
                },
                {
                    "a": [
                        "\t\tint s1 = compareSpecialization(f1, f2, mode);",
                        "\t\tint s2 = compareSpecialization(f2, f1, mode);"
                    ],
                    "b": [
                        "\t\tint s1 = compareSpecialization(f1, f2, mode, nExplicitArgs);",
                        "\t\tint s2 = compareSpecialization(f2, f1, mode, nExplicitArgs);"
                    ]
                },
                {
                    "ab": [
                        "",
                        "\t\tif (s1 == s2)",
                        "\t\t\treturn 0;",
                        "\t\tif (s1 < 0 || s2 > 0)",
                        "\t\t\treturn -1;",
                        "\t\tassert s2 < 0 || s1 > 0;",
                        "\t\treturn 1;",
                        "\t}",
                        ""
                    ]
                },
                {
                    "b": [
                        "\tstatic int orderFunctionTemplates(ICPPFunctionTemplate f1, ICPPFunctionTemplate f2, TypeSelection mode)",
                        "\t\t\tthrows DOMException {",
                        "\t\treturn orderFunctionTemplates(f1, f2, mode, 0);",
                        "\t}",
                        ""
                    ]
                },
                {
                    "ab": [
                        "\tprivate static ICPPFunction transferFunctionTemplate(ICPPFunctionTemplate f) throws DOMException {",
                        "\t\tfinal ICPPTemplateParameter[] tpars = f.getTemplateParameters();",
                        "\t\tfinal int argLen = tpars.length;",
                        "",
                        "\t\t// Create arguments and map",
                        "\t\tICPPTemplateArgument[] args = new ICPPTemplateArgument[argLen];",
                        "\t\tCPPTemplateParameterMap map = new CPPTemplateParameterMap(argLen);",
                        "\t\tfor (int i = 0; i < argLen; i++) {",
                        "\t\t\tfinal ICPPTemplateParameter tpar = tpars[i];",
                        "\t\t\tfinal ICPPTemplateArgument arg = uniqueArg(tpar);",
                        "\t\t\targs[i] = arg;",
                        "\t\t\tif (tpar.isParameterPack()) {",
                        "\t\t\t\tmap.put(tpar, new ICPPTemplateArgument[] { arg });",
                        "\t\t\t} else {",
                        "\t\t\t\tmap.put(tpar, arg);",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\tIBinding result = instantiateFunctionTemplate(f, args, map);",
                        "\t\tif (result instanceof ICPPFunction)",
                        "\t\t\treturn (ICPPFunction) result;",
                        "",
                        "\t\treturn null;",
                        "\t}",
                        "",
                        "\tprivate static ICPPTemplateArgument uniqueArg(final ICPPTemplateParameter tpar) throws DOMException {",
                        "\t\tfinal ICPPTemplateArgument arg;",
                        "\t\tif (tpar instanceof ICPPTemplateNonTypeParameter) {",
                        "\t\t\targ = new CPPTemplateNonTypeArgument(IntegralValue.unique(),",
                        "\t\t\t\t\t((ICPPTemplateNonTypeParameter) tpar).getType());",
                        "\t\t} else {",
                        "\t\t\targ = new CPPTemplateTypeArgument(new UniqueType(tpar.isParameterPack()));",
                        "\t\t}",
                        "\t\treturn arg;",
                        "\t}",
                        ""
                    ]
                },
                {
                    "a": [
                        "\tprivate static ICPPFunctionType getFunctionTypeIgnoringParametersWithDefaults(ICPPFunction function) {"
                    ],
                    "b": [
                        "\tprivate static ICPPFunctionType getFunctionTypeIgnoringParametersWithDefaults(ICPPFunction function,",
                        "\t\t\tint nExplicitArgs) {"
                    ]
                },
                {
                    "ab": [
                        "\t\tICPPParameter[] parameters = function.getParameters();",
                        "\t\tIType[] parameterTypes = new IType[parameters.length];",
                        "\t\tint i;",
                        "\t\tfor (i = 0; i < parameters.length; ++i) {",
                        "\t\t\tICPPParameter parameter = parameters[i];"
                    ]
                },
                {
                    "a": [
                        "\t\t\tif (!parameter.hasDefaultValue()) {"
                    ],
                    "b": [
                        "\t\t\tif (i < nExplicitArgs || !parameter.hasDefaultValue()) {"
                    ]
                },
                {
                    "ab": [
                        "\t\t\t\tparameterTypes[i] = parameter.getType();",
                        "\t\t\t} else {",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\tICPPFunctionType originalType = function.getType();",
                        "\t\tif (i == parameters.length) // No parameters with default arguments.",
                        "\t\t\treturn originalType;",
                        "\t\treturn new CPPFunctionType(originalType.getReturnType(), ArrayUtil.trim(parameterTypes), originalType.isConst(),",
                        "\t\t\t\toriginalType.isVolatile(), originalType.hasRefQualifier(), originalType.isRValueReference(),",
                        "\t\t\t\toriginalType.takesVarArgs());",
                        "\t}",
                        ""
                    ]
                },
                {
                    "a": [
                        "\tprivate static int compareSpecialization(ICPPFunctionTemplate f1, ICPPFunctionTemplate f2, TypeSelection mode)",
                        "\t\t\tthrows DOMException {"
                    ],
                    "b": [
                        "\tprivate static int compareSpecialization(ICPPFunctionTemplate f1, ICPPFunctionTemplate f2, TypeSelection mode,",
                        "\t\t\tint nExplicitArgs) throws DOMException {"
                    ]
                },
                {
                    "ab": [
                        "\t\tICPPFunction transF1 = transferFunctionTemplate(f1);",
                        "\t\tif (transF1 == null)",
                        "\t\t\treturn -1;",
                        "",
                        "\t\tfinal ICPPFunctionType ft2 = f2.getType();"
                    ]
                },
                {
                    "b": [
                        "\t\tint nParams = nExplicitArgs;"
                    ]
                },
                {
                    "ab": [
                        "\t\t// Ignore parameters with default arguments in the transformed function template",
                        "\t\t// as per [temp.func.order] p5."
                    ]
                },
                {
                    "a": [
                        "\t\tfinal ICPPFunctionType transFt1 = getFunctionTypeIgnoringParametersWithDefaults(transF1);"
                    ],
                    "b": [
                        "\t\tfinal ICPPFunctionType transFt1 = getFunctionTypeIgnoringParametersWithDefaults(transF1, nParams);"
                    ]
                },
                {
                    "ab": [
                        "\t\tIType[] pars;",
                        "\t\tIType[] args;",
                        "\t\tswitch (mode) {",
                        "\t\tcase RETURN_TYPE:",
                        "\t\t\tpars = new IType[] { ft2.getReturnType() };",
                        "\t\t\targs = new IType[] { transFt1.getReturnType() };",
                        "\t\t\tbreak;",
                        "\t\tcase PARAMETERS_AND_RETURN_TYPE:",
                        "\t\t\tpars = SemanticUtil.concatTypes(ft2.getReturnType(), ft2.getParameterTypes());",
                        "\t\t\targs = SemanticUtil.concatTypes(transFt1.getReturnType(), transFt1.getParameterTypes());",
                        "\t\t\tbreak;",
                        "\t\tcase PARAMETERS:",
                        "\t\tdefault:",
                        "\t\t\tpars = ft2.getParameterTypes();",
                        "\t\t\targs = transFt1.getParameterTypes();",
                        "\t\t\tboolean nonStaticMember1 = isNonStaticMember(f1);",
                        "\t\t\tboolean nonStaticMember2 = isNonStaticMember(f2);",
                        "\t\t\tif (nonStaticMember1 != nonStaticMember2) {",
                        "\t\t\t\tif (nonStaticMember1) {",
                        "\t\t\t\t\targs = SemanticUtil.addImplicitParameterType(args, (ICPPMethod) f1);",
                        "\t\t\t\t} else {",
                        "\t\t\t\t\tpars = SemanticUtil.addImplicitParameterType(pars, (ICPPMethod) f2);",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t\tbreak;",
                        "\t\t}",
                        "\t\treturn TemplateArgumentDeduction.deduceForPartialOrdering(f2.getTemplateParameters(), pars, args);",
                        "\t}",
                        "",
                        "\tprivate static boolean isNonStaticMember(ICPPFunctionTemplate f) {",
                        "\t\treturn (f instanceof ICPPMethod) && !((ICPPMethod) f).isStatic();",
                        "\t}",
                        "",
                        "\tprivate static ICPPPartialSpecialization findPartialSpecialization(ICPPPartiallySpecializable template,",
                        "\t\t\tICPPTemplateArgument[] args) throws DOMException {",
                        "\t\tICPPPartialSpecialization[] pspecs = template.getPartialSpecializations();",
                        "\t\tif (pspecs != null && pspecs.length > 0) {",
                        "\t\t\tfinal String argStr = ASTTypeUtil.getArgumentListString(args, true);",
                        "\t\t\tfor (ICPPPartialSpecialization pspec : pspecs) {",
                        "\t\t\t\tif (argStr.equals(ASTTypeUtil.getArgumentListString(pspec.getTemplateArguments(), true)))",
                        "\t\t\t\t\treturn pspec;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\treturn null;",
                        "\t}",
                        "",
                        "\tstatic IBinding selectSpecialization(ICPPPartiallySpecializable template, ICPPTemplateArgument[] args,",
                        "\t\t\tboolean isDef) throws DOMException {",
                        "\t\tif (template == null) {",
                        "\t\t\treturn null;",
                        "\t\t}",
                        "\t\tICPPPartialSpecialization[] specializations = template.getPartialSpecializations();",
                        "\t\tif (specializations == null || specializations.length == 0) {",
                        "\t\t\treturn null;",
                        "\t\t}",
                        "",
                        "\t\tICPPPartialSpecialization bestMatch = null;",
                        "\t\tCPPTemplateParameterMap bestMap = null;",
                        "\t\tboolean bestMatchIsBest = true;",
                        "\t\tfor (ICPPPartialSpecialization specialization : specializations) {",
                        "\t\t\tfinal CPPTemplateParameterMap map = new CPPTemplateParameterMap(args.length);",
                        "\t\t\tICPPTemplateArgument[] specializationArguments = specialization.getTemplateArguments();",
                        "\t\t\tif (TemplateArgumentDeduction.fromTemplateArguments(specialization.getTemplateParameters(),",
                        "\t\t\t\t\tspecializationArguments, args, map)",
                        "\t\t\t\t\t&& checkInstantiationOfArguments(specializationArguments, map)) {",
                        "\t\t\t\tint compare = orderSpecializations(bestMatch, specialization);",
                        "\t\t\t\tif (compare == 0) {",
                        "\t\t\t\t\tbestMatchIsBest = false;",
                        "\t\t\t\t} else if (compare < 0) {",
                        "\t\t\t\t\tbestMatch = specialization;",
                        "\t\t\t\t\tbestMap = map;",
                        "\t\t\t\t\tbestMatchIsBest = true;",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\t// 14.5.4.1 If none of the specializations is more specialized than all the other matching",
                        "\t\t// specializations, then the use of the class template is ambiguous and the program is",
                        "\t\t// ill-formed.",
                        "\t\tif (!bestMatchIsBest) {",
                        "\t\t\treturn new CPPTemplateDefinition.CPPTemplateProblem(CPPSemantics.getCurrentLookupPoint(),",
                        "\t\t\t\t\tIProblemBinding.SEMANTIC_AMBIGUOUS_LOOKUP, template.getNameCharArray());",
                        "\t\t}",
                        "",
                        "\t\tif (bestMatch == null)",
                        "\t\t\treturn null;",
                        "",
                        "\t\tif (bestMatch instanceof ICPPClassTemplatePartialSpecialization) {",
                        "\t\t\tbestMatch = SemanticUtil.mapToAST((ICPPClassTemplatePartialSpecialization) bestMatch);",
                        "\t\t}",
                        "",
                        "\t\treturn instantiatePartialSpecialization(bestMatch, args, isDef, bestMap);",
                        "\t}",
                        "",
                        "\tprivate static boolean checkInstantiationOfArguments(ICPPTemplateArgument[] args, CPPTemplateParameterMap tpMap)",
                        "\t\t\tthrows DOMException {",
                        "\t\treturn instantiateArguments(args, new InstantiationContext(tpMap), true) != null;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Compare spec1 to spec2.  Return > 0 if spec1 is more specialized, < 0 if spec2",
                        "\t * is more specialized, = 0 otherwise.",
                        "\t * @param spec1",
                        "\t * @param spec2",
                        "\t * @param point",
                        "\t * @return",
                        "\t * @throws DOMException",
                        "\t */",
                        "\tstatic private int orderSpecializations(ICPPPartialSpecialization spec1, ICPPPartialSpecialization spec2)",
                        "\t\t\tthrows DOMException {",
                        "\t\tif (spec1 == null) {",
                        "\t\t\treturn -1;",
                        "\t\t}",
                        "",
                        "\t\t// we avoid the transformation to function templates, of which the one parameter",
                        "\t\t// will be used in the end.",
                        "",
                        "\t\t// 14.5.5.2",
                        "\t\t// A template is more specialized than another if and only if it is at least as specialized as the",
                        "\t\t// other template and that template is not at least as specialized as the first.",
                        "\t\tboolean f1IsAtLeastAsSpecializedAsF2 = isAtLeastAsSpecializedAs(spec1, spec2);",
                        "\t\tboolean f2IsAtLeastAsSpecializedAsF1 = isAtLeastAsSpecializedAs(spec2, spec1);",
                        "",
                        "\t\tif (f1IsAtLeastAsSpecializedAsF2 == f2IsAtLeastAsSpecializedAsF1)",
                        "\t\t\treturn 0;",
                        "",
                        "\t\tif (f1IsAtLeastAsSpecializedAsF2)",
                        "\t\t\treturn 1;",
                        "",
                        "\t\treturn -1;",
                        "\t}",
                        "",
                        "\tprivate static boolean isAtLeastAsSpecializedAs(ICPPPartialSpecialization f1, ICPPPartialSpecialization f2)",
                        "\t\t\tthrows DOMException {",
                        "\t\t// 14.5.5.2",
                        "\t\t// Using the transformed parameter list, perform argument deduction against the other",
                        "\t\t// function template",
                        "\t\t// The transformed template is at least as specialized as the other if and only if the deduction",
                        "\t\t// succeeds and the deduced parameter types are an exact match.",
                        "\t\tfinal ICPPTemplateParameter[] tpars1 = f1.getTemplateParameters();",
                        "\t\tfinal ICPPTemplateParameter[] tpars2 = f2.getTemplateParameters();",
                        "\t\tfinal ICPPTemplateArgument[] targs1 = f1.getTemplateArguments();",
                        "\t\tfinal ICPPTemplateArgument[] targs2 = f2.getTemplateArguments();",
                        "",
                        "\t\t// Transfer arguments of specialization 1",
                        "\t\tfinal int tpars1Len = tpars1.length;",
                        "\t\tICPPTemplateArgument[] args = new ICPPTemplateArgument[tpars1Len];",
                        "\t\tfinal CPPTemplateParameterMap transferMap = new CPPTemplateParameterMap(tpars1Len);",
                        "\t\tfor (int i = 0; i < tpars1Len; i++) {",
                        "\t\t\tfinal ICPPTemplateParameter param = tpars1[i];",
                        "\t\t\tfinal ICPPTemplateArgument arg = uniqueArg(param);",
                        "\t\t\targs[i] = arg;",
                        "\t\t\tif (param.isParameterPack()) {",
                        "\t\t\t\ttransferMap.put(param, new ICPPTemplateArgument[] { arg });",
                        "\t\t\t} else {",
                        "\t\t\t\ttransferMap.put(param, arg);",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\tfinal ICPPTemplateArgument[] transferredArgs1 = instantiateArguments(targs1,",
                        "\t\t\t\tnew InstantiationContext(transferMap), false);",
                        "",
                        "\t\t// Deduce arguments for specialization 2",
                        "\t\tfinal CPPTemplateParameterMap deductionMap = new CPPTemplateParameterMap(2);",
                        "\t\treturn TemplateArgumentDeduction.fromTemplateArguments(tpars2, targs2, transferredArgs1, deductionMap);",
                        "\t}",
                        "",
                        "\tstatic boolean isValidArgument(ICPPTemplateArgument arg) {",
                        "\t\treturn arg != null",
                        "\t\t\t\t&& SemanticUtil.isValidType(arg.isTypeValue() ? arg.getTypeValue() : arg.getTypeOfNonTypeValue());",
                        "\t}",
                        "",
                        "\tstatic ICPPTemplateArgument matchTemplateParameterAndArgument(ICPPTemplateDefinition template,",
                        "\t\t\tICPPTemplateParameter param, ICPPTemplateArgument arg, CPPTemplateParameterMap map) {",
                        "\t\tif (!isValidArgument(arg)) {",
                        "\t\t\treturn null;",
                        "\t\t}",
                        "\t\tif (param instanceof ICPPTemplateTypeParameter) {",
                        "\t\t\tIType t = arg.getTypeValue();",
                        "\t\t\tif (t != null && !(t instanceof ICPPTemplateDefinition))",
                        "\t\t\t\treturn arg;",
                        "\t\t\treturn null;",
                        "\t\t}",
                        "",
                        "\t\tif (param instanceof ICPPTemplateTemplateParameter) {",
                        "\t\t\tIType t = arg.getTypeValue();",
                        "\t\t\tif (t instanceof ICPPUnknownType)",
                        "\t\t\t\treturn arg;",
                        "\t\t\twhile (!(t instanceof ICPPTemplateDefinition)) {",
                        "\t\t\t\tif (t instanceof ICPPClassSpecialization) {",
                        "\t\t\t\t\t// Undo the effect of specializing a template when the unqualified name",
                        "\t\t\t\t\t// is used within the template itself.",
                        "\t\t\t\t\tt = ((ICPPClassSpecialization) t).getSpecializedBinding();",
                        "\t\t\t\t} else {",
                        "\t\t\t\t\treturn null;",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "",
                        "\t\t\tICPPTemplateParameter[] pParams = null;",
                        "\t\t\tICPPTemplateParameter[] aParams = null;",
                        "\t\t\ttry {",
                        "\t\t\t\tpParams = ((ICPPTemplateTemplateParameter) param).getTemplateParameters();",
                        "\t\t\t\taParams = ((ICPPTemplateDefinition) t).getTemplateParameters();",
                        "\t\t\t\tif (!matchTemplateTemplateParameters(pParams, aParams))",
                        "\t\t\t\t\treturn null;",
                        "\t\t\t} catch (DOMException e) {",
                        "\t\t\t\treturn null;",
                        "\t\t\t}",
                        "",
                        "\t\t\treturn arg;",
                        "\t\t}",
                        "",
                        "\t\tif (param instanceof ICPPTemplateNonTypeParameter) {",
                        "\t\t\tif (!arg.isNonTypeValue())",
                        "\t\t\t\treturn null;",
                        "\t\t\tIType argType = arg.getTypeOfNonTypeValue();",
                        "\t\t\ttry {",
                        "\t\t\t\tIType pType = ((ICPPTemplateNonTypeParameter) param).getType();",
                        "\t\t\t\tif (pType instanceof ICPPParameterPackType) {",
                        "\t\t\t\t\tpType = ((ICPPParameterPackType) pType).getType();",
                        "\t\t\t\t}",
                        "\t\t\t\tif (map != null && pType != null) {",
                        "\t\t\t\t\tpType = instantiateType(pType, new InstantiationContext(map));",
                        "\t\t\t\t}",
                        "",
                        "\t\t\t\tif (argType instanceof ICPPParameterPackType) {",
                        "\t\t\t\t\targType = ((ICPPParameterPackType) argType).getType();",
                        "\t\t\t\t}",
                        "\t\t\t\tif (argType instanceof ICPPUnknownType) {",
                        "\t\t\t\t\treturn new CPPTemplateNonTypeArgument(arg.getNonTypeValue(), pType);",
                        "\t\t\t\t}",
                        "\t\t\t\treturn convertNonTypeTemplateArgument(template, pType, arg);",
                        "\t\t\t} catch (DOMException e) {",
                        "\t\t\t\treturn null;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\tassert false;",
                        "\t\treturn null;",
                        "\t}",
                        "",
                        "\tprivate static boolean matchTemplateTemplateParameters(ICPPTemplateParameter[] pParams,",
                        "\t\t\tICPPTemplateParameter[] aParams) throws DOMException {",
                        "\t\tint pi = 0;",
                        "\t\tint ai = 0;",
                        "\t\twhile (pi < pParams.length && ai < aParams.length) {",
                        "\t\t\tfinal ICPPTemplateParameter pp = pParams[pi];",
                        "\t\t\tfinal ICPPTemplateParameter ap = aParams[ai];",
                        "",
                        "\t\t\t// A parameter pack does not match a regular template parameter.",
                        "\t\t\tif (ap.isParameterPack() && !pp.isParameterPack())",
                        "\t\t\t\treturn false;",
                        "",
                        "\t\t\tboolean pb = pp instanceof ICPPTemplateTypeParameter;",
                        "\t\t\tboolean ab = ap instanceof ICPPTemplateTypeParameter;",
                        "\t\t\tif (pb != ab)",
                        "\t\t\t\treturn false;",
                        "",
                        "\t\t\tif (pb) {",
                        "\t\t\t\t// Both are template type parameters",
                        "\t\t\t} else {",
                        "\t\t\t\tpb = pp instanceof ICPPTemplateNonTypeParameter;",
                        "\t\t\t\tab = ap instanceof ICPPTemplateNonTypeParameter;",
                        "\t\t\t\tif (pb != ab)",
                        "\t\t\t\t\treturn false;",
                        "",
                        "\t\t\t\tif (pb) {",
                        "\t\t\t\t\t// Both are non-type parameters",
                        "\t\t\t\t} else {",
                        "\t\t\t\t\tif (!(pp instanceof ICPPTemplateTemplateParameter)",
                        "\t\t\t\t\t\t\t|| !(ap instanceof ICPPTemplateTemplateParameter)) {",
                        "\t\t\t\t\t\tassert false;",
                        "\t\t\t\t\t\treturn false;",
                        "\t\t\t\t\t}",
                        "",
                        "\t\t\t\t\tif (!matchTemplateTemplateParameters(((ICPPTemplateTemplateParameter) pp).getTemplateParameters(),",
                        "\t\t\t\t\t\t\t((ICPPTemplateTemplateParameter) ap).getTemplateParameters()))",
                        "\t\t\t\t\t\treturn false;",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t\tif (!pp.isParameterPack())",
                        "\t\t\t\tpi++;",
                        "\t\t\tai++;",
                        "\t\t}",
                        "\t\tif (pi < pParams.length) {",
                        "\t\t\tif (pi == pParams.length - 1 && pParams[pi].isParameterPack())",
                        "\t\t\t\treturn true;",
                        "\t\t\treturn false;",
                        "\t\t}",
                        "",
                        "\t\treturn ai == aParams.length;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Converts the template argument {@code arg} to match the parameter type {@code paramType}",
                        "\t * or returns {@code null}, if this violates the rules specified in 14.3.2 - 5.",
                        "\t *",
                        "\t * @throws DOMException",
                        "\t */",
                        "\tprivate static ICPPTemplateArgument convertNonTypeTemplateArgument(ICPPTemplateDefinition template,",
                        "\t\t\tfinal IType paramType, ICPPTemplateArgument arg) throws DOMException {",
                        "\t\t// 14.1s8 function to pointer and array to pointer conversions.",
                        "\t\tIType a = arg.getTypeOfNonTypeValue();",
                        "\t\tif (a instanceof ICPPParameterPackType) {",
                        "\t\t\ta = ((ICPPParameterPackType) a).getType();",
                        "\t\t}",
                        "\t\tIType p;",
                        "\t\tif (paramType instanceof IFunctionType) {",
                        "\t\t\tp = new CPPPointerType(paramType);",
                        "\t\t} else if (paramType instanceof IArrayType) {",
                        "\t\t\tp = new CPPPointerType(((IArrayType) paramType).getType());",
                        "\t\t} else {",
                        "\t\t\tp = paramType;",
                        "\t\t\tif (p != null && p.isSameType(a))",
                        "\t\t\t\treturn arg;",
                        "\t\t}",
                        "",
                        "\t\tif (a instanceof FunctionSetType) {",
                        "\t\t\tif (p instanceof IPointerType) {",
                        "\t\t\t\tp = ((IPointerType) p).getType();",
                        "\t\t\t}",
                        "\t\t\tif (p instanceof IFunctionType) {",
                        "\t\t\t\tfinal CPPFunctionSet functionSet = ((FunctionSetType) a).getFunctionSet();",
                        "\t\t\t\tfor (ICPPFunction f : functionSet.getBindings()) {",
                        "\t\t\t\t\tif (p.isSameType(f.getType())) {",
                        "\t\t\t\t\t\tfunctionSet.applySelectedFunction(f);",
                        "\t\t\t\t\t\treturn new CPPTemplateNonTypeArgument(new EvalBinding(f, null, template));",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t\treturn null;",
                        "\t\t}",
                        "",
                        "\t\tif (paramType instanceof TypeOfDependentExpression) {",
                        "\t\t\t// Partial support for C++17 template <auto>",
                        "\t\t\tTypeOfDependentExpression type = (TypeOfDependentExpression) paramType;",
                        "\t\t\tif (type.isForTemplateAuto()) {",
                        "\t\t\t\treturn arg;",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\tCost cost = Conversions.checkImplicitConversionSequence(p, a, LVALUE, UDCMode.FORBIDDEN, Context.ORDINARY);",
                        "\t\tif (cost == null || !cost.converts()) {",
                        "\t\t\tICPPEvaluation eval = arg.getNonTypeEvaluation();",
                        "\t\t\tICPPEvaluation newEval = CPPEvaluation.maybeApplyConversion(eval, p, false);",
                        "\t\t\tif (newEval == EvalFixed.INCOMPLETE && newEval != eval)",
                        "\t\t\t\treturn null;",
                        "\t\t\treturn new CPPTemplateNonTypeArgument(newEval);",
                        "\t\t}",
                        "",
                        "\t\treturn new CPPTemplateNonTypeArgument(arg.getNonTypeValue(), paramType);",
                        "\t}",
                        "",
                        "\tstatic boolean argsAreTrivial(ICPPTemplateParameter[] pars, ICPPTemplateArgument[] args) {",
                        "\t\tif (pars.length != args.length) {",
                        "\t\t\treturn false;",
                        "\t\t}",
                        "\t\tfor (int i = 0; i < args.length; i++) {",
                        "\t\t\tICPPTemplateParameter par = pars[i];",
                        "\t\t\tICPPTemplateArgument arg = args[i];",
                        "\t\t\tif (par instanceof IType) {",
                        "\t\t\t\tif (arg.isNonTypeValue())",
                        "\t\t\t\t\treturn false;",
                        "\t\t\t\tIType argType = arg.getTypeValue();",
                        "\t\t\t\tif (argType == null)",
                        "\t\t\t\t\treturn false;",
                        "\t\t\t\tif (par.isParameterPack()) {",
                        "\t\t\t\t\tif (!(argType instanceof ICPPParameterPackType))",
                        "\t\t\t\t\t\treturn false;",
                        "\t\t\t\t\targType = ((ICPPParameterPackType) argType).getType();",
                        "\t\t\t\t\tif (argType == null)",
                        "\t\t\t\t\t\treturn false;",
                        "\t\t\t\t}",
                        "\t\t\t\tif (!argType.isSameType((IType) par))",
                        "\t\t\t\t\treturn false;",
                        "\t\t\t} else {",
                        "\t\t\t\tif (arg.isTypeValue())",
                        "\t\t\t\t\treturn false;",
                        "\t\t\t\tif (par.isParameterPack() != arg.isPackExpansion())",
                        "\t\t\t\t\treturn false;",
                        "\t\t\t\tint parpos = IntegralValue.isTemplateParameter(arg.getNonTypeValue());",
                        "\t\t\t\tif (parpos != par.getParameterID())",
                        "\t\t\t\t\treturn false;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\treturn true;",
                        "\t}",
                        "",
                        "\tpublic static boolean hasDependentArgument(ICPPTemplateArgument[] args) {",
                        "\t\tfor (ICPPTemplateArgument arg : args) {",
                        "\t\t\tif (isDependentArgument(arg))",
                        "\t\t\t\treturn true;",
                        "\t\t}",
                        "\t\treturn false;",
                        "\t}",
                        "",
                        "\tpublic static boolean isDependentArgument(ICPPTemplateArgument arg) {",
                        "\t\tif (arg.isTypeValue())",
                        "\t\t\treturn isDependentType(arg.getTypeValue());",
                        "",
                        "\t\tICPPEvaluation evaluation = arg.getNonTypeEvaluation();",
                        "\t\treturn evaluation.isTypeDependent() || evaluation.isValueDependent();",
                        "\t}",
                        "",
                        "\tpublic static boolean containsDependentType(List<IType> ts) {",
                        "\t\tfor (IType t : ts) {",
                        "\t\t\tif (isDependentType(t))",
                        "\t\t\t\treturn true;",
                        "\t\t}",
                        "\t\treturn false;",
                        "\t}",
                        "",
                        "\tpublic static boolean containsDependentType(IType[] ts) {",
                        "\t\tfor (IType t : ts) {",
                        "\t\t\tif (isDependentType(t))",
                        "\t\t\t\treturn true;",
                        "\t\t}",
                        "\t\treturn false;",
                        "\t}",
                        "",
                        "\tpublic static boolean isDependentType(IType t) {",
                        "\t\twhile (true) {",
                        "\t\t\tif (t instanceof ICPPUnknownType)",
                        "\t\t\t\treturn true;",
                        "",
                        "\t\t\tif (t instanceof ICPPFunctionType) {",
                        "\t\t\t\tfinal ICPPFunctionType ft = (ICPPFunctionType) t;",
                        "\t\t\t\tif (containsDependentType(ft.getParameterTypes()))",
                        "\t\t\t\t\treturn true;",
                        "\t\t\t\tt = ft.getReturnType();",
                        "\t\t\t} else if (t instanceof ICPPPointerToMemberType) {",
                        "\t\t\t\tICPPPointerToMemberType ptmt = (ICPPPointerToMemberType) t;",
                        "\t\t\t\tif (isDependentType(ptmt.getMemberOfClass()))",
                        "\t\t\t\t\treturn true;",
                        "\t\t\t\tt = ptmt.getType();",
                        "\t\t\t} else if (t instanceof ICPPParameterPackType) {",
                        "\t\t\t\treturn true;",
                        "\t\t\t} else if (t instanceof ITypeContainer) {",
                        "\t\t\t\tif (t instanceof IArrayType) {",
                        "\t\t\t\t\tIValue asize = ((IArrayType) t).getSize();",
                        "\t\t\t\t\tif (asize != null && IntegralValue.isDependentValue(asize))",
                        "\t\t\t\t\t\treturn true;",
                        "\t\t\t\t}",
                        "\t\t\t\tt = ((ITypeContainer) t).getType();",
                        "\t\t\t} else if (t instanceof InitializerListType) {",
                        "\t\t\t\treturn ((InitializerListType) t).getEvaluation().isTypeDependent();",
                        "\t\t\t} else if (t instanceof IBinding) {",
                        "\t\t\t\tIBinding owner = ((IBinding) t).getOwner();",
                        "\t\t\t\tif (owner instanceof IFunction) {",
                        "\t\t\t\t\tif (owner instanceof ICPPFunctionTemplate) {",
                        "\t\t\t\t\t\treturn true;",
                        "\t\t\t\t\t}",
                        "\t\t\t\t\towner = owner.getOwner();",
                        "\t\t\t\t}",
                        "\t\t\t\tif (owner instanceof ICPPClassTemplate)",
                        "\t\t\t\t\treturn true;",
                        "\t\t\t\treturn (owner instanceof IType) && owner != t && isDependentType((IType) owner);",
                        "\t\t\t} else {",
                        "\t\t\t\treturn false;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t}",
                        "",
                        "\tpublic static boolean containsDependentArg(ObjectMap tpMap) {",
                        "\t\tfor (Object arg : tpMap.valueArray()) {",
                        "\t\t\tif (isDependentType((IType) arg))",
                        "\t\t\t\treturn true;",
                        "\t\t}",
                        "\t\treturn false;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Attempts to (partially) resolve an unknown binding with the given arguments.",
                        "\t */",
                        "\tpublic static IBinding resolveUnknown(ICPPUnknownBinding unknown, InstantiationContext context)",
                        "\t\t\tthrows DOMException {",
                        "\t\tif (unknown instanceof ICPPDeferredClassInstance) {",
                        "\t\t\treturn resolveDeferredClassInstance((ICPPDeferredClassInstance) unknown, context);",
                        "\t\t}",
                        "\t\tif (unknown instanceof ICPPDeferredVariableInstance) {",
                        "\t\t\treturn resolveDeferredVariableInstance((ICPPDeferredVariableInstance) unknown, context);",
                        "\t\t}",
                        "\t\tif (unknown instanceof ICPPUnknownMember) {",
                        "\t\t\treturn resolveUnknownMember((ICPPUnknownMember) unknown, context);",
                        "\t\t}",
                        "\t\tif (unknown instanceof ICPPTemplateParameter && unknown instanceof IType) {",
                        "\t\t\tIType type = resolveTemplateTypeParameter((ICPPTemplateParameter) unknown, context);",
                        "\t\t\tif (type instanceof IBinding)",
                        "\t\t\t\treturn (IBinding) type;",
                        "\t\t}",
                        "\t\tif (unknown instanceof TypeOfDependentExpression) {",
                        "\t\t\tIType type = instantiateType((IType) unknown, context);",
                        "\t\t\tif (type instanceof IBinding)",
                        "\t\t\t\treturn (IBinding) type;",
                        "\t\t}",
                        "\t\treturn unknown;",
                        "\t}",
                        "",
                        "\tprivate static IBinding resolveUnknownMember(ICPPUnknownMember unknown, InstantiationContext context)",
                        "\t\t\tthrows DOMException {",
                        "\t\tfinal IType ot0 = unknown.getOwnerType();",
                        "\t\tif (ot0 == null)",
                        "\t\t\treturn unknown;",
                        "",
                        "\t\tIBinding result = unknown;",
                        "\t\tIType ot1 = instantiateType(ot0, context);",
                        "\t\tif (ot1 != null) {",
                        "\t\t\tot1 = SemanticUtil.getUltimateType(ot1, false);",
                        "\t\t\tif (ot1 instanceof ICPPUnknownType) {",
                        "\t\t\t\tif (unknown instanceof ICPPUnknownMemberClassInstance) {",
                        "\t\t\t\t\tICPPUnknownMemberClassInstance ucli = (ICPPUnknownMemberClassInstance) unknown;",
                        "\t\t\t\t\tICPPTemplateArgument[] args0 = ucli.getArguments();",
                        "\t\t\t\t\tICPPTemplateArgument[] args1 = instantiateArguments(args0, context, false);",
                        "\t\t\t\t\tif (args0 != args1 || !ot1.isSameType(ot0)) {",
                        "\t\t\t\t\t\targs1 = SemanticUtil.getSimplifiedArguments(args1);",
                        "\t\t\t\t\t\tresult = new CPPUnknownClassInstance(ot1, ucli.getNameCharArray(), args1);",
                        "\t\t\t\t\t}",
                        "\t\t\t\t} else if (!ot1.isSameType(ot0)) {",
                        "\t\t\t\t\tif (unknown instanceof ICPPUnknownMemberClass) {",
                        "\t\t\t\t\t\tresult = new CPPUnknownMemberClass(ot1, unknown.getNameCharArray());",
                        "\t\t\t\t\t} else {",
                        "\t\t\t\t\t\tresult = new CPPUnknownMethod(ot1, unknown.getNameCharArray());",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t} else if (ot1 instanceof ICPPClassType) {",
                        "\t\t\t\tIScope s = ((ICPPClassType) ot1).getCompositeScope();",
                        "\t\t\t\tif (s != null) {",
                        "\t\t\t\t\tresult = CPPSemantics.resolveUnknownName(s, unknown);",
                        "\t\t\t\t\tif (unknown instanceof ICPPUnknownMemberClassInstance && (result instanceof ICPPTemplateDefinition",
                        "\t\t\t\t\t\t\t|| result instanceof ICPPAliasTemplateInstance)) {",
                        "\t\t\t\t\t\tICPPTemplateArgument[] args1 = instantiateArguments(",
                        "\t\t\t\t\t\t\t\t((ICPPUnknownMemberClassInstance) unknown).getArguments(), context, false);",
                        "\t\t\t\t\t\tif (result instanceof ICPPClassTemplate) {",
                        "\t\t\t\t\t\t\tresult = instantiate((ICPPClassTemplate) result, args1);",
                        "\t\t\t\t\t\t} else if (result instanceof ICPPAliasTemplate) {",
                        "\t\t\t\t\t\t\tresult = instantiateAliasTemplate((ICPPAliasTemplate) result, args1);",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t} else if (ot1 != ot0) {",
                        "\t\t\t\treturn new ProblemBinding(new CPPASTName(unknown.getNameCharArray()),",
                        "\t\t\t\t\t\tCPPSemantics.getCurrentLookupPoint(), IProblemBinding.SEMANTIC_BAD_SCOPE);",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\treturn result;",
                        "\t}",
                        "",
                        "\tprivate static IBinding resolveDeferredClassInstance(ICPPDeferredClassInstance dci, InstantiationContext context) {",
                        "\t\tICPPClassTemplate classTemplate = dci.getClassTemplate();",
                        "\t\tICPPTemplateArgument[] arguments = dci.getTemplateArguments();",
                        "\t\tICPPTemplateArgument[] newArgs;",
                        "\t\ttry {",
                        "\t\t\tnewArgs = instantiateArguments(arguments, context, true);",
                        "\t\t} catch (DOMException e) {",
                        "\t\t\treturn e.getProblem();",
                        "\t\t}",
                        "\t\tif (newArgs == null)",
                        "\t\t\treturn createProblem(classTemplate, IProblemBinding.SEMANTIC_INVALID_TEMPLATE_ARGUMENTS);",
                        "",
                        "\t\tboolean changed = arguments != newArgs;",
                        "\t\tIType classTemplateSpecialization = instantiateType(classTemplate, context);",
                        "\t\tif (classTemplateSpecialization != classTemplate) {",
                        "\t\t\tif (classTemplateSpecialization instanceof ICPPClassTemplate) {",
                        "\t\t\t\tclassTemplate = (ICPPClassTemplate) classTemplateSpecialization;",
                        "\t\t\t\tchanged = true;",
                        "\t\t\t} else if (classTemplateSpecialization instanceof ICPPAliasTemplate) {",
                        "\t\t\t\tIBinding inst = instantiateAliasTemplate((ICPPAliasTemplate) classTemplateSpecialization, newArgs);",
                        "\t\t\t\tif (inst != null)",
                        "\t\t\t\t\treturn inst;",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\tif (changed) {",
                        "\t\t\tIBinding inst = instantiate(classTemplate, newArgs);",
                        "\t\t\tif (inst != null)",
                        "\t\t\t\treturn inst;",
                        "\t\t}",
                        "\t\treturn dci;",
                        "\t}",
                        "",
                        "\tprivate static IBinding resolveDeferredVariableInstance(ICPPDeferredVariableInstance dvi,",
                        "\t\t\tInstantiationContext context) {",
                        "\t\tICPPVariableTemplate variableTemplate = dvi.getTemplateDefinition();",
                        "\t\tICPPTemplateArgument[] arguments = dvi.getTemplateArguments();",
                        "\t\tICPPTemplateArgument[] newArgs;",
                        "\t\ttry {",
                        "\t\t\tnewArgs = instantiateArguments(arguments, context, true);",
                        "\t\t} catch (DOMException e) {",
                        "\t\t\treturn e.getProblem();",
                        "\t\t}",
                        "\t\tif (newArgs == null) {",
                        "\t\t\treturn createProblem(variableTemplate, IProblemBinding.SEMANTIC_INVALID_TEMPLATE_ARGUMENTS);",
                        "\t\t}",
                        "",
                        "\t\t// Unlike class templates, variable templates cannot be passed as template template arguments,",
                        "\t\t// so there is no need to instantiate the template itself.",
                        "",
                        "\t\tif (arguments != newArgs) {",
                        "\t\t\tIBinding inst = instantiate(variableTemplate, newArgs);",
                        "\t\t\tif (inst != null)",
                        "\t\t\t\treturn inst;",
                        "\t\t}",
                        "\t\treturn dvi;",
                        "\t}",
                        "",
                        "\tpublic static boolean haveSameArguments(ICPPTemplateInstance i1, ICPPTemplateInstance i2) {",
                        "\t\tfinal ICPPTemplateArgument[] m1 = i1.getTemplateArguments();",
                        "\t\tfinal ICPPTemplateArgument[] m2 = i2.getTemplateArguments();",
                        "",
                        "\t\tif (m1 == null || m2 == null || m1.length != m2.length)",
                        "\t\t\treturn false;",
                        "",
                        "\t\tString s1 = ASTTypeUtil.getArgumentListString(m1, true);",
                        "\t\tString s2 = ASTTypeUtil.getArgumentListString(m2, true);",
                        "\t\treturn s1.equals(s2);",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Creates a template parameter map for the given template definition and template arguments. The template",
                        "\t * arguments are adjusted by converting types of the non-type arguments to match the types of the template",
                        "\t * parameters.",
                        "\t *",
                        "\t * @param template the template definition",
                        "\t * @param arguments the template arguments; arguments may be modified by this method due to type",
                        "\t *     conversion performed for non-type arguments",
                        "\t * @return the created template parameter map, or {@code null} if the arguments are invalid",
                        "\t */",
                        "\tprivate static CPPTemplateParameterMap createParameterMap(ICPPTemplateDefinition template,",
                        "\t\t\tICPPTemplateArgument[] arguments) {",
                        "\t\tfinal ICPPTemplateParameter[] parameters = template.getTemplateParameters();",
                        "\t\tfinal int numArgs = arguments.length;",
                        "\t\tfinal int numParams = parameters.length;",
                        "\t\tfinal int length = Math.max(numArgs, numParams);",
                        "",
                        "\t\tCPPTemplateParameterMap map = new CPPTemplateParameterMap(numParams);",
                        "",
                        "\t\tboolean isPack = false;",
                        "\t\tICPPTemplateParameter param = null;",
                        "\t\tfor (int i = 0; i < length; i++) {",
                        "\t\t\tif (!isPack || param == null) {",
                        "\t\t\t\tif (i >= numParams)",
                        "\t\t\t\t\treturn null;",
                        "\t\t\t\tparam = parameters[i];",
                        "\t\t\t\tisPack = param.isParameterPack();",
                        "\t\t\t}",
                        "\t\t\tif (i < numArgs) {",
                        "\t\t\t\tICPPTemplateArgument arg = arguments[i];",
                        "\t\t\t\tICPPTemplateArgument newArg = matchTemplateParameterAndArgument(template, param, arg, map);",
                        "\t\t\t\tif (newArg == null)",
                        "\t\t\t\t\treturn null;",
                        "\t\t\t\tif (newArg != arg) {",
                        "\t\t\t\t\targuments[i] = newArg;",
                        "\t\t\t\t}",
                        "\t\t\t\tif (!isPack) {",
                        "\t\t\t\t\tmap.put(param, newArg);",
                        "\t\t\t\t}",
                        "\t\t\t} else {",
                        "\t\t\t\t// Parameter pack with empty arguments.",
                        "\t\t\t\tassert isPack;",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\tif (isPack) {",
                        "\t\t\tint packOffset = numParams - 1;",
                        "\t\t\tint packSize = numArgs - packOffset;",
                        "\t\t\tICPPTemplateArgument[] pack = new ICPPTemplateArgument[packSize];",
                        "\t\t\tSystem.arraycopy(arguments, packOffset, pack, 0, packSize);",
                        "\t\t\tmap.put(param, pack);",
                        "\t\t}",
                        "\t\treturn map;",
                        "\t}",
                        "",
                        "\tpublic static IBinding findDeclarationForSpecialization(IBinding binding) {",
                        "\t\twhile (binding instanceof ICPPSpecialization) {",
                        "\t\t\tif (ASTInternal.hasDeclaration(binding))",
                        "\t\t\t\treturn binding;",
                        "",
                        "\t\t\tIBinding original = ((ICPPSpecialization) binding).getSpecializedBinding();",
                        "\t\t\tif (original == null)",
                        "\t\t\t\treturn binding;",
                        "\t\t\tbinding = original;",
                        "\t\t}",
                        "\t\treturn binding;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Returns the instantiated function body of the given function specialization.",
                        "\t */",
                        "\tpublic static ICPPExecution instantiateFunctionBody(ICPPFunctionSpecialization f) {",
                        "\t\tICPPFunction spec = (ICPPFunction) f.getSpecializedBinding();",
                        "\t\tICPPExecution exec = null;",
                        "\t\tif (spec instanceof ICPPComputableFunction) {",
                        "\t\t\texec = ((ICPPComputableFunction) spec).getFunctionBodyExecution();",
                        "\t\t\tif (exec != null) {",
                        "\t\t\t\tInstantiationContext context = new InstantiationContext(f.getTemplateParameterMap(), f);",
                        "\t\t\t\tCPPTemplates.addInstantiatedParameters(context, f);",
                        "\t\t\t\texec = exec.instantiate(context, IntegralValue.MAX_RECURSION_DEPTH);",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\treturn exec;",
                        "\t}",
                        "",
                        "\tprivate static void addInstantiatedParameters(InstantiationContext context, ICPPFunctionSpecialization spec) {",
                        "\t\tICPPFunction specialized = (ICPPFunction) spec.getSpecializedBinding();",
                        "\t\tICPPParameter paramSpecs[] = spec.getParameters();",
                        "\t\tICPPParameter specializedParams[] = specialized.getParameters();",
                        "\t\tfor (int i = 0; i < paramSpecs.length; i++) {",
                        "\t\t\tfinal ICPPParameter paramSpecialization = paramSpecs[i];",
                        "\t\t\tfinal ICPPParameter specializedParam = specializedParams[i];",
                        "\t\t\tcontext.putInstantiatedLocal(specializedParam, paramSpecialization);",
                        "\t\t\tif (specializedParam.isParameterPack()) {",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Returns the instantiated constructor chain of the given constructor specialization.",
                        "\t */",
                        "\tpublic static ICPPExecution instantiateConstructorChain(ICPPConstructorSpecialization f) {",
                        "\t\tICPPConstructor spec = (ICPPConstructor) f.getSpecializedBinding();",
                        "\t\tICPPExecution exec = null;",
                        "\t\tif (spec != null) {",
                        "\t\t\texec = spec.getConstructorChainExecution();",
                        "\t\t\tif (exec != null) {",
                        "\t\t\t\tInstantiationContext context = new InstantiationContext(f.getTemplateParameterMap(), f);",
                        "\t\t\t\texec = exec.instantiate(context, IntegralValue.MAX_RECURSION_DEPTH);",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\treturn exec;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * If 'name' is a destructor-name, return the name of the type (i.e. the",
                        "\t * portion following the '~'). Otherwise return null.",
                        "\t */",
                        "\tpublic static String unwrapDestructorName(char[] name) {",
                        "\t\tif (name == null || name.length == 0 || name[0] != '~') {",
                        "\t\t\treturn null;",
                        "\t\t}",
                        "\t\treturn new String(name).substring(1).trim();",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Instantiate a plain name (simple-id).",
                        "\t * Only destructor names require instantiation, e.g. the name \"~T\", when instantiated",
                        "\t * with a parameter map that maps T to C, needs to become \"~C\".",
                        "\t *",
                        "\t * @param name the name to be instantiated",
                        "\t * @param context the instantiation context",
                        "\t * @param enclosingTemplate The enclosing template definition. This is required because the",
                        "\t *                          instantiation context doesn't actually store parameter names, so",
                        "\t *                          we need to walk the chain of enclosing templates to find potential",
                        "\t *                          template parameter names.",
                        "\t * @return The instantiated name. If the provided name is not a destructor name, or if",
                        "\t *         the type named by the destructor name is not mapped to anything in the",
                        "\t *         instantiation context's parameter map, the provided name is returned unchanged.",
                        "\t */",
                        "\tpublic static char[] instantiateName(char[] name, InstantiationContext context, IBinding enclosingTemplate) {",
                        "\t\tString typename = unwrapDestructorName(name);",
                        "\t\tif (typename == null) { // not a destructor-name",
                        "\t\t\treturn name;",
                        "\t\t}",
                        "\t\tICPPTemplateParameterMap map = context.getParameterMap();",
                        "\t\tIBinding enclosing = enclosingTemplate;",
                        "\t\twhile (enclosing != null) {",
                        "\t\t\tif (enclosing instanceof ICPPTemplateDefinition) {",
                        "\t\t\t\tfor (ICPPTemplateParameter param : ((ICPPTemplateDefinition) enclosing).getTemplateParameters()) {",
                        "\t\t\t\t\tif (param instanceof ICPPTemplateTypeParameter) {",
                        "\t\t\t\t\t\tif (param.getName().equals(typename)) {",
                        "\t\t\t\t\t\t\tICPPTemplateArgument arg = map.getArgument(param);",
                        "\t\t\t\t\t\t\tif (arg instanceof CPPTemplateTypeArgument) {",
                        "\t\t\t\t\t\t\t\tIType argType = arg.getTypeValue();",
                        "\t\t\t\t\t\t\t\targType = SemanticUtil.getNestedType(argType, CVTYPE | TDEF);",
                        "\t\t\t\t\t\t\t\tif (argType instanceof ICPPClassType) {",
                        "\t\t\t\t\t\t\t\t\t// Destructor for class type.",
                        "\t\t\t\t\t\t\t\t\tStringBuilder result = new StringBuilder();",
                        "\t\t\t\t\t\t\t\t\tresult.append('~');",
                        "\t\t\t\t\t\t\t\t\tresult.append(((ICPPClassType) argType).getName());",
                        "\t\t\t\t\t\t\t\t\treturn result.toString().toCharArray();",
                        "\t\t\t\t\t\t\t\t} else if (argType instanceof ICPPBasicType) {",
                        "\t\t\t\t\t\t\t\t\t// Pseudo-destructor for builtin type.",
                        "\t\t\t\t\t\t\t\t\tStringBuilder result = new StringBuilder();",
                        "\t\t\t\t\t\t\t\t\tresult.append('~');",
                        "\t\t\t\t\t\t\t\t\tASTTypeUtil.appendType(argType, true, result);",
                        "\t\t\t\t\t\t\t\t\treturn result.toString().toCharArray();",
                        "\t\t\t\t\t\t\t\t}",
                        "\t\t\t\t\t\t\t}",
                        "\t\t\t\t\t\t}",
                        "\t\t\t\t\t}",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t\tenclosing = enclosing.getOwner();",
                        "\t\t}",
                        "\t\treturn name;",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Checks whether a binding is fully instantiated, that is, it does not depend on template",
                        "\t * parameters that do not yet have values.",
                        "\t */",
                        "\tpublic static boolean isFullyInstantiated(IBinding binding) {",
                        "\t\twhile (binding != null) {",
                        "\t\t\tbinding = binding.getOwner();",
                        "\t\t\tif (binding instanceof ICPPTemplateDefinition) {",
                        "\t\t\t\treturn false;",
                        "\t\t\t}",
                        "\t\t\tif (!(binding instanceof ICPPClassType)) {",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\treturn true;",
                        "\t}",
                        "",
                        "\tprivate static Map<TypeInstantiationRequest, IType> getInstantiationCache() {",
                        "\t\tIASTNode lookupPoint = CPPSemantics.getCurrentLookupPoint();",
                        "\t\tif (lookupPoint != null) {",
                        "\t\t\tIASTTranslationUnit tu = lookupPoint.getTranslationUnit();",
                        "\t\t\tif (tu instanceof CPPASTTranslationUnit) {",
                        "\t\t\t\treturn ((CPPASTTranslationUnit) tu).getInstantiationCache();",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\treturn null;",
                        "\t}",
                        "",
                        "\tprivate static IType getCachedInstantiation(TypeInstantiationRequest instantiationRequest) {",
                        "\t\tMap<TypeInstantiationRequest, IType> cache = getInstantiationCache();",
                        "\t\treturn cache != null ? cache.get(instantiationRequest) : null;",
                        "\t}",
                        "",
                        "\tprivate static void putCachedInstantiation(TypeInstantiationRequest instantiationRequest, IType result) {",
                        "\t\tMap<TypeInstantiationRequest, IType> cache = getInstantiationCache();",
                        "\t\tif (cache != null) {",
                        "\t\t\tcache.put(instantiationRequest, result);",
                        "\t\t}",
                        "\t}",
                        "}",
                        ""
                    ]
                }
            ]
        },
        "core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/FunctionCost.java": {
            "meta_a": {
                "name": "core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/FunctionCost.java",
                "content_type": "text/x-java",
                "lines": 302,
                "web_links": [
                    {
                        "name": "browse",
                        "url": "/r/plugins/gitiles/cdt/org.eclipse.cdt/+/d085e955c72e7ce382620a78dee2643e093d9d96/core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/FunctionCost.java",
                        "target": "_blank"
                    }
                ]
            },
            "meta_b": {
                "name": "core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/FunctionCost.java",
                "content_type": "text/x-java",
                "lines": 307,
                "web_links": [
                    {
                        "name": "browse",
                        "url": "/r/plugins/gitiles/cdt/org.eclipse.cdt/+/refs/changes/40/133040/1/core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/FunctionCost.java",
                        "target": "_blank"
                    }
                ]
            },
            "change_type": "MODIFIED",
            "diff_header": [
                "diff --git a/core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/FunctionCost.java b/core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/FunctionCost.java",
                "index a483390..3f58408 100644",
                "--- a/core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/FunctionCost.java",
                "+++ b/core/org.eclipse.cdt.core/parser/org/eclipse/cdt/internal/core/dom/parser/cpp/semantics/FunctionCost.java"
            ],
            "content": [
                {
                    "ab": [
                        "/*******************************************************************************",
                        " * Copyright (c) 2009, 2015 Wind River Systems, Inc. and others.",
                        " *",
                        " * This program and the accompanying materials",
                        " * are made available under the terms of the Eclipse Public License 2.0",
                        " * which accompanies this distribution, and is available at",
                        " * https://www.eclipse.org/legal/epl-2.0/",
                        " *",
                        " * SPDX-License-Identifier: EPL-2.0",
                        " *",
                        " * Contributors:",
                        " *     Markus Schorn - initial API and implementation",
                        " *******************************************************************************/",
                        "package org.eclipse.cdt.internal.core.dom.parser.cpp.semantics;",
                        "",
                        "import static org.eclipse.cdt.internal.core.dom.parser.cpp.semantics.CPPTemplates.TypeSelection.PARAMETERS;",
                        "import static org.eclipse.cdt.internal.core.dom.parser.cpp.semantics.CPPTemplates.TypeSelection.RETURN_TYPE;",
                        "import static org.eclipse.cdt.internal.core.dom.parser.cpp.semantics.SemanticUtil.CVTYPE;",
                        "import static org.eclipse.cdt.internal.core.dom.parser.cpp.semantics.SemanticUtil.REF;",
                        "import static org.eclipse.cdt.internal.core.dom.parser.cpp.semantics.SemanticUtil.TDEF;",
                        "import static org.eclipse.cdt.internal.core.dom.parser.cpp.semantics.SemanticUtil.getNestedType;",
                        "",
                        "import java.util.Arrays;",
                        "",
                        "import org.eclipse.cdt.core.dom.ast.DOMException;",
                        "import org.eclipse.cdt.core.dom.ast.IASTExpression.ValueCategory;",
                        "import org.eclipse.cdt.core.dom.ast.IASTTranslationUnit;",
                        "import org.eclipse.cdt.core.dom.ast.IBinding;",
                        "import org.eclipse.cdt.core.dom.ast.IFunction;",
                        "import org.eclipse.cdt.core.dom.ast.IType;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPClassType;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPFunction;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPFunctionTemplate;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPFunctionType;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPMethod;",
                        "import org.eclipse.cdt.core.dom.ast.cpp.ICPPSpecialization;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.OverloadableOperator;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.semantics.CPPTemplates.TypeSelection;",
                        "import org.eclipse.cdt.internal.core.dom.parser.cpp.semantics.Cost.DeferredUDC;",
                        "",
                        "/**",
                        " * Cost for the entire function call.",
                        " */",
                        "class FunctionCost {",
                        "\tprivate final ICPPFunction fFunction;",
                        "\tprivate final Cost[] fCosts;",
                        "\tprivate final ValueCategory[] fValueCategories;",
                        "\tprivate boolean fIsDirectCopyCtor;",
                        "",
                        "\tpublic FunctionCost(ICPPFunction fn, int paramCount) {",
                        "\t\tfFunction = fn;",
                        "\t\tfCosts = new Cost[paramCount];",
                        "\t\tfValueCategories = new ValueCategory[paramCount];",
                        "\t}",
                        "",
                        "\tpublic FunctionCost(ICPPFunction fn, Cost cost) {",
                        "\t\tfFunction = fn;",
                        "\t\tfCosts = new Cost[] { cost };",
                        "\t\tfValueCategories = null; // no udc will be performed",
                        "\t}",
                        "",
                        "\tpublic int getLength() {",
                        "\t\treturn fCosts.length;",
                        "\t}",
                        "",
                        "\tpublic Cost getCost(int idx) {",
                        "\t\treturn fCosts[idx];",
                        "\t}",
                        "",
                        "\tpublic void setCost(int idx, Cost cost, ValueCategory valueCat) {",
                        "\t\tfCosts[idx] = cost;",
                        "\t\tfValueCategories[idx] = valueCat;",
                        "\t}",
                        "",
                        "\tpublic ICPPFunction getFunction() {",
                        "\t\treturn fFunction;",
                        "\t}",
                        "",
                        "\tpublic boolean hasAmbiguousUserDefinedConversion() {",
                        "\t\tfor (Cost cost : fCosts) {",
                        "\t\t\tif (cost.isAmbiguousUDC())",
                        "\t\t\t\treturn true;",
                        "\t\t}",
                        "\t\treturn false;",
                        "\t}",
                        "",
                        "\tpublic boolean hasDeferredUDC() {",
                        "\t\tfor (Cost cost : fCosts) {",
                        "\t\t\tif (!cost.converts())",
                        "\t\t\t\treturn false;",
                        "\t\t\tif (cost.isDeferredUDC() != DeferredUDC.NONE)",
                        "\t\t\t\treturn true;",
                        "\t\t}",
                        "\t\treturn false;",
                        "\t}",
                        "",
                        "\tpublic boolean performUDC() throws DOMException {",
                        "\t\tfor (int i = 0; i < fCosts.length; i++) {",
                        "\t\t\tCost cost = fCosts[i];",
                        "\t\t\tCost udcCost = null;",
                        "\t\t\tswitch (cost.isDeferredUDC()) {",
                        "\t\t\tcase NONE:",
                        "\t\t\t\tcontinue;",
                        "\t\t\tcase COPY_INIT_OF_CLASS:",
                        "\t\t\t\tudcCost = Conversions.copyInitializationOfClass(fValueCategories[i], cost.source,",
                        "\t\t\t\t\t\t(ICPPClassType) cost.target, false);",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase INIT_BY_CONVERSION:",
                        "\t\t\t\tIType uqSource = getNestedType(cost.source, TDEF | REF | CVTYPE);",
                        "\t\t\t\tudcCost = Conversions.initializationByConversion(fValueCategories[i], cost.source,",
                        "\t\t\t\t\t\t(ICPPClassType) uqSource, cost.target, false, allowsContextualBooleanConversion());",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase LIST_INIT_OF_CLASS:",
                        "\t\t\t\tudcCost = Conversions.listInitializationOfClass(((InitializerListType) cost.source).getEvaluation(),",
                        "\t\t\t\t\t\t(ICPPClassType) cost.target, false, false);",
                        "\t\t\t\tbreak;",
                        "\t\t\tcase DIRECT_LIST_INIT_OF_CLASS:",
                        "\t\t\t\tudcCost = Conversions.listInitializationOfClass(((InitializerListType) cost.source).getEvaluation(),",
                        "\t\t\t\t\t\t(ICPPClassType) cost.target, true, false);",
                        "\t\t\t\tbreak;",
                        "\t\t\tdefault:",
                        "\t\t\t\treturn false;",
                        "\t\t\t}",
                        "\t\t\tfCosts[i] = udcCost;",
                        "\t\t\tif (!udcCost.converts()) {",
                        "\t\t\t\treturn false;",
                        "\t\t\t}",
                        "\t\t\tudcCost.setReferenceBinding(cost.getReferenceBinding());",
                        "\t\t}",
                        "\t\treturn true;",
                        "\t}",
                        "",
                        "\tprivate boolean allowsContextualBooleanConversion() {",
                        "\t\tchar[] functionName = fFunction.getNameCharArray();",
                        "\t\treturn Arrays.equals(functionName, OverloadableOperator.AND.toCharArray())",
                        "\t\t\t\t|| Arrays.equals(functionName, OverloadableOperator.OR.toCharArray())",
                        "\t\t\t\t|| Arrays.equals(functionName, OverloadableOperator.NOT.toCharArray());",
                        "\t}",
                        "",
                        "\t/**",
                        "\t * Compares this function call cost to another one.",
                        "\t */"
                    ]
                },
                {
                    "a": [
                        "\tpublic int compareTo(IASTTranslationUnit tu, FunctionCost other) throws DOMException {"
                    ],
                    "b": [
                        "\tpublic int compareTo(IASTTranslationUnit tu, FunctionCost other, LookupData data) throws DOMException {"
                    ]
                },
                {
                    "ab": [
                        "\t\tif (other == null)",
                        "\t\t\treturn -1;",
                        "",
                        "\t\tboolean haveWorse = false;",
                        "\t\tboolean haveBetter = false;",
                        "\t\t// In order for this function to be better than the previous best, it must",
                        "\t\t// have at least one parameter match that is better that the corresponding",
                        "\t\t// match for the other function, and none that are worse.",
                        "\t\tint idx = getLength() - 1;",
                        "\t\tint idxOther = other.getLength() - 1;",
                        "\t\tfor (; idx >= 0 && idxOther >= 0; idx--, idxOther--) {",
                        "\t\t\tCost cost = getCost(idx);",
                        "\t\t\tif (!cost.converts()) {",
                        "\t\t\t\thaveWorse = true;",
                        "\t\t\t\thaveBetter = false;",
                        "\t\t\t\tbreak;",
                        "\t\t\t}",
                        "",
                        "\t\t\tint cmp = cost.compareTo(other.getCost(idxOther));",
                        "\t\t\thaveWorse |= (cmp > 0);",
                        "\t\t\thaveBetter |= (cmp < 0);",
                        "\t\t}",
                        "",
                        "\t\tfinal ICPPFunction f1 = getFunction();",
                        "\t\tfinal ICPPFunction f2 = other.getFunction();",
                        "\t\tif (!haveWorse && !haveBetter) {",
                        "\t\t\t// If they are both template functions, we can order them that way",
                        "\t\t\tICPPFunctionTemplate asTemplate = asTemplate(f1);",
                        "\t\t\tICPPFunctionTemplate otherAsTemplate = asTemplate(f2);",
                        "\t\t\tfinal boolean isTemplate = asTemplate != null;",
                        "\t\t\tfinal boolean otherIsTemplate = otherAsTemplate != null;",
                        "",
                        "\t\t\t// Prefer normal functions over template functions",
                        "\t\t\tif (isTemplate && !otherIsTemplate) {",
                        "\t\t\t\thaveWorse = true;",
                        "\t\t\t} else if (!isTemplate && otherIsTemplate) {",
                        "\t\t\t\thaveBetter = true;",
                        "\t\t\t} else if (isTemplate && otherIsTemplate) {",
                        "\t\t\t\tTypeSelection ts = SemanticUtil.isConversionOperator(f1) ? RETURN_TYPE : PARAMETERS;"
                    ]
                },
                {
                    "a": [
                        "\t\t\t\tint order = CPPTemplates.orderFunctionTemplates(otherAsTemplate, asTemplate, ts);"
                    ],
                    "b": [
                        "\t\t\t\tint order = CPPTemplates.orderFunctionTemplates(otherAsTemplate, asTemplate, ts,",
                        "\t\t\t\t\t\tdata != null ? data.getFunctionArgumentCount() : 0);"
                    ]
                },
                {
                    "ab": [
                        "\t\t\t\tif (order < 0) {",
                        "\t\t\t\t\thaveBetter = true;",
                        "\t\t\t\t} else if (order > 0) {",
                        "\t\t\t\t\thaveWorse = true;",
                        "\t\t\t\t}",
                        "\t\t\t}",
                        "\t\t}",
                        "",
                        "\t\tif (haveBetter == haveWorse) {",
                        "\t\t\t// 7.3.3-15 Using declarations in classes can be overridden",
                        "\t\t\tint cmp = overridesUsingDeclaration(f1, f2);",
                        "\t\t\tif (cmp != 0)",
                        "\t\t\t\treturn cmp;",
                        "",
                        "\t\t\t// At this point prefer non-index bindings",
                        "\t\t\treturn -CPPSemantics.compareByRelevance(tu, f1, f2);",
                        "\t\t}",
                        "",
                        "\t\tif (haveBetter)",
                        "\t\t\treturn -1;",
                        "",
                        "\t\treturn 1;",
                        "\t}",
                        ""
                    ]
                },
                {
                    "b": [
                        "\tpublic int compareTo(IASTTranslationUnit tu, FunctionCost other) throws DOMException {",
                        "\t\treturn compareTo(tu, other, null);",
                        "\t}",
                        ""
                    ]
                },
                {
                    "ab": [
                        "\tprivate int overridesUsingDeclaration(ICPPFunction f1, ICPPFunction f2) {",
                        "\t\tif (f1.takesVarArgs() != f2.takesVarArgs())",
                        "\t\t\treturn 0;",
                        "\t\tif (!(f1 instanceof ICPPMethod && f2 instanceof ICPPMethod))",
                        "\t\t\treturn 0;",
                        "",
                        "\t\tfinal ICPPMethod m1 = (ICPPMethod) f1;",
                        "\t\tfinal ICPPMethod m2 = (ICPPMethod) f2;",
                        "\t\tICPPClassType o1 = m1.getClassOwner();",
                        "\t\tICPPClassType o2 = m2.getClassOwner();",
                        "\t\tif (o1.isSameType(o2))",
                        "\t\t\treturn 0;",
                        "",
                        "\t\tfinal ICPPFunctionType ft1 = m1.getType();",
                        "\t\tfinal ICPPFunctionType ft2 = m2.getType();",
                        "\t\tif (ft1.isConst() != ft2.isConst() || ft2.isVolatile() != ft2.isVolatile())",
                        "\t\t\treturn 0;",
                        "",
                        "\t\tif (!parameterTypesMatch(ft1, ft2))",
                        "\t\t\treturn 0;",
                        "",
                        "\t\tint diff = SemanticUtil.calculateInheritanceDepth(o2, o1);",
                        "\t\tif (diff >= 0)",
                        "\t\t\treturn diff;",
                        "\t\treturn -SemanticUtil.calculateInheritanceDepth(o1, o2);",
                        "\t}",
                        "",
                        "\tprivate boolean parameterTypesMatch(final ICPPFunctionType ft1, final ICPPFunctionType ft2) {",
                        "\t\tIType[] p1 = ft1.getParameterTypes();",
                        "\t\tIType[] p2 = ft2.getParameterTypes();",
                        "\t\tif (p1.length != p2.length) {",
                        "\t\t\tif (p1.length == 0)",
                        "\t\t\t\treturn p2.length == 1 && SemanticUtil.isVoidType(p2[0]);",
                        "\t\t\tif (p2.length == 0)",
                        "\t\t\t\treturn p1.length == 1 && SemanticUtil.isVoidType(p1[0]);",
                        "\t\t\treturn false;",
                        "\t\t}",
                        "",
                        "\t\tfor (int i = 0; i < p2.length; i++) {",
                        "\t\t\tif (!p1[i].isSameType(p2[i])) {",
                        "\t\t\t\treturn false;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\treturn true;",
                        "\t}",
                        "",
                        "\tpublic boolean mustBeWorse(FunctionCost other) {",
                        "\t\tif (other == null)",
                        "\t\t\treturn false;",
                        "",
                        "\t\tboolean haveWorse = false;",
                        "\t\tint idx = getLength() - 1;",
                        "\t\tint idxOther = other.getLength() - 1;",
                        "\t\tfor (; idx >= 0 && idxOther >= 0; idx--, idxOther--) {",
                        "\t\t\tCost cost = getCost(idx);",
                        "\t\t\tif (!cost.converts())",
                        "\t\t\t\treturn true;",
                        "",
                        "\t\t\tCost otherCost = other.getCost(idxOther);",
                        "",
                        "\t\t\tint cmp;",
                        "\t\t\tif (cost.isDeferredUDC() != DeferredUDC.NONE) {",
                        "\t\t\t\tcmp = cost.getRank().compareTo(otherCost.getRank());",
                        "\t\t\t} else {",
                        "\t\t\t\tcmp = cost.compareTo(otherCost);",
                        "\t\t\t}",
                        "",
                        "\t\t\tif (cmp < 0)",
                        "\t\t\t\treturn false;",
                        "\t\t\tif (cmp > 0)",
                        "\t\t\t\thaveWorse = true;",
                        "\t\t}",
                        "",
                        "\t\treturn haveWorse;",
                        "\t}",
                        "",
                        "\tprivate static ICPPFunctionTemplate asTemplate(IFunction function) {",
                        "\t\tif (function instanceof ICPPSpecialization) {",
                        "\t\t\tIBinding original = ((ICPPSpecialization) function).getSpecializedBinding();",
                        "\t\t\tif (original instanceof ICPPFunctionTemplate) {",
                        "\t\t\t\treturn (ICPPFunctionTemplate) original;",
                        "\t\t\t}",
                        "\t\t}",
                        "\t\treturn null;",
                        "\t}",
                        "",
                        "\tpublic void setIsDirectInitWithCopyCtor(boolean val) {",
                        "\t\tfIsDirectCopyCtor = val;",
                        "\t}",
                        "",
                        "\tpublic boolean isDirectInitWithCopyCtor() {",
                        "\t\treturn fIsDirectCopyCtor;",
                        "\t}",
                        "}",
                        ""
                    ]
                }
            ]
        }
    }
}